#!/usr/bin/perl -w
#
# tv_grab_az_sdjson_sqlite
#
# Copyright (c) 2016, 2017 Gary Buhrmaster <gary.buhrmaster@gmail.com>
#
# This code is distributed under the GNU General Public License v2 (GPLv2)
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# version 2 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
#
# For extended help information run
#     tv_grab_az_sdjson_sqlite --info
#
#
# NOTE - Automated XMLTV testing will report failure since Schedules Direct
# requires an account for downloading of data.  The automated testing
# likely needs a way (a new capability?) that indicates that the grabber
# cannot be tested.  In addition, for many real world lineups, we again
# fall into the different interpretations of the terms "station" and
# "channel".  Unlike how XMLTV uses the term, we consider a "station"
# as a programming entity which has a schedule of programs.  A "channel"
# is a technical means of delivering a particular "station".  XMLTV
# uses channel when they mean station.  For many lineups (for example,
# a cable/satellite provider, or OTA repeaters) the exact same "station"
# is on multiple "channels", which results in "duplicate" messages from
# the automated testing tool which presumes that the channels need not
# be duplicated.  In an ideal world, that might be true, but as the
# channel (in XMLTV terms) is also overloaded with the display name
# which is used for automated discovery and updates in PVRs, we report
# each "channel" seperately, even when the "station" is the same.
#
#
# Version history:
#
# 2017/11/30 - 1.35 - Populate thetvdb episode-num.
# 2017/10/11 - 1.34 - download artwork.
# 2018/11/10 - 1.60 - include subscription info in additional paths
# 2018/11/03 - 1.59 - additional protection against bad data
# 2018/10/30 - 1.58 - initial protections against bad data
# 2018/09/15 - 1.57 - support lineup selection by transmitter
# 2018/09/15 - 1.56 - enhance obtainAvailble to use uri
# 2018/09/14 - 1.55 - support explicit lineup name for --manage-lineup add
# 2018/09/13 - 1.54 - revise previously-shown (new is new and no supplemental)
# 2018/09/05 - 1.53 - multi-lineup plumbing - configure
# 2018/09/05 - 1.52 - add initial Schedules Direct "IPTV" transport
# 2018/09/05 - 1.51 - multi-lineup plumbing - getLineup (v2)
# 2018/09/05 - 1.50 - provide proper bind data types
# 2018/09/04 - 1.49 - support short-name in getLineup for other types
# 2018/09/03 - 1.48 - use available channum
# 2018/09/02 - 1.47 - remove dead code
# 2018/09/02 - 1.46 - fix grammer
# 2018/08/30 - 1.45 - multi-lineup plumbing - mainline code
# 2018/08/30 - 1.44 - multi-lineup plumbing - getLineup
# 2018/08/30 - 1.43 - multi-lineup plumbing - SD_isLineupFetchRequired
# 2018/08/30 - 1.42 - multi-lineup plumbing - lineupValidate
# 2018/08/30 - 1.41 - multi-lineup plumbing - channelWriter
# 2018/08/29 - 1.40 - multi-lineup plumbing - SD_cleanLineups
# 2018/08/29 - 1.39 - multi-lineup plumbing - canonical lineup details
# 2018/08/25 - 1.38 - remove dead code
# 2018/08/25 - 1.37 - minor whitespace adjustments
# 2018/06/17 - 1.36 - handle deleted lineups not having description
# 2018/02/03 - 1.35 - remove lang from channel display-name
# 2018/02/03 - 1.34 - remove use warning nonfatal experimental in package
# 2017/07/21 - 1.33 - dtd compliance.  Only actors can have roles
# 2017/06/19 - 1.32 - derive category from showtype
# 2017/04/20 - 1.31 - provide fixup support
# 2017/04/18 - 1.30 - fix typo (in version history)
# 2017/04/06 - 1.29 - add supplemental SHow data to EPisodes
# 2017/04/02 - 1.28 - misc. code cleanup
# 2017/03/26 - 1.27 - misc. code cleanup
# 2017/03/21 - 1.26 - fix sth typos
# 2017/03/21 - 1.25 - fix trailing whitespace
# 2016/09/10 - 1.24 - change (improve) cast mapping
# 2016/09/10 - 1.23 - remove use warning nonfatal experimental decl
# 2016/08/25 - 1.22 - no warning messages for malformed SD data if quiet
# 2016/08/25 - 1.21 - additional error checking of SD data
# 2016/08/24 - 1.20 - correct sql error reporting
# 2016/08/03 - 1.19 - reflect multinational capability (and fix docs)
# 2016/08/03 - 1.18 - rename grabber based on xmltv agreed convention
# 2016/07/30 - 1.17 - don't report radio stations as tvshow category
# 2016/07/30 - 1.16 - eliminate XML:Writer validation for performance
# 2016/07/17 - 1.15 - use Digest::SHA rather than Digest::SHA1
# 2016/06/07 - 1.14 - support multipart episodes
# 2016/06/07 - 1.13 - improved season/episode value checks
# 2016/05/28 - 1.12 - add support for episodeImage
# 2016/05/26 - 1.11 - use program duration as length
# 2016/05/26 - 1.10 - hack for tv_find_grabbers source parsing of desc
# 2016/05/25 - 1.9 - Support total seasons, and more robust validation
# 2016/05/24 - 1.8 - retry limit updates and get-lineup improvements
# 2016/05/21 - 1.7 - protect against bad json returned by server
# 2016/05/21 - 1.6 - correct (mis)use of global variable in package
# 2016/05/20 - 1.5 - minor output formatting improvements for xmltv_ns
# 2016/05/19 - 1.4 - correct totalEpisodes output
# 2016/05/19 - 1.3 - add support for totalEpisodes metadata
# 2016/04/28 - 1.2 - update version number in history and output
# 2016/04/23 - 1.1 - Minor update for improved(?) category ordering
# 2016/04/01 - 1.0 - First release
#

eval 'exec /usr/bin/perl -w -S $0 ${1+"$@"}' if 0; # not running under some shell

require 5.016;
use feature ':5.16';

use strict;
use warnings FATAL => 'all';
use warnings NONFATAL => qw(exec recursion internal malloc newline deprecated portable);
no warnings 'once';

use utf8;

STDERR->autoflush(1);                          # Autoflush STDERR

use XMLTV 0.005067;
use XMLTV::Options qw/ParseOptions/;
use XMLTV::Configure::Writer;
use XMLTV::Configure qw/LoadConfig SaveConfig/;
use XMLTV::Ask;
use XML::Writer;
use Encode qw/decode encode/;
use JSON;
use Digest::MD5 qw(md5_hex);
use Digest::SHA qw(sha1 sha1_hex sha1_base64);
use File::Basename;
use File::Which;
use File::HomeDir;
use File::Path qw(make_path);
use File::Spec::Functions qw(catdir tmpdir);
use DateTime;
use DateTime::TimeZone;
use DateTime::Format::ISO8601;
use DateTime::Format::SQLite;
use DateTime::Format::Strptime;
use HTML::Entities;
use POSIX qw(strftime);
use List::MoreUtils qw(natatime);
use List::Util qw/min max/;
use DBI;
use DBI qw(:sql_types);
use DBD::SQLite;
use Scalar::Util qw/looks_like_number/;
use Storable qw(dclone);
use Data::Dumper;

my $RFC2838_COMPLIANT          = 1;            # RFC2838 compliant station ids, which makes XMLTV
                                               # validate even though the docs say "SHOULD" not "MUST"

# Has to be a "CVS" Id string for XMLTV::Options.
my $SCRIPT_VERSION             = '$Id: tv_grab_az_sdjson_sqlite,v 1.57 3976d0 2019/06/22 01:19:00 gtb Exp ed $';
my $SCRIPT_URL                 = 'https://github.com/azlm8t/tv_grab_zz_sdjson_sqlite';
my $SCRIPT_NAME                = basename("$0");
my $SCRIPT_NAME_DIR            = dirname("$0");

my $SCRIPT_DB_VERSION          = 4;            # Used for script/db updates (see DB_open_global)

my $SD_DESC                    = 'Schedules Direct';
my $SD_SITEURL                 = 'https://www.schedulesdirect.org';

my $SD_COMMENT                 = 'Note: This data has been downloaded from Schedules Direct, ' .
                                 'and use of the data is restricted by the subscriber agreement ' .
                                 'to non-commercial use with open source projects.  Refer to ' .
                                 'the Schedules Direct subscriber agreement for more information';

my $SD_SCHEDULE_HASH_CHUNK     = 250;          # Request stations schedules hash in chunk sizes
my $SD_SCHEDULE_CHUNK          = 1000;         # Request stations schedules in chunk sizes
my $SD_PROGRAM_CHUNK           = 4000;         # Request program data in chunk sizes
my $SD_ARTWORK_CHUNK           = 500;          # Request artwork data in chunk sizes

my $JSON                       = JSON->new()->shrink(1)->utf8(1);

my $SD = SchedulesDirect->new();

my $DBH;                                       # DataBase Handle

my $nowDateTime = DateTime->now( time_zone => 'UTC' );
my $nowDateTimeSQLite = DateTime::Format::SQLite->format_datetime($nowDateTime);

my $GRABBER_FIXUPS = {};                       # Grabber fixups for broken applications
foreach my $fixup(split(':', $ENV{'TV_GRAB_TARGET_APPLICATION_FIXUPS'} || ''))
  {
    $GRABBER_FIXUPS->{$fixup} = undef;
  }

my $quiet = 0;
my $debug = 0;

my $download = 1;
my $num_prog_from_cache = 0;
my $num_prog_details_not_from_cache = 0;
my $num_prog_details_total = 0;
my $len_prog_not_printed = 0;
my $num_imdb_lookups_other = 0;
my $num_imdb_lookups_movie = 0;
my $num_imdb_lookups_from_cache = 0;
my $num_imdb_lookups_movie_success = 0;
my $num_imdb_lookups_other_success = 0;

my $passwordHash;

my $opt;
my $conf;
my $param;

my %num_progs_per_channel;      # Map channel id to number of programmes on that channel.
my %channel_names;              # Map channel id to canonical name.

my %catmap_major = (
                    movie => "\N{CLAPPER BOARD}",
                    news => "\N{NEWSPAPER}",
                    radio => "\N{RADIO}",
                    series => "\N{TELEVISION}",
                    sports => "\N{SPORTS MEDAL}",
                    'sports non-event' => "\N{SPORTS MEDAL}",
                   );
my %catmap_minor = (
                    action => "\N{COLLISION SYMBOL}",
                    'adults only' => "\N{NO ONE UNDER EIGHTEEN SYMBOL}",
                    adventure => "\N{BOW AND ARROW}",
                    animals => "\N{PAW PRINTS}",
                    animated => "\N{PENCIL}",
                    art => "\N{ARTIST PALETTE}",
                    auction => "\N{MONEY WITH WINGS}",
                    'auto racing' => "\N{RACING CAR}",
                    auto => "\N{AUTOMOBILE}",
                    baseball => "\N{BASEBALL}",
                    basketball => "\N{BASKETBALL AND HOOP}",
                    #boxing => "\N{BOXING GLOVE}",
                    'bus./financial' => "\N{CHART WITH UPWARDS TREND}",
                    children => "\N{BABY}",
                    comedy => "\N{FACE WITH TEARS OF JOY}",
                    computers => "\N{PERSONAL COMPUTER}",
                    community => "\N{FAMILY}",
                    cooking => "\N{COOKING}",
                    'crime drama' => "\N{POLICE OFFICER}",
                    dance => "\N{DANCER}",
                    educational => "\N{GRADUATION CAP}",
                    fantasy => "\N{UNICORN FACE}",
                    fashion => "\N{HIGH-HEELED SHOE}",
                    'figure skating' => "\N{ICE SKATE}",
                    fishing => "\N{FISHING POLE AND FISH}",
                    football => "\N{AMERICAN FOOTBALL}", # American Football (not soccer)
                    'game show' => "\N{GAME DIE}",
                    #gymnastics => "\N{PERSON DOING CARTWHEEL}",
                    history => "\N{CASTLE}",
                    holiday => "\N{AIRPLANE}",
                    'home improvement' => "\N{CONSTRUCTION WORKER}",
                    horror => "\N{SKULL}",
                    horse => "\N{HORSE FACE}",
                    'house/garden' => "\N{HOUSE WITH GARDEN}",
                    interview => "\N{SPEAKING HEAD IN SILHOUETTE}",
                    law => "\N{POLICE OFFICER}",
                    #'martial arts' => "\N{MARTIAL ARTS UNIFORM}",
                    medical => "\N{AMBULANCE}",
                    military => "\N{MILITARY MEDAL}",
                    miniseries => "\N{LINK SYMBOL}",
                    #'mixed martial arts' => "\N{MARTIAL ARTS UNIFORM}",
                    motorcycle => "\N{RACING MOTORCYCLE}",
                    music => "\N{MUSICAL NOTE}",
                    musical => "\N{MUSICAL NOTE}",
                    mystery => "\N{LEFT-POINTING MAGNIFYING GLASS}",
                    nature => "\N{ELEPHANT}",
                    paranormal => "\N{GHOST}",
                    poker => "\N{BLACK SPADE SUIT}",
                    politics => "\N{BALLOT BOX WITH BALLOT}",
                    #'pro wrestling' => "\N{WRESTLERS}",
                    #reality => "\N{SELFIE}",
                    religious => "\N{PLACE OF WORSHIP}",
                    romance => "\N{BEATING HEART}",
                    'romantic comedy' => "\N{BEATING HEART}",
                    'science fiction' => "\N{EXTRATERRESTRIAL ALIEN}",
                    science => "\N{MICROSCOPE}",
                    #shopping => "\N{SHOPPING TROLLEY}",
                    sitcom=> "\N{GRINNING FACE}",
                    skiing => "\N{SKIER}",
                    soap => "\N{COUCH AND LAMP}",
                    soccer => "\N{SOCCER BALL}",
                    'sports talk' => "\N{SPEAKING HEAD IN SILHOUETTE}",
                    spy=> "\N{SLEUTH OR SPY}",
                    standup => "\N{MICROPHONE}",
                    swimming => "\N{SWIMMER}",
                    talk => "\N{SPEAKING HEAD IN SILHOUETTE}",
                    technology => "\N{PERSONAL COMPUTER}",
                    tennis => "\N{TENNIS RACQUET AND BALL}",
                    theater => "\N{PERFORMING ARTS}",
                    travel => "\N{AIRPLANE}",
                    war => "\N{MILITARY MEDAL}",
                    weather => "\N{SUN BEHIND CLOUD}",
                    weightlifting => "\N{WEIGHT LIFTER}",
                    western => "\N{CACTUS}",
                   );

( $opt, $conf ) = ParseOptions
  (
    {
      grabber_name => "$SCRIPT_NAME",
      capabilities => [qw/baseline manualconfig preferredmethod lineups apiconfig/],
      stage_sub => \&configureGrabber,
      listchannels_sub => \&listChannels,
      list_lineups_sub => \&listLineups,
      get_lineup_sub => \&getLineup,
      load_old_config_sub => \&loadOldConfig,
      preferredmethod => 'allatonce',
      version => "$SCRIPT_VERSION",
      description => 'Multinational (Schedules Direct JSON web services with SQLite DB and local segment caching)',
      extra_options => [qw/manage-lineups
                           force-download
                           force-vacuum|vacuum-force
                           download-only
                           no-download
                           no-prune
                           no-channel-output
                           merge-split=n
                           artwork-max-width=n
                           channel-regex=s
                           channel-exclude-regex=s
                           channel-short-days=n
                           channel-short-days-exclude-regex=s
                           output-bad-channel-details=s
                           use-category-for-keyword!
                           update-category-with-grabber!
                           update-description-with-all!
                           update-description-with-credits!
                           update-description-with-categories!
                           update-description-with-year!
                           update-description-with-season-episode!
                           update-description-with-icons!
                           update-description-with-icons-basic!
                           update-description-with-icons-entity!
                           update-description-with-premiere!
                           update-description-with-live!
                           update-description-with-advisory!
                           update-description-with-artwork!
                           update-description-with-stars!
                           update-description-with-stars-color|update-description-with-stars-colour=s
                           update-description-with-rating!
                           update-description-with-title!
                           update-previously-shown-with-year!
                           use-imdb!
                           imdb-db-type=s
                           imdb-db=s
                           imdb-user=s
                           imdb-pass=s
                           imdb-dir=s
                           imdb-download=s
                           prefer-imdb-rating!
                           content-rating-order=s
                           passwordhash=s
                           cache-driver=s
                           cache-namespace-extra=s
                           cache-expiry=s
                           cache-ignore-unchanged-programmes!
                           cache-purge-expired!
                           cache-force-clear!
                           cache-root-dir=s
                           cache-compression-threshold=n
                           vacuum-frequency=n
                           benchmark/],
      defaults => { days => 30 },
    }
  );

$debug = $opt->{'debug'};
$quiet = $opt->{'quiet'};
$passwordHash = $opt->{'passwordhash'};
my $channelRegex = $opt->{'channel-regex'};
my $channelExcludeRegex = $opt->{'channel-exclude-regex'};

$SD->Debug(1) if ($debug);

#
# Special case for managing lineups
#
# This should (possibly) be done at the Schedules Direct
# site itself (as it is done now), or a seperate program,
# but as of now, this is it.
#
if ($opt->{'manage-lineups'})
  {
    manageLineups();
    exit(0);
  }

#
# Verify we have what we need to proceed and
# perform a few checks for things we do not
# support
#
configValidate($conf, $opt);
my $use_benchmark = use_benchmark();

if ($opt->{'offset'} < 0)
  {
    # Note: While it is (in theory) possible to
    # support an offset of -1, it requires a
    # bit of hoop jumping to get that data from
    # Schedules Direct, and it is not really
    # considered to be worth it for the edge
    # cases that might exist.  The data may be
    # in the database in some cases.
    print (STDERR "Offset value may not be less than 0\n");
    exit(1);
  }

if ($opt->{'days'} < 0)
  {
    print (STDERR "Day value may not be less than 0\n");
    exit(1);
  }


if (!defined(eval {require JSON::XS}))
  {
    print (STDERR "WARNING: Perl module JSON::XS not installed.  JSON encode/decode performance will be poor.\n") if (!$quiet);
  }

$download = 0 if ($opt->{'no-download'});

#
# Various sql and statement handles for accessing our database
#
my $sql;
my $sql0;
my $sql1;
my $sql2;
my $sql3;
my $sql4;
my $sth;
my $sth0;
my $sth1;
my $sth2;
my $sth3;
my $sth4;

#
# Open database
#
print (STDERR "Opening the local database\n") if (!$quiet);
DB_open_global($conf->{'database'}->[0]);

my $imdb;
if (get_option("use-imdb")) {
    my $dbtype = get_option('imdb-db-type') // "mysql";
    my $db = get_option('imdb-db') // "imdb"; # Or use imdb@localhost, etc.
    my $user = get_option('imdb-user') // "imdb";
    my $pass = get_option('imdb-pass') // "imdb";
    my $dbi = "DBI:$dbtype:$db";
    $imdb = TVHIMDB->new(dbi => $dbi, user=>$user, pass=>$pass);
    my $dir = get_option('imdb-dir') // "/var/db/mysql_secure";
    my $dl = get_option("imdb-download");
    $imdb->download($dir, $dl) if $dl;
    $imdb->import($dir);
}

#
# Provide the ability to force a (mostly) complete download
# for all data by deleting most of the data in the database,
# making this (in effect) a "first download".
#
if ($opt->{'force-download'})
  {
    print (STDERR "   clearing existing database to force full download\n") if (!$quiet);
    DB_clean();
  }

check_cache_clear();

#
# If we are not downloading data, we need to verify
# that the lineup is in the database now.
#
if (!$download)
  {
    lineupValidate($conf->{'lineup'});
    goto skipDownload;
  }

#
# Login and perform the usual checks
#
print (STDERR "Obtaining authentication token for Schedules Direct\n") if (!$quiet);

SD_login();

my $expiry = $SD->accountExpiry;
if (!defined($expiry))
  {
    print (STDERR "Unable to obtain the account expiration date: " . $SD->ErrorString . "\n");
    exit(1);
  }
# lastDateUpdated (from SD status) is across all lineups.
my $dataLastUpdated = $SD->obtainDataLastUpdated;
if (!defined($dataLastUpdated))
  {
    print (STDERR "Unable to obtain the Schedules Direct data last updated: " . $SD->ErrorString . "\n");
    exit(1);
  }
my $expiryDateTime = DateTime::Format::ISO8601->parse_datetime($expiry);
my $dataLastUpdatedDateTime = DateTime::Format::ISO8601->parse_datetime($dataLastUpdated);

print (STDERR "   Schedules Direct account expires on " . $expiryDateTime . "\n") if (!$quiet);
print (STDERR "   Schedules Direct data last updated on " . $dataLastUpdatedDateTime . "\n") if (!$quiet);

SD_cleanLineups();

#
# Start the download process
#
print (STDERR "Downloading data from Schedules Direct\n") if (!$quiet);

# We used to fetch unconditionally here, now it's done
# based on $download to be compatible with list-channels and
# list-lineups.
my $fetchLineupRequired = lineupFetchAndValidate($conf);
my $t_downloadstart = Benchmark->new if $use_benchmark;
# We do this sequentially for the moment since we are
# checking for lineups that are out of date or never
# downloaded and then figuring out schedule hashes.
for my $lineup (@{$conf->{lineup}}) {
print STDERR "Downloading data for $lineup\n" unless $quiet;
#
# We can skip downloading station schedules if our data is current
#
$sql = 'select 1 from lineups l1 where (l1.downloaded <= ? and l1.lineup in ( ' . join(', ', ('?') x scalar(@{$conf->{'lineup'}})) . ' )) union select 1 where not exists (select 1 from lineups l2 where l2.lineup in ( ' . join(', ', ('?') x scalar(@{$conf->{'lineup'}})) . ' ))';

$sth = $DBH->prepare_cached($sql);
if (!defined($sth))
  {
    print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
    exit(1);
  }

$param = 1;
$sth->bind_param( $param, DateTime::Format::SQLite->format_datetime($dataLastUpdatedDateTime), SQL_DATETIME );
$param++;
for (my $i=0; $i < scalar(@{$conf->{'lineup'}}); $i++)
  {
    $sth->bind_param( $param, @{$conf->{'lineup'}}[$i], SQL_VARCHAR);
    $param++;
  }
for (my $i=0; $i < scalar(@{$conf->{'lineup'}}); $i++)
  {
    $sth->bind_param( $param, @{$conf->{'lineup'}}[$i], SQL_VARCHAR);
    $param++;
  }

$sth->execute();

if ($sth->err())
  {
    print (STDERR "Unexpected error when executing statement ($sql): " . $sth->errstr . "\n");
    exit(1)
  }

my $fetchStationSchedulesRequired = $sth->fetchrow_array() || 0;;

$sth->finish();

if ((!$fetchStationSchedulesRequired) && (!$fetchLineupRequired))
  {
    print (STDERR "   not downloading station schedule hashes for $lineup (data current)\n") if (!$quiet);
  }
else
  {
    #
    # Obtain the current schedule hash values for our
    # lineup stations and feed to our DB
    #
    # Note that there is no (substantial) advantage in
    # requesting only the days we will be processing
    # as tests have shown that Schedules Direct takes
    # about the same time to return all vs just one,
    # and it complicates matters to request ranges
    # and deal with potential errors due to out of
    # range issues.
    #
    $sql = 'select distinct stations.station from stations as stations where stations.station in (select distinct channels.station from channels as channels where channels.lineup in ( ' . join(', ', ('?') x scalar(@{$conf->{'lineup'}})) . ' ) and channels.selected = 1)';

    $sth = $DBH->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
        exit(1);
      }

    $param = 1;
    for (my $i=0; $i < scalar(@{$conf->{'lineup'}}); $i++)
      {
        $sth->bind_param( $param, @{$conf->{'lineup'}}[$i], SQL_VARCHAR);
        $param++;
      }

    $sth->execute();

    if ($sth->err())
      {
        print (STDERR "Unexpected error when executing statement ($sql): " . $sth->errstr . "\n");
        exit(1)
      }

    $sth->bind_col( 1, undef, SQL_VARCHAR );

    my $stationsSchedulesHashList = $sth->fetchall_arrayref([0]);

    $sth->finish();

    print (STDERR "   downloading station schedule hashes for " . scalar(@{$stationsSchedulesHashList}) . " stations\n") if (!$quiet);

    $sql = "replace into stations_schedules_hash (station, day, hash, details) values ( ?, ?, ?, ?)";
    $sth = $DBH->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
        exit(1);
      }

    my $stationsSchedulesHashIter;
    $stationsSchedulesHashIter = natatime $SD_SCHEDULE_HASH_CHUNK, @{$stationsSchedulesHashList};
    while(my @chunk = $stationsSchedulesHashIter->())
      {
        print (STDERR "      downloading schedule hashes for " . scalar(@chunk) . " stations in this chunk\n") if ((!$quiet) && ((scalar(@chunk) != scalar(@{$stationsSchedulesHashList}))));

        my $stationsSchedulesHashRequest = [];

        foreach (@chunk)
          {
            my $s = {};
            $s->{'stationID'} = $_->[0];
            push(@{$stationsSchedulesHashRequest}, $s);
          }

        my $r = $SD->obtainStationsSchedulesHash(@{$stationsSchedulesHashRequest});
        if (!defined($r))
          {
            print (STDERR "Unexpected error when obtaining station schedules hashes: " . $SD->ErrorString() . "\n");
            exit(1);
          }

        if (ref($r) ne 'HASH')
          {
            print (STDERR "Unexpected return data type " . ref($r) . " when obtaining station schedules hashes.\n");
            exit(1);
          }

        foreach my $station(keys %{$r})
          {
            if (ref($r->{$station}) ne 'HASH')
              {
                # print (STDERR "Unexpected return data type " . ref($r->{$station}) . " for station $station while obtaining station schedules hashes\n");
                next;
              }
            foreach my $day(keys %{$r->{$station}})
              {
                my $s = $r->{$station}->{$day};
                # If we have an error code (non-zero) then ignore this hash.
                # We get SD error 7030 when there are lineup issues.
                next if $s->{code};
                my $hash = $s->{'md5'} || '';
                my $details = $JSON->utf8->encode($s);
                $sth->bind_param( 1, $station, SQL_VARCHAR );
                $sth->bind_param( 2, $day, SQL_DATE );
                $sth->bind_param( 3, $hash, SQL_VARCHAR );
                $sth->bind_param( 4, $details, SQL_VARCHAR );
                $sth->execute();
                if ($sth->err)
                  {
                    print (STDERR "Unexpected error when executing statement ($sql): " . $sth->errstr . "\n");
                    exit(1);
                  }
              }
          }

        $DBH->commit();
      }

    #
    # Indicate we have downloaded the data
    #
    $sql = 'update lineups set downloaded = ? where lineup in ( ' . join(', ', ('?') x scalar(@{$conf->{'lineup'}})) . ' )';
    $sth = $DBH->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
        exit(1);
      }
    $param = 1;
    $sth->bind_param( $param, $nowDateTimeSQLite, SQL_DATETIME );
    $param++;
    for (my $i=0; $i < scalar(@{$conf->{'lineup'}}); $i++)
      {
        $sth->bind_param( $param, @{$conf->{'lineup'}}[$i], SQL_VARCHAR);
        $param++;
      }
    $sth->execute();
    if ($sth->err())
      {
        print (STDERR "Unexpected error when executing statement ($sql): " . $sth->errstr . "\n");
        exit(1)
      }
    $DBH->commit();
  }
# We _should_ be able to end the "for each lineup" here
# and then do the remaining fetch across all lineups.
# But, for the moment, we'll do it all per-lineup
# since difference in performance should be negligible
# vs. risk of errors.
####} # for each lineup, download schedule hashes.


#
# Obtain the station schedules for days for which we do
# not have current information based on hash values and
# feed to our DB
#
for (my $retry = 0; $retry < 7; $retry++)
  {

    my $downloadQueued = 0;

    my $startDateTime = DateTime->now(time_zone => 'UTC')->add(days => $opt->{'offset'});
    my $endDateTime = DateTime->now(time_zone => 'UTC')->add(days => $opt->{'offset'})->add(days => $opt->{'days'});

    #
    # Note that we only update schedules (if needed) for days which will
    # produce reports for.  This may, in some cases, reduce the overheads
    #
    # Note also that it is important to check for the day to be >= today
    #   in order to skip retrieving schedules where the hash is obsolete.
    #   Since Schedules Direct does not update past station_schedules, but
    #   we keep them around for a bit, our past schedule hash can be invalid,
    #   but we do not want to force a request for such schedules, which would
    #   likely fail since Schedules Direct does not make available data
    #   which older than (about) 24 hours ago.
    #
    $sql = "select distinct stations_schedules_hash.station, stations_schedules_hash.day from stations_schedules_hash as stations_schedules_hash " .
           " left outer join schedules_hash as schedules_hash on stations_schedules_hash.station = schedules_hash.station " .
           " AND stations_schedules_hash.day = schedules_hash.day " .
           " where (stations_schedules_hash.station in (select distinct channels.station " .
           " from channels as channels where channels.lineup in ( " .  join(', ', ('?') x scalar(@{$conf->{'lineup'}})) . " ) " .
           " and channels.selected = 1)) " .
           " AND (schedules_hash.station is NULL OR schedules_hash.hash != stations_schedules_hash.hash) " .
           " AND stations_schedules_hash.day >= ? AND stations_schedules_hash.day < ? " .
           " ORDER by stations_schedules_hash.station, stations_schedules_hash.day";

    $sth = $DBH->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
        exit(1);
      }

    $param = 1;
    for (my $i=0; $i < scalar(@{$conf->{'lineup'}}); $i++)
      {
        $sth->bind_param( $param, @{$conf->{'lineup'}}[$i], SQL_VARCHAR);
        $param++;
      }
    $sth->bind_param( $param, DateTime::Format::SQLite->format_date($startDateTime), SQL_DATE );
    $param++;
    $sth->bind_param( $param, DateTime::Format::SQLite->format_date($endDateTime), SQL_DATE );
    $param++;

    $sth->execute();
    if ($sth->err)
      {
        print (STDERR "Unexpected error when executing statement ($sql): " . $sth->errstr . "\n");
        exit(1);
      }

    $sth->bind_col( 1, undef, SQL_VARCHAR );
    $sth->bind_col( 2, undef, SQL_DATE );

    my $stationsSchedulesList = $sth->fetchall_arrayref();

    $sth->finish();

    if (scalar(@{$stationsSchedulesList}) == 0)
      {
        if ($retry == 0)
          {
            print (STDERR "   not downloading daily schedules (data current)\n") if (!$quiet);
          }
        last;
      }

    print (STDERR "   downloading " . scalar(@{$stationsSchedulesList}) . " new, updated, or missing daily schedules" . (($retry == 0) ? "" : " (retry $retry)") . "\n") if (!$quiet);

    sleep(min(30, (10 * $retry)));

    $sql1 = "delete from schedules where station = ? and day = ?";
    $sql2 = "replace into schedules (station, day, starttime, duration, program, program_hash, details) values (?, ?, ?, ?, ?, ?, ?)";
    $sql3 = "replace into schedules_hash (station, day, hash) values (?, ?, ?)";

    $sth1 = $DBH->prepare_cached($sql1);
    if (!defined($sth1))
      {
        print (STDERR "Unexpected error when preparing statement ($sql1): " . $DBH->errstr . "\n");
        exit(1);
      }
    $sth2 = $DBH->prepare_cached($sql2);
    if (!defined($sth2))
      {
        print (STDERR "Unexpected error when preparing statement ($sql2): " . $DBH->errstr . "\n");
        exit(1);
      }
    $sth3 = $DBH->prepare_cached($sql3);
    if (!defined($sth3))
      {
        print (STDERR "Unexpected error when preparing statement ($sql3): " . $DBH->errstr . "\n");
        exit(1);
      }
    $sql4 = "delete from stations where station = ?";
    $sth4 = $DBH->prepare_cached($sql4);
    if (!defined($sth4))
      {
        print (STDERR "Unexpected error when preparing statement ($sql4): " . $DBH->errstr . "\n");
        exit(1);
      }
    my $schedulesIter;
    $schedulesIter = natatime $SD_SCHEDULE_CHUNK, @{$stationsSchedulesList};
    while(my @chunk = $schedulesIter->())
      {
        print (STDERR "      downloading " . scalar(@chunk) . " new, updated, or missing daily schedules in this chunk\n") if ((!$quiet) && ((scalar(@chunk) != scalar(@{$stationsSchedulesList}))));

        my $stationsSchedulesRequest = [];

        foreach (@chunk)
          {
            my $s = {};
            $s->{'stationID'} = $_->[0];
            $s->{'date'} = [$_->[1]];
            push (@{$stationsSchedulesRequest}, ($s));
          }

        my $r = $SD->obtainStationsSchedules(@{$stationsSchedulesRequest});

        if (!defined($r))
          {
            # For some reason, sometimes Schedules Direct returns malformed response (I believe due to
            # their optimization for the program array returns, which can result in partial data).
            # We will force a retry under those conditions.
            print (STDERR "Unexpected error when obtaining station schedules: " . $SD->ErrorString() . " (will retry)\n") if (!$quiet);
            $downloadQueued = 1;
            next;
          }

        if (ref($r) ne 'ARRAY')
          {
            # For some reason, sometimes Schedules Direct returns malformed response (I believe due to
            # their optimization for the program array returns, which can result in partial data).
            # We will force a retry under those conditions.
            print (STDERR "Unexpected error when obtaining station schedules: " . $SD->ErrorString() . " (will retry)\n") if (!$quiet);
            $downloadQueued = 1;
            next;
          }
        my %errs;
        foreach my $sched(@{$r})
          {
            my $hash;
            my $dayDateTime;
            my $sID = $sched->{'stationID'};
            my $code = $sched->{'code'} || 0;
            if ($code != 0)
              {
                ++$errs{$code};
                if ($code == 7100)
                  {
                    $downloadQueued = 1;
                  }
                  elsif ($code == 7030) {
                      # SCHEDULE_NOT_IN_LINEUP
                      #
                      # We should not normally get these, but we've
                      # had cases where SD says the station is in your
                      # configured lineup, then complains that station
                      # is not in your lineup. Deleting the station
                      # then causes the next lineup fetch to
                      # re-populate the station with the same details,
                      # so is probably pointless, but seems a good idea
                      # to delete stations we're told don't exist just
                      # in case.
                      my $stnid = $sched->{stationID};
                      if ($stnid) {
                          print STDERR "......Deleting station $stnid that is no longer in lineup $lineup (SD error 7030)\n" unless $quiet;
                          $sth4->execute($stnid);
                          if ($sth4->err) {
                              print (STDERR "Unexpected error when executing statement ($sql4): " . $sth4->errstr . "\n");
                              exit(1);
                          }
                      }
                  }
                next;
              }
            my $meta = $sched->{'metadata'};
            if (defined($meta))
              {
                $hash = $meta->{'md5'};
                if (defined($meta->{'startDate'}))
                  {
                    $dayDateTime = DateTime::Format::ISO8601->parse_datetime($meta->{'startDate'});
                  }
              }
            my $programs = $sched->{'programs'};
            if ((!defined($hash)) || (!defined($dayDateTime)) || (!defined($programs)))
              {
                next;
              }
            $sth1->bind_param( 1, $sID, SQL_VARCHAR );
            $sth1->bind_param( 2, DateTime::Format::SQLite->format_date($dayDateTime), SQL_DATE );
            $sth1->execute();
            if ($sth1->err)
              {
                print (STDERR "Unexpected error when executing statement ($sql1): " . $sth1->errstr . "\n");
                 exit(1);
              }
            foreach my $program(@{$programs})
              {
                my $pID = $program->{'programID'};
                my $airDateTime = $program->{'airDateTime'};
                my $duration = $program->{'duration'};
                my $phash = $program->{'md5'};
                my $details = $JSON->utf8->encode($program);
                if ((!defined($duration)) || (!defined($phash)) || (!defined($pID)) || (!defined($airDateTime)))
                  {
                    print (STDERR "Unexpected parsing error in program (data malformed) in schedule for $sID on " . $meta->{'startDate'} . ", skipping\n") if (!$quiet);
                    next;
                  }
                my $starttime = DateTime::Format::ISO8601->parse_datetime($airDateTime);
                $sth2->bind_param( 1, $sID, SQL_VARCHAR );
                $sth2->bind_param( 2, DateTime::Format::SQLite->format_date($dayDateTime), SQL_DATE );
                $sth2->bind_param( 3, DateTime::Format::SQLite->format_datetime($starttime), SQL_DATETIME );
                $sth2->bind_param( 4, $duration, SQL_INTEGER );
                $sth2->bind_param( 5, $pID, SQL_VARCHAR );
                $sth2->bind_param( 6, $phash, SQL_VARCHAR );
                $sth2->bind_param( 7, $details, SQL_VARCHAR );
                $sth2->execute();
                if ($sth2->err)
                  {
                    print (STDERR "Unexpected error when executing statement ($sql2): " . $sth2->errstr . "\n");
                    exit(1);
                  }
              }
            $sth3->bind_param( 1, $sID, SQL_VARCHAR );
            $sth3->bind_param( 2, DateTime::Format::SQLite->format_date($dayDateTime), SQL_DATE );
            $sth3->bind_param( 3, $hash, SQL_VARCHAR );
            $sth3->execute();
            if ($sth3->err)
              {
                print (STDERR "Unexpected error when executing statement ($sql3): " . $sth3->errstr . "\n");
                 exit(1);
              }
          }
        # We had some SCHEDULE_NOT_IN_LINEUP errors (7030) that (from a user POV)
        # are invisible and just cause repeated downloads, so ensure we log any errors.
        if (!$quiet && scalar keys %errs) {
            printf STDERR "...Received %d unique error codes from SD during this chunk\n", scalar keys %errs;
            print STDERR  "......SD Error Code: $_ Count: $errs{$_}\n" for sort keys %errs;
        }

        $DBH->commit();
      }

    # We are done unless one (or more) entities indicate that the server queued the request
    last if (!$downloadQueued);
  }

my %artworkProgram;

#
# Obtain the program information for programs for which
# we do not have current information based on hash values
# and feed to our DB
#
for (my $retry = 0; $retry < 7; $retry++)
  {
    my $downloadQueued = 0;

    my $startDateTime = DateTime->now(time_zone => 'UTC')->add(days => $opt->{'offset'});
    my $endDateTime = DateTime->now(time_zone => 'UTC')->add(days => $opt->{'offset'})->add(days => $opt->{'days'});

    #
    # Note that we only update programs (if needed) for days which will
    # produce reports for.  This may, in some cases, reduce the overheads
    #
    # Note also that it is important to check for the day to be >= today
    #   in order to skip retrieving programs where the program hash is
    #   obsolete.  Since Schedules Direct does not update past schedules,
    #   but we keep then around for a bit, our past program hash can
    #   be invalid, but we do not want to request such programs (since
    #   the program hash will be updated).
    #
    $sql = "select distinct schedules.program from schedules as schedules " .
           " left outer join programs as programs on schedules.program = programs.program " .
           " where (schedules.station in (select distinct stations.station " .
           " from stations as stations where stations.station " .
           " in (select distinct channels.station from channels channels " .
           " where channels.lineup in ( " .  join(', ', ('?') x scalar(@{$conf->{'lineup'}})) . " ) and channels.selected = 1)) " .
           " AND (programs.program is null OR schedules.program_hash != programs.hash)) " .
           " AND schedules.day >= ? AND schedules.day < ?" ;

    $sth = $DBH->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
        exit(1);
      }

    $param = 1;
    for (my $i=0; $i < scalar(@{$conf->{'lineup'}}); $i++)
      {
        $sth->bind_param( $param, @{$conf->{'lineup'}}[$i], SQL_VARCHAR);
        $param++;
      }
    $sth->bind_param( $param, DateTime::Format::SQLite->format_date($startDateTime), SQL_DATE );
    $param++;
    $sth->bind_param( $param, DateTime::Format::SQLite->format_date($endDateTime), SQL_DATE );
    $param++;

    $sth->execute();

    if ($sth->err)
      {
        print (STDERR "Unexpected error when executing statement ($sql): " . $sth->errstr . "\n");
        exit(1);
      }

    $sth->bind_col( 1, undef, SQL_VARCHAR );

    my $programsList = $sth->fetchall_arrayref([0]);

    $sth->finish();

    if (scalar(@{$programsList}) == 0)
      {
        if ($retry == 0)
          {
            print (STDERR "   not downloading programs (data current)\n") if (!$quiet);
          }
        last;
      }

    print (STDERR "   downloading " . scalar(@{$programsList}) . " new, updated, or missing programs" . (($retry == 0) ? "" : " (retry $retry)") . "\n") if (!$quiet);

    sleep(min(30, (10 * $retry)));

    $sql1 = "replace into programs (program, hash, details, program_supplemental, downloaded) values (?, ?, ?, ?, ?)";

    $sth1 = $DBH->prepare_cached($sql1);
    if (!defined($sth1))
      {
        print (STDERR "Unexpected error when preparing statement ($sql1): " . $DBH->errstr . "\n");
        exit(1);
      }

    my $programsIter;
    $programsIter = natatime $SD_PROGRAM_CHUNK, @{$programsList};
    while(my @chunk = $programsIter->())
      {
        print (STDERR "      downloading " . scalar(@chunk) . " new, updated, or missing programs in this chunk\n") if ((!$quiet) && ((scalar(@chunk) != scalar(@{$programsList}))));

        my $pl = [];

        foreach (@chunk)
          {
            push (@{$pl}, $_->[0]);
          }

        my $r = $SD->obtainPrograms(@{$pl});

        if (!defined($r))
          {
            # For some reason, sometimes Schedules Direct returns malformed response (I believe due to
            # their optimization for the program array returns, which can result in partial data).
            # We will force a retry under those conditions.
            print (STDERR "Unexpected error when obtaining programs: " . $SD->ErrorString() . " (will retry)\n") if (!$quiet);
            $downloadQueued = 1;
            next;
          }

        if (ref($r) ne 'ARRAY')
          {
            # For some reason, sometimes Schedules Direct return malformed response (I believe due to
            # their optiomization for the program array returns, which can result in partial data).
            # We will force a retry under those conditions.
            print (STDERR "Unexpected return data type " . ref($r) . " when obtaining program array (will retry)\n") if (!$quiet);
            $downloadQueued = 1;
            next;
          }

        foreach my $program(@{$r})
          {
            my $pID = $program->{'programID'};
            next if (!defined($pID));
            my $hash = $program->{'md5'} || 0;
            my $code = $program->{'code'} || 0;
            if ($code != 0)
              {
                if ($code == 6001)
                  {
                    $downloadQueued = 1;
                  }
                next;
              }
            my $details = $JSON->utf8->encode($program);
            my $supplemental;
            if (substr($pID, 0, 2) eq 'EP')
              {
                $supplemental = 'SH' . substr($pID, 2, 8)  . '0000';
              }
            $sth1->bind_param( 1, $pID, SQL_VARCHAR );
            $sth1->bind_param( 2, $hash, SQL_VARCHAR );
            $sth1->bind_param( 3, $details, SQL_VARCHAR );
            $sth1->bind_param( 4, $supplemental, SQL_VARCHAR );
            $sth1->bind_param( 5, $nowDateTimeSQLite, SQL_DATETIME );

            $sth1->execute();
            if ($sth1->err)
              {
                print (STDERR "Unexpected error when executing statement ($sql1): " . $sth1->errstr . "\n");
                exit(1);
              }
            $artworkProgram{$pID} = 1 if $program->{hasImageArtwork} || $program->{hasSeriesArtwork} || $program->{hasEpisodeArtwork} || $program->{hasMovieArtwork} || $program->{hasSportsArtwork};
          }
        $DBH->commit();
      }

    # We are done unless one (or more) entities indicate that the server queued the request
    last if (!$downloadQueued);
  }

#
# Obtain the program supplemental information for programs
# for which we do not have current information
#
for (my $retry = 0; $retry < 7; $retry++)
  {
    my $startDateTime = DateTime->now(time_zone => 'UTC')->add(days => $opt->{'offset'});
    my $endDateTime = DateTime->now(time_zone => 'UTC')->add(days => $opt->{'offset'})->add(days => $opt->{'days'});

    my $downloadQueued = 0;

    # Select all necessary supplemental program entities, and
    # randomly select others with an age bias (older more likely)
    $sql = "select distinct p1.program_supplemental from programs as p1 " .
           "  left join programs as supplemental on supplemental.program = p1.program_supplemental " .
           "  where p1.program_supplemental is not null " .
           "    and (   (supplemental.program is null) " .
           "         or ((((julianday('now') - julianday(supplemental.downloaded)) / 30.0) + " .
           "             (0.5 - random() / cast(-9223372036854775808 as real) / 2.0)) > 1.40 )) " .
           "    and p1.program in ( select schedules.program from schedules as schedules " .
           "      where (schedules.station in (select distinct stations.station from stations as stations " .
           "        where stations.station in (select distinct channels.station from channels channels " .
           "          where channels.lineup in ( " .  join(', ', ('?') x scalar(@{$conf->{'lineup'}})) . " ) " .
           "          and channels.selected = 1)) " .
           "        and schedules.day >= ? and schedules.day < ? ) ) ";

    $sth = $DBH->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
        exit(1);
      }

    $param = 1;
    for (my $i=0; $i < scalar(@{$conf->{'lineup'}}); $i++)
      {
        $sth->bind_param( $param, @{$conf->{'lineup'}}[$i], SQL_VARCHAR);
        $param++;
      }
    $sth->bind_param( $param, DateTime::Format::SQLite->format_date($startDateTime), SQL_DATE );
    $param++;
    $sth->bind_param( $param, DateTime::Format::SQLite->format_date($endDateTime), SQL_DATE );
    $param++;

    $sth->execute();

    if ($sth->err)
      {
        print (STDERR "Unexpected error when executing statement ($sql): " . $sth->errstr . "\n");
        exit(1);
      }

    $sth->bind_col(1, undef, SQL_VARCHAR );

    my $programsList = $sth->fetchall_arrayref([0]);

    $sth->finish();

    if (scalar(@{$programsList}) == 0)
      {
        if ($retry == 0)
          {
            print (STDERR "   not downloading programs for supplemental data (data current)\n") if (!$quiet);
          }
        last;
      }

    print (STDERR "   downloading " . scalar(@{$programsList}) . " new, updated, or missing programs for supplemental data" . (($retry == 0) ? "" : " (retry $retry)") . "\n") if (!$quiet);

    sleep(min(30, (10 * $retry)));

    $sql1 = "replace into programs (program, hash, details, program_supplemental, downloaded) values (?, ?, ?, ?, ?)";

    $sth1 = $DBH->prepare_cached($sql1);
    if (!defined($sth1))
      {
        print (STDERR "Unexpected error when preparing statement ($sql1): " . $DBH->errstr . "\n");
        exit(1);
      }

    my $programsIter;
    $programsIter = natatime $SD_PROGRAM_CHUNK, @{$programsList};
    while(my @chunk = $programsIter->())
      {
        print (STDERR "      downloading " . scalar(@chunk) . " new, updated, or missing programs for supplemental data in this chunk\n") if ((!$quiet) && ((scalar(@chunk) != scalar(@{$programsList}))));

        my $pl = [];

        foreach (@chunk)
          {
            push (@{$pl}, $_->[0]);
          }

        my $r = $SD->obtainPrograms(@{$pl});

        if (!defined($r))
          {
            # For some reason, sometimes Schedules Direct returns malformed response (I believe due to
            # their optimization for the program array returns, which can result in partial data).
            # We will force a retry under those conditions.
            print (STDERR "Unexpected error when obtaining programs: " . $SD->ErrorString() . " (will retry)\n") if (!$quiet);
            $downloadQueued = 1;
            next;
            exit(1);
          }

        if (ref($r) ne 'ARRAY')
          {
            # For some reason, sometimes Schedules Direct return malformed response (I believe due to
            # their optiomization for the program array returns, which can result in partial data).
            # We will force a retry under those conditions.
            print (STDERR "Unexpected return data type " . ref($r) . " when obtaining program array (will retry)\n") if (!$quiet);
            $downloadQueued = 1;
            next;
            exit(1);
          }

        foreach my $program(@{$r})
          {
            my $pID = $program->{'programID'};
            next if (!defined($pID));
            my $hash = $program->{'md5'} || 0;
            my $code = $program->{'code'} || 0;
            if ($code != 0)
              {
                if ($code == 6001)
                  {
                    $downloadQueued = 1;
                  }
                next;
              }
            my $details = $JSON->utf8->encode($program);
            my $supplemental;
            if (substr($pID, 0, 2) eq 'EP')
              {
                $supplemental = 'SH' . substr($pID, 2, 8)  . '0000';
              }
            $sth1->bind_param( 1, $pID, SQL_VARCHAR );
            $sth1->bind_param( 2, $hash, SQL_VARCHAR );
            $sth1->bind_param( 3, $details, SQL_VARCHAR );
            $sth1->bind_param( 4, $supplemental, SQL_VARCHAR );
            $sth1->bind_param( 5, $nowDateTimeSQLite, SQL_DATETIME );

            $sth1->execute();
            if ($sth1->err)
              {
                print (STDERR "Unexpected error when executing statement ($sql1): " . $sth1->errstr . "\n");
                exit(1);
              }

            $artworkProgram{$pID} = 1 if $program->{hasImageArtwork} || $program->{hasSeriesArtwork} || $program->{hasEpisodeArtwork} || $program->{hasMovieArtwork} || $program->{hasSportsArtwork};
          }
        $DBH->commit();
      }

    # We are done unless one (or more) entities indicate that the server queued the request
    last if (!$downloadQueued);
  }


# We also refresh (re-download) old artwork so that long running shows
# get newer artwork.
my $oldArtworkList = get_old_artwork_to_redownload();
print (STDERR "   will also refresh " . scalar @{$oldArtworkList} . " old artwork\n") if !$quiet && scalar @{$oldArtworkList};
$artworkProgram{$_} = 1 for @{$oldArtworkList};

$sql4 = "replace into artwork (program, hash, details, downloaded) values (?, ?, ?, ?)";
$sth4 = $DBH->prepare_cached($sql4);
if (!defined($sth4))
  {
      print (STDERR "Unexpected error when preparing statement ($sql4): " . $DBH->errstr . "\n");
      exit(1);
  }

for (my $retry = 0; $retry < 7; $retry++)
  {
    my $downloadQueued = 0;
    my $numArtwork = scalar keys %artworkProgram;

    if ($numArtwork == 0)
      {
        if ($retry == 0)
          {
            print (STDERR "   not downloading artwork (data current)\n") if (!$quiet);
          }
        last;
      }

    print (STDERR "   downloading " . $numArtwork . " new, updated, or missing artwork" . (($retry == 0) ? "" : " (retry $retry)") . "\n") if (!$quiet);

    sleep(min(30, (10 * $retry)));

    my $artworkIter = natatime $SD_ARTWORK_CHUNK, keys %artworkProgram;

    while(my @chunk = $artworkIter->())
      {
          print (STDERR "      downloading " . scalar(@chunk) . " new, updated, or missing artwork for programs in this chunk of total $numArtwork artwork\n") if ((!$quiet) && ((scalar(@chunk) != $numArtwork)));

        my $pl = [];

        foreach (@chunk)
          {
            push (@{$pl}, $_);
          }
          my $r = $SD->obtainProgramsArtwork(@{$pl});
          if (!defined($r))
            {
                print (STDERR "Unexpected error when obtaining artwork: " . $SD->ErrorString() . " (will retry)\n") if (!$quiet);
                $downloadQueued = 1;
                next;
                exit(1);
            }

        if (ref($r) ne 'ARRAY')
          {
            # For some reason, sometimes Schedules Direct return malformed response (I believe due to
            # their optiomization for the program array returns, which can result in partial data).
            # We will force a retry under those conditions.
            print (STDERR "Unexpected return data type " . ref($r) . " when obtaining artwork array (will retry)\n") if (!$quiet);
            $downloadQueued = 1;
            next;
            exit(1);
          }
        foreach my $artwork(@{$r})
          {
            my $pID = $artwork->{'programID'};
            next if (!defined($pID));
            my $code = $artwork->{'code'} || 0;
            if ($code != 0)
              {
                if ($code == 5001)
                  {
                      # We currently ignore the queued response since,
                      # unlike programs, a queued image is never
                      # generated immediately and could take a few
                      # days. In this case, you are left with no
                      # artwork unless the program itself changes its
                      # hash and is re-downloaded. But for series we
                      # would use the SHow artwork instead.
                      #
                      # $downloadQueued = 1;
                  }
                next;
              }
            my $details = $JSON->utf8->encode($artwork);
            # Artwork currently has no hash, but we persist one for consistency.
            # For entries with an error code, we use a hash of zero so we can
            # search for them easier for re-downloading.
            my $hash = $code ? "0" : $artwork->{'md5'} || md5_hex($details);
            $sth4->bind_param( 1, $pID, SQL_VARCHAR );
            $sth4->bind_param( 2, $hash, SQL_VARCHAR );
            $sth4->bind_param( 3, $details, SQL_VARCHAR );
            $sth4->bind_param( 4, $nowDateTimeSQLite, SQL_DATETIME );

            $sth4->execute();
            if ($sth4->err)
              {
                print (STDERR "Unexpected error when executing statement ($sql1): " . $sth4->errstr . "\n");
                exit(1);
              }

          }
        $DBH->commit();
      }
    # We are done unless one (or more) entities indicate that the server queued the request
    last if (!$downloadQueued);
  }
} # for each lineup, download schedule hash and program details

if ($use_benchmark) {
    my $t_downloadend = Benchmark->new;
    print_benchmark($t_downloadstart, $t_downloadend, "Download took %s\n") if !$quiet;
}

#
# Process data and report
#

skipDownload:

#
# If we were requested to only download data,
# we are now complete
#

goto finalize if ($opt->{'download-only'});

#
# Start at the start
#
if (!$quiet) {
    my $now = DateTime->now;
    print (STDERR "Processing data and creating XMLTV output at $now\n");
}
#
# Create some mappings for processing programs
#

# (Known) Schedules Direct cast roles and XMLTV map
# (this map likely needs review and correction)
my $castMap =
  {
    'Actor'                            => 'actor',
    'Guest Star'                       => 'guest',
    'Guest Voice'                      => 'guest',
    'Voice'                            => 'actor',
    'Correspondent'                    => 'guest',
    'Contestant'                       => 'guest',
    'Guest'                            => 'guest',
    'Muscial Guest'                    => 'guest',
    'Anchor'                           => 'presenter',
    'Host'                             => 'presenter',
    'Narrator'                         => 'presenter'
  };

# (Known) Schedules Direct crew roles and XMLTV map
# for those XMLTV roles we will use (there is no
# XMLTV role for make up artist, for example)
# (this map likely needs review and correction)
my $crewMap =
  {
    'Writer'                           => 'writer',
    'Writer (Adaptation)'              => 'writer',
    'Writer (Autobiography)'           => 'writer',
    'Writer (Book)'                    => 'writer',
    'Writer (Characters)'              => 'writer',
    'Writer (Comic Book)'              => 'writer',
    'Writer (Dialogue)'                => 'writer',
    'Writer (Earlier Screenplay)'      => 'writer',
    'Writer (Idea)'                    => 'writer',
    'Writer (Miniseries)'              => 'writer',
    'Writer (Narration)'               => 'writer',
    'Writer (Novel)'                   => 'writer',
    'Writer (Opera)'                   => 'writer',
    'Writer (Original Film)'           => 'writer',
    'Writer (Original Screenplay)'     => 'writer',
    'Writer (Play)'                    => 'writer',
    'Writer (Poem)'                    => 'writer',
    'Writer (Screenplay)'              => 'writer',
    'Writer (Screen Story)'            => 'writer',
    'Writer (Script)'                  => 'writer',
    'Writer (Short Story)'             => 'writer',
    'Writer (Story)'                   => 'writer',
    'Writer (Story and Screenplay)'    => 'writer',
    'Writer (Teleplay)'                => 'writer',
    'Writer (Television Series)'       => 'writer',
    'Action Director'                  => 'director',
    'Art Direction'                    => 'director',
    'Art Director'                     => 'director',
    'Artistic Director'                => 'director',
    'Assistant Art Director'           => 'director',
    'Assistant Director'               => 'director',
    'Associate Art Direction'          => 'director',
    'Associate Director'               => 'director',
    'Casting Director'                 => 'director',
    'Co-Art Director'                  => 'director',
    'Co-Director'                      => 'director',
    'Director'                         => 'director',
    'Director of Cinematography'       => 'director',
    'Director of Photography'          => 'director',
    'First Assistant Director'         => 'director',
    'Key Second Asst. Director'        => 'director',
    'Musical Director'                 => 'director',
    'Music Director'                   => 'director',
    'Recording Director'               => 'director',
    'Second Assistant Director'        => 'director',
    'Second Second Assistant Director' => 'director',
    'Second Unit Director'             => 'director',
    'Senior Art Director'              => 'director',
    'Set Director'                     => 'director',
    'Supervising Art Direction'        => 'director',
    'Third Assistant Director'         => 'director',
    'Trainee Assistant Director'       => 'director',
    'Voice Director'                   => 'director',
    'Additional Editor'                => 'editor',
    'Assistant Dialogue Editor'        => 'editor',
    'Assistant Editor'                 => 'editor',
    'Assistant Sound Editor'           => 'editor',
    'Associate Film Editor'            => 'editor',
    'Background Sound Editor'          => 'editor',
    'Co-Editor'                        => 'editor',
    'Dialogue Editor'                  => 'editor',
    'Editing'                          => 'editor',
    'Editor'                           => 'editor',
    'Film Editor'                      => 'editor',
    'Foley Editor'                     => 'editor',
    'Music Editor'                     => 'editor',
    'Sound Editor'                     => 'editor',
    'Sound Effects Editor'             => 'editor',
    'Supervising ADR Editor'           => 'editor',
    'Supervising Editor'               => 'editor',
    'Supervising Foley Editor'         => 'editor',
    'Supervising Sound Editor'         => 'editor',
    'Assistant Producer'               => 'producer',
    'Associate Producer'               => 'producer',
    'Co-Associate Producer'            => 'producer',
    'Co-Executive Producer'            => 'producer',
    'Consulting Producer'              => 'producer',
    'Coordinating Producer'            => 'producer',
    'Co-Producer'                      => 'producer',
    'Executive Co-Producer'            => 'producer',
    'Executive Music Producer'         => 'producer',
    'Executive Producer'               => 'producer',
    'Line Producer'                    => 'producer',
    'Location Producer'                => 'producer',
    'Makeup Effects Producer'          => 'producer',
    'Producer'                         => 'producer',
    'Special Effects Makeup Producer'  => 'producer',
    'Supervising Producer'             => 'producer',
    'Visual Effects Producer'          => 'producer',
    'Composer'                         => 'composer',
    'Additional Music'                 => 'composer',
    'Music'                            => 'composer',
    'Music Score'                      => 'composer',
    'Music Theme'                      => 'composer',
    'Non-Original Music'               => 'composer',
    'Original Music'                   => 'composer',
    'Original Music and Songs'         => 'composer'
  };

  output_xml();
#
# Our work here is done
#

finalize:

output_bad_channel_list();

if (!$opt->{'no-prune'}) {
    my ($t_prunestart, $t_pruneend);
    print (STDERR "Pruning the local database\n") if (!$quiet);
    $t_prunestart = Benchmark->new if $use_benchmark;
    DB_prune();
    $t_pruneend = Benchmark->new if $use_benchmark;
    print_benchmark($t_prunestart, $t_pruneend, "Pruning took %s\n") if !$quiet && $use_benchmark;
}

# Backends such as Redis handle expiry themselves so this option
# should not be used for them. However, some backends require
# that we call purge.
if (get_option('cache-purge-expired') && is_cache_enabled()) {
    my ($t_purgestart, $t_purgeend);
    $t_purgestart = Benchmark->new if $use_benchmark;
    my  $warn = "";
    $warn = " (not needed for many backends that handle expiry such as Redis)" if get_option('cache-driver') eq 'Redis';
    print STDERR "Purging cache of expired entries$warn.\n" if !$quiet;
    # We need to eval since some backends do not handle purge.
    # Backends such as File have a very inefficient purge and its typically
    # recommended to use "find" to delete obsolete files.
    eval { get_cache_object()->purge() };
    if (my $err = @_) {
        print STDERR "Failed to purge cache: $err\n";
    }
    # Need separate purge for this since it is a different namespace.
    eval { get_cache_object_for_programme_details()->purge() };
    if (my $err = @_) {
        print STDERR "Failed to purge cache: $err\n";
    }
    $t_purgeend = Benchmark->new if $use_benchmark;
    print_benchmark($t_purgestart, $t_purgeend, "Purging took %s\n") if !$quiet && $use_benchmark;
}
exit(0);


# Fetch oldest artwork IDs from the database to allow it to be
# refreshed.  Artwork must be older than a certain timeframe.
sub get_old_artwork_to_redownload {
    local $DBH->{RaiseError} = 1;
    my $LIMIT = 100;
    my $sql = "select program from artwork where downloaded < ? or (downloaded < ? and hash = 0) order by downloaded limit $LIMIT";
    # Re-download old artwork.
    my $earliest_artwork_date = DateTime->now->subtract(days => 90);
    # And retry failed to download artwork more frequently.
    my $earliest_artwork_date_for_failed = DateTime->now->subtract(days => 7);
    my $oldArtworkList = $DBH->selectcol_arrayref($sql, { MaxRows => $LIMIT },
                                                  DateTime::Format::SQLite->format_datetime($earliest_artwork_date, SQL_DATETIME),
                                                  DateTime::Format::SQLite->format_datetime($earliest_artwork_date_for_failed, SQL_DATETIME));
    return $oldArtworkList;
}

sub cache_clear {
    my ($t_clearstart);
    $t_clearstart = Benchmark->new if $use_benchmark;
    eval { get_cache_object()->clear() };
    if (my $err = @_) {
        print STDERR "Failed to clear cache: $err\n";
    }
    # Need separate clear for this since it is a different namespace.
    eval { get_cache_object_for_programme_details()->clear() };
    if (my $err = @_) {
        print STDERR "Failed to clear cache: $err\n";
    }
    if ($use_benchmark) {
        my $t_clearend = Benchmark->new;
        print_benchmark($t_clearstart, $t_clearend, "Clearing took %s\n") unless $quiet;
    }
}

# Check if user wants a cache clear, and clear it if necessary.
sub check_cache_clear {
    return unless get_option('cache-force-clear');
    if (!is_cache_enabled()) {
        print STDERR "   cache clear requested, but no cache is enabled.\n" unless $quiet;
        return;
    }
    print STDERR "   clearing cache\n" unless $quiet;
    cache_clear();
}

sub print_benchmark {
    my ($start, $end, $text) = @_;
    printf STDERR $text, Benchmark::timestr(Benchmark::timediff($end, $start));
}

sub use_benchmark {
    # We have a separate "is_checked flag to avoid repeated calls to
    # "require" after we have checked the config the first time.
    state $is_checked;
    state $enabled_flag;
    return $enabled_flag if $is_checked;

    $enabled_flag = !$quiet && get_option('benchmark');
    $is_checked = 1;
    if ($enabled_flag) {
        require Benchmark;
    }
    return $enabled_flag;
}

# Return an approximation of the number in human terms.
sub human_number {
    my $value = shift;
    return sprintf "%.1fGB", ($value / 1024 / 1024 / 1024) if ($value > 1024 * 1024 * 1024);
    return sprintf "%.1fMB", ($value / 1024 / 1024) if ($value > 1024 * 1024);
    return sprintf "%.1fKB", ($value / 1024) if ($value > 1024);
    return "$value bytes";
}


# Determine channels for which we have no guide data and warn the user.
sub output_bad_channel_list {
    my @bad_list;
    my $num_good = 0;
    my $num_bad = 0;
    for my $id (keys %channel_names) {
        if ($num_progs_per_channel{$id}) {
            ++$num_good;
        } else {
            my $name = $channel_names{$id} // $id;
            my $try = $name;
            if ($name =~ /HD$/) { $try =~ s/ ?U?HD//; }
            else {$try .= " HD"; }
            my @good_try;
            if ($name ne $try) {
                for my $key (keys %channel_names) {
                    if (eval {$channel_names{$key} =~ /$name/i} && $num_progs_per_channel{$key}) {
                        push @good_try, qq!"I$key ($channel_names{$key})"!;
                    }
                }
            }
            my $good_tries = scalar @good_try ? "Maybe try: " . join " or ", @good_try : "";
            push @bad_list, sprintf "%-40s\tI$id\t$good_tries", $name;
            ++$num_bad;
        }
    }
    print STDERR "Got $num_good channels with schedule data for the requested days.\n";
    print STDERR "Got $num_bad channels without any schedule data for the requested days.\n";
    if ($num_bad && is_correct_day_for_opt('output-bad-channel-details')) {
        print STDERR "\t$_\n" for (sort @bad_list);
    }
}

sub output_xml {
my $use_benchmark = use_benchmark();

my ($t_start, $t_end, $t_chanstart, $t_chanend, $t_progstart, $t_progend);
$t_start = Benchmark->new if $use_benchmark;

my $w = XML::Writer->new( 'ENCODING' => 'UTF-8',
                          'DATA_MODE' => 1,
                          'DATA_INDENT' => 1,
                          'UNSAFE' => (!$debug) );

$w->xmlDecl('UTF-8');
$w->comment($SD_COMMENT);
$w->doctype( 'tv', undef, 'xmltv.dtd' );
$w->startTag('tv',
             'generator-info-name'   => $SCRIPT_NAME,
             'generator-info-url'    => $SCRIPT_URL,
             'source-info-name'      => $SD_DESC,
             'source-info-url'       => $SD_SITEURL );
{
  # We always process the channels so we can determine if some channels
  # don't have guide data.
  $t_chanstart = Benchmark->new if $use_benchmark;
  my $do_write = !get_option('no-channel-output');
  my $channelsWritten = channelWriter($conf->{'lineup'}, $w, $do_write);
  $t_chanend = Benchmark->new if $use_benchmark;

  if ($do_write) {
      if ($use_benchmark) {
          printf (STDERR "   $channelsWritten channels processed took %s\n", Benchmark::timestr(Benchmark::timediff($t_chanend, $t_chanstart))) if (!$quiet);
      } else {
          print (STDERR "   $channelsWritten channels processed\n") if (!$quiet);
      }
  }
}

  $t_progstart = Benchmark->new if $use_benchmark;
  my $programsWritten = programWriter($w);
  $t_progend = $t_end = Benchmark->new if $use_benchmark;

  if ($use_benchmark) {
      printf (STDERR "   $programsWritten program schedules processed took %s\n", Benchmark::timestr(Benchmark::timediff($t_progend, $t_progstart))) if (!$quiet);
  } else {
      print (STDERR "   $programsWritten program schedules processed\n") if (!$quiet);
  }

  printf (STDERR "   $num_prog_from_cache programs retrieved from cache (%0.2f%%)\n", $num_prog_from_cache / $programsWritten * 100) if (!$quiet && $num_prog_from_cache);
  printf (STDERR "   $num_prog_from_cache programs not output saving approx %s\n", human_number($len_prog_not_printed)) if !$quiet && $len_prog_not_printed;
  {
      # Unfortunately the "compute" tracks number computed not number from cache,
      # so calculate number from cache here.
      my $num_prog_details_from_cache = $num_prog_details_total - $num_prog_details_not_from_cache;
      printf (STDERR "   %d of %d program details retrieved from cache (%0.2f%%)\n", $num_prog_details_from_cache, $num_prog_details_total, $num_prog_details_from_cache / $num_prog_details_total * 100) if (!$quiet && $num_prog_details_from_cache > 0);
  }
  printf (STDERR "   $num_imdb_lookups_other_success of $num_imdb_lookups_other non-movie details retrieved from imdb (%0.2f%%)\n", $num_imdb_lookups_other_success / $num_imdb_lookups_other * 100) if !$quiet && $num_imdb_lookups_other;
  printf (STDERR "   $num_imdb_lookups_movie_success of $num_imdb_lookups_movie movie details retrieved from imdb (%0.2f%%)\n", $num_imdb_lookups_movie_success / $num_imdb_lookups_movie * 100) if !$quiet && $num_imdb_lookups_movie;
  printf (STDERR "   $num_imdb_lookups_from_cache of %d program details retrieved from imdb cache (%0.2f%%)\n", $num_imdb_lookups_other + $num_imdb_lookups_movie, $num_imdb_lookups_from_cache / ($num_imdb_lookups_other + $num_imdb_lookups_movie) * 100) if !$quiet && $num_imdb_lookups_from_cache;

  if ($use_benchmark) {
      printf (STDERR "   xmltv generation took %s\n", Benchmark::timestr(Benchmark::timediff($t_end, $t_start))) if (!$quiet);
  }
  if (!$quiet) {
    my $now = DateTime->now;
    print (STDERR "Finished processing data and creating XMLTV output at $now\n");
  }

  $w->endTag('tv');
  $w->end();
}

my ($prog1, $prog2, $prog3);

sub programWriter {
    my $w = shift;
  #
  # Select out schedules/programs
  #
  # This select has (the only) sqlite specific SQL in it
  # to deal with datetime processing.  Perl performance
  # for operating on datetime is poor (it is arguably
  # reasonable given the complexity of datatime operations)
  # so we let sqlite do the work for us.  It is not
  # desirable, but when you get back 40-50% of the cpu
  # it is a necessary compromise
  #

  my ($lineupsql, @bind) = sql_generate_lineup_query();
  # If we have caching then we avoid pulling big columns from the DB unless needed.
  my $progDetails = is_cache_enabled() ? "NULL" : "programs.details";
  my $sql = "select schedules.station, schedules.starttime, schedules.duration, schedules.program, schedules.details, $progDetails, strftime('%Y%m%d%H%M%S', schedules.starttime), strftime('%Y%m%d%H%M%S', datetime(schedules.starttime, '+' || schedules.duration || ' seconds')), stations.details, supplemental.details, NULL, NULL, programs.hash as prog_hash, supplemental.hash as sup_hash, programs.program_supplemental

from
schedules as schedules left join programs as programs on programs.program = schedules.program
left join stations as stations on stations.station = schedules.station
left join programs as supplemental on programs.program_supplemental = supplemental.program

where
schedules.station in (select distinct stations.station from stations as stations where stations.station in ( select distinct channels.station from channels as channels where $lineupsql and channels.selected = 1))
AND schedules.starttime >= ?
and schedules.starttime < ?

order by schedules.station, schedules.starttime";

  my $sth = $DBH->prepare_cached($sql);
  if (!defined($sth))
    {
      print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
      exit(1);
    }

  #
  # Determine our start and end days
  #
  # Previously we'd round to nearest day (ignore time). But that means
  # if you run the grabber in the evening, you get the entire of
  # today's listings (including morning and afternoon) which is not
  # useful.
  #
  # So, we start from "now", but we subtract a few hours since
  # otherwise if a programme is half way through then its starttime
  # would be in the past so the programme would not be included.
  #
  # Of course, the opposite problem is that now if you ran at
  # midnight, you now get a few programmes from yesterday...
  # We could filter on "endtime" but that isn't stored in a DB
  # column and the overhead of calculating it does not seem
  # worth it.
  my $startDay = DateTime->now(time_zone => 'UTC')->add(days => $opt->{'offset'})->subtract(hours => 4);
  my $endDay = DateTime->now(time_zone => 'UTC')->add(days => $opt->{'offset'})->add(days => $opt->{'days'});
  push @bind, DateTime::Format::SQLite->format_datetime($startDay, SQL_DATETIME);
  push @bind, DateTime::Format::SQLite->format_datetime($endDay, SQL_DATETIME);

  $sth->execute(@bind);

  if ($sth->err())
    {
      print (STDERR "Unexpected error when executing statement ($sql): " . $sth->errstr . "\n");
      exit(1)
    }

  # We bind reference variables to avoid allocating each
  # time around the loop. This improves performance when
  # we have tens of thousands of programmes.
  my ($sched_station, $sched_starttime, $sched_duration, $sched_program, $sched_details,
      $prog_details, $sched_starttime_str, $sched_endtime,
      $stat_details, $sup_details,
      $art_details, $supart_details,
      $prog_hash, $sup_hash,
      $sup_id);
  # Nb: 1-based not 0-based.
  $sth->bind_col( 1, \$sched_station, SQL_VARCHAR );
  $sth->bind_col( 2, \$sched_starttime, SQL_DATETIME );
  $sth->bind_col( 3, \$sched_duration, SQL_INTEGER );
  $sth->bind_col( 4, \$sched_program, SQL_VARCHAR );
  $sth->bind_col( 5, \$sched_details, SQL_VARCHAR );
  $sth->bind_col( 6, \$prog_details, SQL_VARCHAR );
  $sth->bind_col( 7, \$sched_starttime_str, SQL_VARCHAR );
  $sth->bind_col( 8, \$sched_endtime, SQL_VARCHAR );
  $sth->bind_col( 9, \$stat_details, SQL_VARCHAR );
  $sth->bind_col(10, \$sup_details, SQL_VARCHAR );
  $sth->bind_col(11, \$art_details, SQL_VARCHAR ); # No longer used (NULL)
  $sth->bind_col(12, \$supart_details, SQL_VARCHAR ); # No longer used (NULL)
  $sth->bind_col(13, \$prog_hash, SQL_VARCHAR );
  $sth->bind_col(14, \$sup_hash, SQL_VARCHAR );
  $sth->bind_col(15, \$sup_id, SQL_VARCHAR );

  my $programsWritten = 0;

  while ($sth->fetch()) {
      $programsWritten += output_program($w,
                                         [$sched_station, $sched_starttime, $sched_duration, $sched_program, $sched_details,
                                          $prog_details, $sched_starttime_str, $sched_endtime,
                                          $stat_details, $sup_details,
                                          $art_details, $supart_details,
                                          $prog_hash, $sup_hash,
                                          $sup_id,
                                         ]
                                        );
  }
    # We might have some programmes left over, so write them now.
  $programsWritten += output_program($w, $prog1->{db}) if $prog1;
  $programsWritten += output_program($w, $prog2->{db}) if $prog2;
  $programsWritten += output_program($w, $prog3->{db}) if $prog3;
  return $programsWritten;
}

sub get_title {
    my ($r) = @_;
    my $programDetails = $r->{programDetails};
    my $supplementalDetails = $r->{supplementalDetails};

    # Mandatory title array should (must?) contain title120, but may
    # contain others?
    if (defined($programDetails->{'titles'})) {
        foreach my $title(@{$programDetails->{'titles'}}) {
            return $title->{title120} if defined($title->{'title120'});
        }
    }
    elsif (defined($supplementalDetails->{'titles'})) {
        foreach my $title(@{$supplementalDetails->{'titles'}}) {
            return $title->{title120} if defined $title->{title120};
      }
    }
}

sub get_sub_title {
    my ($r) = @_;
    my $programDetails = $r->{programDetails};
    my $supplementalDetails = $r->{supplementalDetails};

    return $programDetails->{episodeTitle150} // $supplementalDetails->{episodeTitle150};
}

sub output_program {
    my ($w, $r) = @_;
    state $strp = DateTime::Format::Strptime->new(
                                           pattern   => '%Y%m%d%H%M%S',
                                           time_zone => 'GMT',
                                           on_error => 'croak',
                                                 );
    state $merge_split = $opt->{'merge-split'} // $conf->{'merge-split'};
    state $channelShortDaysExcludeRegex = get_option('channel-short-days-exclude-regex');

    # Record that the station has a programme _before_ the exclude regexes.
    # This is because we later want to find stations that we have that do not
    # have any programmes association with them since SD has a habit of
    # silently dropping stations from the guide.
    my $sched_station = $r->[0];
    ++$num_progs_per_channel{$sched_station};

    my $stationDetails;
    # Shortcut decode logic (if possible) if user hasn't given regex.
    $stationDetails = $JSON->decode($r->[8]) if (($channelRegex || $channelExcludeRegex || $channelShortDaysExcludeRegex) && defined $r->[8]);

    if ($channelRegex && $stationDetails) {
        return 0 if $stationDetails->{name} !~ $channelRegex;
    }

    if ($channelExcludeRegex && $stationDetails) {
        return 0 if $stationDetails->{name} =~ $channelExcludeRegex;
    }

    if ($channelShortDaysExcludeRegex && $stationDetails && $stationDetails->{name} !~ $channelShortDaysExcludeRegex) {
        state $channelShortDays = get_option('channel-short-days') // 3;
        state $channelShortDaysStartTime = DateTime->now(time_zone => 'UTC')->add(days => $channelShortDays)->strftime("%F %T");
        return 0 if $r->[1] gt $channelShortDaysStartTime;
    }

    # Shortcut logic if we are not merging programmes.
    if (!$merge_split) {
        return write_programme($w, { db => $r,
                                     stationDetails => $stationDetails,
                                   })
    }

    # Shortcut clones if we have no programmes and we are not a movie
    # then we can output immediately and move on to next programme.
    if (!$prog1) {
        my $pID = $r->[3];
        if ($pID !~ /^MV/) {
            # Not a movie and no shuffle, so let's output this one.
            return write_programme($w, { db => $r,
                                         stationDetails => $stationDetails,
                                         });
        }
    }

    # Shortcut clone if current programme is not a movie
    # then we can clearout.
    if ($prog1 && $prog2 && $r->[3] !~ /^MV/) {
        # Print prog1
        my $ret = print_and_shuffle_programmes($w);
        # And print prog2
        $ret += print_and_shuffle_programmes($w);
        # And print the current programme.
        return $ret + write_programme($w, { db => $r,
                                            stationDetails => $stationDetails,
                                          });
    }

    my $programDetails = $JSON->decode($r->[5]) if defined($r->[5]);
    my $supplementalDetails = $JSON->decode($r->[9]) if defined($r->[9]);

    my $r2 = { db => dclone($r), # Need a deep clone otherwise all entries point to the same thing.
               programDetails => $programDetails,
               supplementalDetails => $supplementalDetails,
             };

    if (!$prog1) {
        $prog1 = $r2;
        return 0;
    }
    if (!$prog2) {
        $prog2 = $r2;
        return 0;
    }
    $prog3 = $r2;

    # Only movies can be split for news.
    my $progid1 = $prog1->{db}->[3];
    return print_and_shuffle_programmes($w) if !$progid1 || $progid1 !~ /^MV/;
    my $progid3 = $prog3->{db}->[3];
    return print_and_shuffle_programmes($w) if !$progid3 || $progid1 ne $progid3;

    # Both parts should have the same title (safety check)
    my $title1 = get_title($prog1);
    my $title3 = get_title($prog3);
    return print_and_shuffle_programmes($w) if $title1 ne $title3;

    my $dt2_start = $strp->parse_datetime($prog2->{db}->[6]);
    my $dt2_stop = $strp->parse_datetime($prog2->{db}->[7]);
    my $dt2_dur = $dt2_stop - $dt2_start;
    my $dt2_min = $dt2_dur->in_units('minutes');
    # News programmes for split movies are only short.
    return print_and_shuffle_programmes($w) if $dt2_min > $merge_split;

    # If here we need to erase the middle programme.
    my $title2 = get_title($prog2);
    my $progid2 = $prog2->{db}->[3];
    $w->comment("Merging programmes for '$title1' ($progid1) and removing '$title2' ($progid2) of $dt2_min minute duration");
    # Extend the stop time for programme 1 to be the end of programme 3.
    $prog1->{db}->[7] = $prog3->{db}->[7];
    undef $prog2;
    undef $prog3;
    return print_and_shuffle_programmes($w);
}

sub get_cache_namespace {
    state $cache_ns;
    return $cache_ns if $cache_ns;

    # It seemed a good idea to include $SCRIPT_VERSION
    # in our namespace so when a new release is made we
    # automatically ignore old data and let the server
    # purge them automatically, in case we had fixed bugs.
    # However, with a File backend, it means we leave behind
    # a whole cache hierarchy for every version that is never
    # accessed. So, we'll just use one fixed namespace.
    my $ns = "tv_az";
    # Allow user to specify additional namespaces, for example if
    # script is run with different options for different PVRs.
    my $user_ns = get_option('cache-namespace-extra');
    $ns .= ".$user_ns" if $user_ns;

    # We no longer sha1_hex since the namespace should be short.

    # We append EUID to ensure we also get a different cache per user.
    $ns .= ".$>";

    return $cache_ns = $ns;
}

sub get_cache_object {
    state $cache;
    return $cache if $cache;

    state $driver = get_option('cache-driver'); # E.g., "Redis" (with capital "R").
    return unless $driver;

    # Only require the CHI if user has specified a cache.
    # This avoids majority of users having to install it and
    # not use it.
    require CHI;
    $cache = CHI->new(driver => $driver,
                      namespace => get_cache_namespace,
                      root_dir => cache_get_root_dir(),
                      # We want the backend caching server to
                      # expire data even if we are not run.
                      expires_on_backend => 1,
                      compress_threshold => get_option('cache-compression-threshold') // 1024 * 1,
                      # No point having an l1 cache since we currently
                      # cache data effectively by (station,start,stop) due to
                      # programmes having varying data such as "premiere".
                      #
                      # l1_cache => {
                      #              driver => 'Memory', global => 1, max_size => 1024 * 1024 * 20
                      #             },
                     );
    return $cache;
}

sub get_cache_object_for_programme_details {
    state $cache;
    return $cache if $cache;
    require CHI;
    $cache = CHI->new(driver => get_option('cache-driver'),
                      namespace => "pd." . get_cache_namespace(),
                      root_dir => cache_get_root_dir(),
                      expires_on_backend => 1,
                      compress_threshold => get_option('cache-compression-threshold') // 1024 * 1,
                      # We use an l1 cache since programme details are often repeated.
                      # For example "Night News" will be on every day, and shows are
                      # repeated in morning and night.
                      l1_cache => { driver => 'Memory', global => 1, max_size => 1024 * 1024 * 20 },
                     );
    return $cache;
}

sub get_cache_object_for_imdb {
    state $cache;
    return $cache if $cache;
    require CHI;
    $cache = CHI->new(driver => get_option('cache-driver'),
                      namespace => "i." . get_cache_namespace(),
                      root_dir => cache_get_root_dir(),
                      expires_on_backend => 1,
                      compress_threshold => get_option('cache-compression-threshold') // 1024 * 1,
                      # We use an l1 cache since programmes are frequently repeated.
                      # For example "Night News" will be on every day, and shows are
                      # repeated in morning and night.
                      l1_cache => { driver => 'Memory', global => 1, max_size => 1024 * 1024 * 20 },
                     );
    return $cache;
}


sub is_cache_enabled {
    # If we have a driver then we are caching.
    state $is_enabled = get_option('cache-driver');
    return $is_enabled;
}

sub cache_get_root_dir {
    my $dir = get_option('cache-root-dir');
    # Default is a cache directory inside your .xmltv directory.
    # This is because /tmp can be small on many devices.
    # For CHI::Driver::File we also ensure we have one per uid
    # just in case multiple users share the same .xmltv directory.
    $dir = catdir(File::HomeDir->my_home, '.xmltv', 'cache', "tv_grab_az.chi-driver-file.$<") unless $dir;
    return $dir;
}

sub cache_get_expiry {
    my ($optional_timeout) = @_;
    # We ttl all cache entries to ensure old data eventually
    # disappears without user having to do anything.
    $optional_timeout = get_option('cache-expiry') // '+ 5 days' unless $optional_timeout;
    $optional_timeout = '+ 30 s' if $debug;
    return $optional_timeout;
}

# Calculate an expiry for a programme in the cache.  So user may say
# "expire in 2 weeks", but our programme is on today, so no point
# leaving it in the cache for a further 2 weeks when it can expire
# early.
sub cache_get_maximum_expiry_for_programme {
    my ($progtime, $expiry) = @_;
    return $expiry unless $progtime;

    # Parse the time in to an epoch.
    #
    # We add on a few hours to ensure we have some lee-way if a
    # second fetch is done before programme expires.
    my $progtime_timet = eval { DateTime::Format::SQLite->parse_datetime($progtime)->add(hours=>12)->epoch };
    # If we failed, then return default expiry.
    return $expiry unless $progtime_timet;

    my $now = time();
    # Let's prematurely optimize to avoid constantly parsing $expiry
    # if the time has not changed.
    state $prev_now = 0;
    state $expires_at = 0;
    state $prev_expiry = $expiry;

    # If our expiry string has changed then our cached values must
    # also change.
    $prev_now = 0 if ($expiry ne $prev_expiry);

    if ($now == $prev_now) {
        # Nothing to do, re-use $expires_at.
    } elsif ($now == $prev_now + 1) {
        # If we were one second on then we now expiry is also one second later.
        # This avoids re-parsing the $expiry.
        ++$expires_at;
        $prev_now = $now;
    } else {
        # A few seconds later, so recalculate.
        $expires_at = $now + Time::Duration::Parse::parse_duration($expiry);
        $prev_now = $now;
        $prev_expiry = $expiry;
    }

    # Expiry times are relative, not absolute, even when given as an epoch.
    if ($expires_at > $progtime_timet) {
        return $progtime_timet - $now;
    } else {
        return $expires_at - $now;
    }
}

sub cache_set {
    my ($key, $value_ref, $optional_timeout) = @_;
    $optional_timeout = cache_get_expiry($optional_timeout) unless $optional_timeout;
    print STDERR "Setting cache $key for $optional_timeout\n" if $debug;
    get_cache_object->set($key, $value_ref, $optional_timeout);
    if ($debug) {
        my $check = cache_get($key);
        if ($check ne $$value_ref) {
            die "Failed check", "check=", Dumper $check, "Orig=", Dumper $$value_ref;
        }
    }
}

sub cache_get_ref {
    my ($key) = @_;
    print STDERR "Getting cache $key\n" if $debug;
    return get_cache_object->get($key);
}

# Cache returns references to strings, so this is a convenience
# function for returning the string itself.
sub cache_get {
    my $ret = cache_get_ref(@_);
    return ref $ret ? $$ret : undef;
}

sub cache_generate_key {
    my ($r2) = @_;
    my $r = $r2->{db};

    my $sID = $r->[0] // "No station id"; # To ensure same programme on different channels don't get mixed up.
    my $pID = $r->[3] // "No prog id";
    my $start = $r->[6]; # For "premiere" instead of using schedDetails which is long.
    my $stop = $r->[7];
    # my $stationDetails = $r->[8] // "No station details";
    my $programHash = $r->[12] // "No prog hash";
    my $supplementalHash = $r->[13] // "No sup hash";
    # Ideally we would have artHash and supArtHash here, but we currently
    # do not fetch artwork details unless we have to.
    return sha1_hex( join ":",
                     $sID,
                     $start,
                     $stop,
                     # $stationDetails, # Assume station doesn't change from radio to tv so don't cache.
                     $pID,
                     $programHash,
                     $supplementalHash,
                   );
}

sub cache_generate_key_for_programme_details {
    my ($r2) = @_;
    my $r = $r2->{db};

    my $pID = $r->[3] // "No prog id";
    # We need schedule for premiere/last showing/videoProperties/hdtv
    # The string is relatively short, but we not can use it verbatim
    # since it contains airDateTime and we we want to share the
    # same details for multiple date/times.
    my $scheduleDetails = $r2->{scheduleDetails};
    die "No schedule Details for $pID" unless $scheduleDetails; # Ensure details are already unpacked!

    my $programHash = $r->[12] // "No prog hash";
    my $supplementalHash = $r->[13] // "No sup hash";
    my $scheduleHash = $scheduleDetails->{md5} // die "No schedule hash";
    my @multipart;
    # Can't just join since keys are in an unspecified order and vary with
    # each run for security.
    if (defined($scheduleDetails->{multipart})) {
        push @multipart, $scheduleDetails->{multipart}->{'partNumber'};
        push @multipart, $scheduleDetails->{multipart}->{'totalParts'};
    }
    my @tags;
    push @tags,
      $pID,
      $programHash,
      $supplementalHash,
      # We can *not* just use the scheduleHash.
      # The tuple of (programHash, scheduleHash) should be unique
      # and if schedule changes then we get a new hash, however
      # that's not the case. The scheduleHash is the same value
      # for both HD and non-HD versions of the same programID.
      $scheduleHash,
      $scheduleDetails->{duration} // "NoDur",
      $scheduleDetails->{isPremiereOrFinale} // "NoIsPrem",
      $scheduleDetails->{liveTapeDelay} // "NoLive",
      $scheduleDetails->{multipart} // "NoMulti",
      $scheduleDetails->{new} // "NoNew",
      $scheduleDetails->{premiere} // "NoPrem",
      $scheduleDetails->{ratings} // "NoRat";
    push @tags, join ",", @{$scheduleDetails->{audioProperties}} if $scheduleDetails->{audioProperties};
    push @tags, join ",", @{$scheduleDetails->{videoProperties}} if $scheduleDetails->{videoProperties};
    push @tags, join ",", @multipart if scalar @multipart;

    return sha1_hex( join ":", @tags);
}


sub print_and_shuffle_programmes {
    my ($w) = @_;
    return 0 unless $prog1;
    my $ret = write_programme($w, $prog1);
    $prog1 = $prog2;
    $prog2 = $prog3;
    $prog3 = undef;
    # If we can clear out prog1 (as not a movie) then we do so now to
    # avoid having to do clones later.  We do this recursively so we
    # can also clear out $prog2 if possible.
    if ($prog1 && $prog1->{db}->[3] !~ /^MV/) {
        $ret += print_and_shuffle_programmes($w);
    }
    return $ret;
}

sub get_option {
    my ($name) = @_;
    return $opt->{$name} // $conf->{$name};
}

# Determine if it's the correct day for running an option.
# The option value should be one of:
# - never
# - always|day|daily
# - weekly
# - monthly
# - quarter
# - half
# - year
sub is_correct_day_for_opt  {
    my ($name, $default) = @_;
    my $opt = get_option($name) // $default;
    return unless $opt;
    return if $opt eq 'never';
    return 1 if $opt eq 'always' or $opt =~ /^day|^daily/;

    my $now = DateTime->now;
    return 1 if $opt =~ /^week/    && $now->day_of_week == 1;
    return 1 if $opt =~ /^month/   && $now->day == 1;
    return 1 if $opt =~ /^quarter/ && $now->day == 1 && ($now->month-1)%4 == 0;
    return 1 if $opt =~ /^half/    && $now->day == 1 && ($now->month-6)%6 == 0;
    return 1 if $opt =~ /^year/    && $now->day == 1 && $now->month == 0;
    return;
}

# Get order that content rating should be sorted.
sub get_content_rating_order {
    return get_option('content-rating-order') // 'MPAA,VCHIP,CHVRS,BBFC,UK,BFC';
}

# Get option for update_description_... with fallback to allowing
# user-convenience of update-description-with-all to enable all features.
sub get_option_update_description_xx {
    my ($name) = @_;
    return get_option($name) // get_option('update-description-with-all');
}

sub get_artwork_image {
    my ($pID, $artwork, $supArt) = @_;
    # Get episode artwork. For movies allow any artwork if there is no decent artwork such as poster.
    # For episodes if there is no decent images in EP then we try SH and finally any image from EP.
    my ($artURI, $width, $height);
    my $is_episode = $pID =~ /^EP/;
    my $allowAnyArt = !$is_episode;
    if (($artURI, $width, $height) = $SD->getEpisodeImageFromArtwork($artwork, $allowAnyArt)) {
        return ($artURI, $width, $height);
    }

    if (($artURI, $width, $height) = $SD->getEpisodeImageFromArtwork($supArt, $allowAnyArt)) {
        return ($artURI, $width, $height);
    }

    return unless $is_episode;
    # Episode, so try finding any artwork (not just preferred artwork).

    if (($artURI, $width, $height) = $SD->getEpisodeImageFromArtwork($artwork, 1)) {
        # And if no good EP image and no good SH image then try any EP image. This
        # mostly picks up "Iconic" image.
        # However, new episodes frequently don't have any artwork at all.
        return ($artURI, $width, $height);
    }
    # So, if we can't find any artwork then try getting supplemental artwork.
    if (($artURI, $width, $height) = $SD->getEpisodeImageFromArtwork($supArt, 1)) {
        return ($artURI, $width, $height);
    }
    return undef;
}

sub get_json_common_details_for_progid {
    my ($sth, $progid) = @_;
    $sth->bind_param(1, $progid);
    $sth->execute();
    $sth->bind_col( 1, undef, SQL_VARCHAR );
    if (my @row = $sth->fetchrow_array) {
        $sth->finish();
        return $row[0];
    }
    return undef;
}

sub get_json_artwork_for_progid {
    # Sqlite allows us to execute a statement even during a fetch.
    # "Portable applications should not assume [this]" (DBI).
    # So, to be portable, we'll open a second DB connection here.
    state $db = DB_open_local(noupgrade => 1, # Don't want to go through upgrading db since it's already done.
                              AutoCommit => 1, RaiseError => 1, PrintError => 1);
    state $sql = "select details from artwork where program = ?";
    state $sth = $db->prepare_cached($sql);
    return get_json_common_details_for_progid($sth, shift);
}

sub get_json_program_details_for_progid {
    state $db = DB_open_local(noupgrade => 1, # Don't want to go through upgrading db since it's already done.
                              AutoCommit => 1, RaiseError => 1, PrintError => 1);
    state $sql = "select details from programs where program = ?";
    state $sth = $db->prepare_cached($sql);
    return get_json_common_details_for_progid($sth, shift);
}


# Fetch and JSON decode artwork for the progid.
sub get_decoded_artwork_for_progid {
    my ($progid) = @_;
    my $json_art = get_json_artwork_for_progid($progid);
    return unless $json_art;
    return $JSON->decode($json_art);
}

sub get_desc {
    my ($r, $desc, $actors, $year, $season_num, $episode_num, $max_season_num, $max_episode_num, $categories, $scheduleDetails, $advisories, $artURI, $artURI2, $programDetails, $ratings, $starRatings) = @_;
    return $desc unless $desc;

    if (get_option_update_description_xx('update-description-with-stars') && defined($starRatings)) {
        my $stars;
        for my $body(sort keys %$starRatings) {
            my $quality = $starRatings->{$body};
            my ($rating, $max) = split '/', $quality;
            next unless $max > 0;
            # Make in to a 5-star rating.
            # For example if max=5 and our rating is out of 5,
            # then we'd have multiplier=5/5. If rating is out of 10
            # then 5/10=0.5 so we'd have to half the rating.
            my $multiplier = 5 / $max;
            $rating *= $multiplier;
            my $color = get_option('update-description-with-stars-color') // "white";
            my $star_char = $color =~ /white/i ? "\N{WHITE STAR}" : "\N{BLACK STAR}";
            $stars = $star_char x $rating;
            $rating = int($rating * 4)/4;
            my $frac = $rating - int($rating);
            if ($frac >= 0.75) {
                $stars .= "\N{VULGAR FRACTION THREE QUARTERS}";
            } elsif ($frac >= 0.5) {
                $stars .= "\N{VULGAR FRACTION ONE HALF}";
            } elsif ($frac >= 0.25) {
                $stars .= "\N{VULGAR FRACTION ONE QUARTER}";
            }

            last;
        }
        $desc = "$stars. $desc" if ($stars);
    }

    if (get_option_update_description_xx('update-description-with-rating') && $ratings) {
        my $r;
        my $cro = get_content_rating_order();
        if ($cro) {
            my @cro;
            push @cro, $_ for (split /,/, $cro);
            while (!$r and my $pref = shift @cro) {
                for my $rating(%{$ratings}) {
                    if ($rating eq $pref) {
                        $r = $ratings->{$rating};
                        last;
                    }
                }
            }
        }

        if (!$r) {
            for my $rating(sort keys %${ratings}) {
                $r = $ratings->{$rating};
                last;
            }
        }

        $desc = "($r). $desc" if ($r);
    }

    if (get_option_update_description_xx('update-description-with-year') && $year) {
        $desc = "($year). $desc";
    }
    if (get_option_update_description_xx('update-description-with-season-episode') ) {
        my @str;
        my $s_str = "";
        $s_str .= "S$season_num" if $season_num;
        $s_str .= "/$max_season_num" if $season_num and $max_season_num;
        push @str, $s_str if $s_str;
        my $e_str = "";
        $e_str .= "E$episode_num" if $episode_num;
        $e_str .= "/$max_episode_num" if $episode_num and $max_episode_num;
        push @str, $e_str if $e_str;
        if (scalar @str) {
            my $str = join ' ', @str;
            $desc = "$str. $desc" if length $str;
        }
    }
    if (get_option('update-description-with-title')) {
        my @str;
        my $title = get_title($r);
        my $se = "";
        $se = sprintf "S%02d", $season_num if $season_num;
        $se .= sprintf "E%02d", $episode_num if $episode_num;
        my $sub_title = get_sub_title($r);

        # If no other details then include year. Note, this is fine
        # for films but not so great for news where the year tends to
        # be when the programme was created rather than today's episode number.
        # So we only include it for MV movies.
        $title .= " ($year)" if $year && (!$sub_title && !$season_num && !$episode_num && $r->{db} && $r->{db}[3] =~ /^MV/);
        push @str, $title if $title;
        push @str, $se if $se;
        push @str, $sub_title if $sub_title;

        my $str = join " - ", @str;
        $desc = "$str.\n\n$desc" if $str;
    }

    my @prog_details;
    if (get_option_update_description_xx('update-description-with-premiere')) {
        my $is_new = $scheduleDetails->{premiere} // $scheduleDetails->{new};
        push @prog_details, "NEW" if $is_new;
    }
    if (get_option_update_description_xx('update-description-with-live')) {
        my $is_live = $scheduleDetails->{liveTapeDelay} && $scheduleDetails->{liveTapeDelay} eq 'Live';
        push @prog_details, "LIVE" if $is_live;
    }

    if (@prog_details) {
        my $prog_details = join ":", @prog_details;
        # We output ":NEW:", ":NEW:LIVE:", etc. We use colons around
        # the name so that it is easy to search for by the user
        # whereas "NEW" (without colons) might not be easy to find
        # with case-insensitive searches.
        $desc = ":$prog_details:\n$desc";
    }

    if (get_option_update_description_xx('update-description-with-advisory')) {
        my @advisory;
        push @advisory, $_ foreach (sort keys %{$advisories});
        my $advisory = join ", ", @advisory;
        $desc = "$desc\n\nAdvisory: $advisory." if $advisory;
    }

    if (get_option_update_description_xx('update-description-with-credits') && $actors && length $actors) {
        $desc .= "\n\nCast: $actors.";
    }

    if (get_option_update_description_xx('update-description-with-categories')) {
        my @cat;
        push @cat, $_ for (sort keys %{$categories});
        if (scalar @cat) {
            my $cat = join ', ', @cat;
            $desc .= "\n\nCategories: $cat.";
        }
    }

    my $icons = get_option('update-description-with-icons');
    my $basic = get_option('update-description-with-icons-basic');
    my $entity = get_option('update-description-with-icons-entity');
    if ($icons || $basic || $entity) {
        # Some databases default to only a broken utf-8 which only
        # handles basic multiplane characters, not four-byte
        # characters. So have an option to only use basic icons.
        # This option has to be explicitly requested since it's for
        # broken clients.
        # We use maps since several categories can map to same icon.
        my %icons_major;
        my %icons_minor;
        foreach my $category (sort {$categories->{$a} <=> $categories->{$b}} (keys %{$categories})) {
            $category = lc $category;
            my $icon = $catmap_major{$category};
            if ($icon) {
                my $is_basic_icon = ord($icon) <= 0xffff;
                if ($entity && !$is_basic_icon) {
                    $icons_major{encode_entities($icon)} = 1;
                } else {
                    $icons_major{$icon} = 1 if (!$basic || ($basic && $is_basic_icon));
                }
            } else {
                $icon = $catmap_minor{$category};
                if ($icon) {
                    my $is_basic_icon = ord($icon) <= 0xffff;
                    if ($entity && !$is_basic_icon) {
                        $icons_minor{encode_entities($icon)} = 1;
                    } else {
                        $icons_minor{$icon} = 1 if (!$basic || ($basic && $is_basic_icon));
                    }
                }
            }
        }
        my $icons_major = join "", keys %icons_major;
        my $icons_minor = join "", keys %icons_minor;
        my $icons = $icons_major . $icons_minor;
        $desc = "$desc\n$icons" if length $icons;
    }

    # Have to explicitly request this option since it effectively does html injection.
    if (get_option('update-description-with-artwork')) {
        if ($artURI) {
            my $url = $SD->uriResolve($artURI, '/image');
            # Make image small
            $desc .= qq(\n<img src="$url" width="120"/>);
        }
        if ($artURI2 && $artURI ne $artURI2) {
            my $url = $SD->uriResolve($artURI2, '/image');
            # Make image small
            $desc .= qq(\n<img src="$url" width="120"/>);
        }
    }

    return $desc;
}

# Schedules Direct data can have duplicate ratings for
# a body (one in the schedule, one in the program, and
# one for the show/series), so we store only the last,
# if multiple exist.  We remap the rating agency to the
# MythTV standard, as it is as good of a standard as
# anything else, and makes importing the data much easier.
sub get_ratings {
    my ($supplementalDetails, $programDetails, $scheduleDetails) = @_;
    my $ratings = {};
    # Supplemental can have generic show ratings
    if (defined($supplementalDetails->{'contentRating'})) {
        foreach my $rating (@{$supplementalDetails->{'contentRating'}}) {
            my $body = $rating->{'body'};
            my $code = $rating->{'code'};
            ($body, $code) = mapRatingAgency($body, $code);
            if (defined($body) && defined($code)) {
                $ratings->{$body} = $code;
            }
        }
    }
    # Programs can have rating for this specific program
    if (defined($programDetails->{'contentRating'})) {
        foreach my $rating (@{$programDetails->{'contentRating'}}) {
            my $body = $rating->{'body'};
            my $code = $rating->{'code'};
            ($body, $code) = mapRatingAgency($body, $code);
            if (defined($body) && defined($code)) {
                $ratings->{$body} = $code;
            }
        }
    }
    # Schedule ratings are for this airing, and may be
    # different than for the (original) program.  We
    # overwrite any program ratings with schedule (airing)
    # ratings if duplicates exist.
    if (defined($scheduleDetails->{'ratings'})) {
        foreach my $rating (@{$scheduleDetails->{'ratings'}}) {
            my $body = $rating->{'body'};
            my $code = $rating->{'code'};
            ($body, $code) = mapRatingAgency($body, $code);
            if (defined($body) && defined($code)) {
                $ratings->{$body} = $code;
            }
        }
    }
    
    # Supplemental can have generic show ratings
    if (defined($supplementalDetails->{'contentRating'})) {
        foreach my $rating (@{$supplementalDetails->{'contentRating'}}) {
            my $body = $rating->{'body'};
            my $code = $rating->{'code'};
            ($body, $code) = mapRatingAgency($body, $code);
            if (defined($body) && defined($code)) {
                $ratings->{$body} = $code;
            }
        }
    }
    # Programs can have rating for this specific program
    if (defined($programDetails->{'contentRating'})) {
        foreach my $rating (@{$programDetails->{'contentRating'}}) {
            my $body = $rating->{'body'};
            my $code = $rating->{'code'};
            ($body, $code) = mapRatingAgency($body, $code);
            if (defined($body) && defined($code)) {
                $ratings->{$body} = $code;
            }
        }
    }
    # Schedule ratings are for this airing, and may be
    # different than for the (original) program.  We
    # overwrite any program ratings with schedule (airing)
    # ratings if duplicates exist.
    if (defined($scheduleDetails->{'ratings'})) {
        foreach my $rating (@{$scheduleDetails->{'ratings'}}) {
            my $body = $rating->{'body'};
            my $code = $rating->{'code'};
            ($body, $code) = mapRatingAgency($body, $code);
            if (defined($body) && defined($code)) {
                $ratings->{$body} = $code;
            }
        }
    }
    return $ratings;
}

sub get_star_rating_from_quality {
    my $quality = shift;
    my $body = $quality->{'ratingsBody'};
    my $min = $quality->{'minRating'};
    my $max = $quality->{'maxRating'};
    my $incr = $quality->{'increment'};
    my $rating = $quality->{'rating'};
    if (defined($body) && defined($min) && defined($max) && defined($incr) && defined($rating) &&
        looks_like_number($min) && looks_like_number($max) && looks_like_number($incr) && looks_like_number($rating))
      {
          $min = 0 + $min;
          $max = 0 + $max;
          $incr = 0 + $incr;
          $rating = 0 + $rating;
          $rating = $min if ($rating < $min);
          $rating = $max if ($rating > $max);
          my $adjustedRating = ($rating - $min);
          my $adjustedMax = ($max - $min);
          return ($body, "$adjustedRating/$adjustedMax");
      }
    return undef;
}

sub get_imdb_details {
    state $use_imdb = get_option('use-imdb');
    return unless $use_imdb;
    my ($title, $subtitle, $year, $season_num, $episode_num, $pID, $sup_year) = @_;
    my $show_type = substr($pID, 0, 2);
    my $is_movie = $show_type eq 'MV';

    if ($is_movie) {
        ++$num_imdb_lookups_movie;
    } else {
        ++$num_imdb_lookups_other;
    }

    my $cache = get_cache_object_for_imdb() if is_cache_enabled();
    # We use the programID for caching data since all our lookup
    # data (season, episode, year, etc.) derive from it.
    my $key_local = $pID if $cache;
    my $key = $key_local if $cache; # No need to "sha1_hex($key_local)" since key is unique and short.
    my $need_store = 1;

    my $cached_value = $cache->get($key) if $cache;
    my ($imdbRating, $imdbID, $imdbParentID);
    if (defined $cached_value) {
        ++$num_imdb_lookups_from_cache;
        return if (!$cached_value);
        ($imdbRating, $imdbID, $imdbParentID) = split ",", $cached_value;
        $imdbRating = undef unless $imdbRating;
        $imdbID = undef unless $imdbID;
        $imdbParentID = undef unless $imdbParentID;
        $need_store = 0;
    } else {
        $year = substr($year, 0, 4) if ($year && length $year > 4);
        $sup_year = substr($sup_year, 0, 4) if ($sup_year && length $sup_year > 4);
        ($imdbRating, $imdbID, $imdbParentID) = $show_type eq 'SH' ? $imdb->find_details_for_show($title, $year) :
          $is_movie ? $imdb->find_details_for_movie($title, $year) :
          $imdb->find_details_for_episode($title, $subtitle, $year, $season_num, $episode_num);
        if (!$is_movie && !$imdbID && !$imdbParentID && (($sup_year && $sup_year ne $year) || (!$subtitle && $show_type ne 'SH'))) {
            # Failed to find episode details. Try the series instead.
            # Do a lookup of the series/show by calling ourselves without season details.
            # This ensures we do the second lookup in the cache.
            #
            # But ensure we only recurse once! This means we also pick
            # up episodes which have season/episode that do not match
            # imdb due to having no subtitle (but imdb fakes one of
            # "Episode #1.1" for example), so we recurse and pick up
            # the show instead.
            $pID = 'SH' . substr($pID, 2, 8) . '0000';
            ($imdbRating, $imdbID, $imdbParentID) =  get_imdb_details($title, undef, $sup_year // $year, undef, undef, $pID, undef);
        }
    }

    if ($imdbID || $imdbParentID) {
        if ($is_movie) {
            ++$num_imdb_lookups_movie_success;
        } else {
            +++$num_imdb_lookups_other_success;
        }
    }

    if ($cache && $need_store) {
        my $val = join ",", $imdbRating // "", $imdbID // "", $imdbParentID // "";
        my $expiry = cache_get_expiry();
        $cache->set($key, $val, $expiry);
    }
    return ($imdbRating, $imdbID, $imdbParentID);
}

sub get_star_ratings {
    my ($programDetails, $supplementalDetails, $pID, $title, $sub_title, $season_num, $episode_num, $year, $imdbRating) = @_;
    # XMLTV star-rating starts from zero (so if rating agency is 1-4,
    # we adjust the reported values to be from 0-3.
    my $starRatings = {};
    # No need to "rebase" figures since it is 0..10/10.
    if (defined($imdbRating)) {
        $starRatings->{"imdb"} = "$imdbRating/10";
        return $starRatings if get_option("prefer-imdb-rating");
    }

    if (defined($supplementalDetails->{'movie'}->{'qualityRating'})) {
        foreach my $quality(@{$supplementalDetails->{'movie'}->{'qualityRating'}}) {
            my ($body, $value) = get_star_rating_from_quality($quality);
            $starRatings->{$body} = $value if $body && $value;
        }
    }
    if (defined($programDetails->{'movie'}->{'qualityRating'})) {
        foreach my $quality(@{$programDetails->{'movie'}->{'qualityRating'}}) {
            my ($body, $value) = get_star_rating_from_quality($quality);
            $starRatings->{$body} = $value if $body && $value;
        }
    }
    return $starRatings;
}


sub get_season_episode {
    my ($pID, $programDetails, $supplementalDetails, $scheduleDetails) = @_;
        # Season/Episode numbering is "special" as SHows and
        # EPisodes use slightly different interpretations of
        # the exact same terms.
        my $season = '';
        my $episode = '';
        my $part = '';
        my $programEpisode;
        my $programTotalEpisodes;
        my $programSeason;
        my $showSeason;
        my $showEpisode;
        my $showTotalEpisodes;
        my $showTotalSeasons;
        my $showingPart;
        my $showingTotalParts;
        my $thetvdbSeriesID;
        my $thetvdbEpisodeID;
        my $thetvdbSeason;
        my $thetvdbEpisode;
        if (defined($supplementalDetails->{'metadata'}))
          {
            foreach my $meta(@{$supplementalDetails->{'metadata'}})
              {
                last if ((!defined($supplementalDetails->{'programID'})) ||
                         ('SH' ne substr($supplementalDetails->{'programID'}, 0, 2)));
                # We only support Gracenote season/episode metadata
                # and TheTVDB series/episode link.
                if (defined($meta->{'Gracenote'}))
                  {
                    $showSeason = $meta->{'Gracenote'}->{'season'};
                    $showEpisode = $meta->{'Gracenote'}->{'episode'};
                    $showTotalSeasons = $meta->{'Gracenote'}->{'totalSeasons'};
                    $showTotalEpisodes = $meta->{'Gracenote'}->{'totalEpisodes'};
                  } elsif (defined($meta->{'TheTVDB'}))
                  {
                      $thetvdbSeriesID = $meta->{'TheTVDB'}->{seriesID};
                      $thetvdbEpisodeID = $meta->{'TheTVDB'}->{episodeID};
                  }
              }
          }
        if (defined($programDetails->{'metadata'}))
          {
            foreach my $meta(@{$programDetails->{'metadata'}})
              {
                # We only support Gracenote season/episode metadata
                # and TheTVDB series/episode link.
                if (defined($meta->{'Gracenote'}))
                  {
                    if (substr($pID, 0, 2) eq 'SH')
                      {
                        $showSeason = $meta->{'Gracenote'}->{'season'};
                        $showEpisode = $meta->{'Gracenote'}->{'episode'};
                        $showTotalSeasons = $meta->{'Gracenote'}->{'totalSeasons'};
                        $showTotalEpisodes = $meta->{'Gracenote'}->{'totalEpisodes'};
                      }
                    else
                      {
                        $programSeason = $meta->{'Gracenote'}->{'season'};
                        $programEpisode = $meta->{'Gracenote'}->{'episode'};
                        $programTotalEpisodes = $meta->{'Gracenote'}->{'totalEpisodes'};
                      }
                  } elsif (defined($meta->{'TheTVDB'}))
                  {
                      $thetvdbSeriesID = $meta->{'TheTVDB'}->{seriesID};
                      $thetvdbEpisodeID = $meta->{'TheTVDB'}->{episodeID};
                      $thetvdbSeason = $meta->{'TheTVDB'}->{season};
                      $thetvdbEpisode = $meta->{'TheTVDB'}->{episode};
                  }
              }
          }
        if (defined($scheduleDetails->{'multipart'}))
          {
            $showingPart = $scheduleDetails->{'multipart'}->{'partNumber'};
            $showingTotalParts = $scheduleDetails->{'multipart'}->{'totalParts'};
          }
        $programSeason = $showSeason if (!defined($programSeason));
        $showTotalSeasons = undef if (exists($GRABBER_FIXUPS->{'NO_XMLTV_NS_TOTAL_SEASONS'}));
        # Prefer TVDB season/episode if it is available since external
        # metadata lookups will fail otherwise. For example, CSI:Miami
        # S3E25 on Gracenote is S3E24 on TVDB and on other metadata
        # systems due to Gracenote having a gap for an unaired S3E17.
        # But we only use the TVDB if it differs since Gracenote often
        # has total number of episodes/seasons.
        my ($season_num, $max_season_num, $episode_num, $max_episode_num);
        if (($thetvdbSeason  && $programSeason  && ($thetvdbSeason  != $programSeason)) ||
            ($thetvdbEpisode && $programEpisode && ($thetvdbEpisode != $programEpisode))) {
            $season = generateXMLTV_NS($thetvdbSeason, undef);
            $episode = generateXMLTV_NS($thetvdbEpisode, undef);
            $season_num = $thetvdbSeason;
            $episode_num = $thetvdbEpisode;
            # $max_season_num and $max_episode_num remain unset
        } else {
            $season = generateXMLTV_NS($programSeason, $showTotalSeasons);
            $episode = generateXMLTV_NS($programEpisode, $programTotalEpisodes);
            $season_num = $programSeason;
            $episode_num = $programEpisode;
            $max_episode_num = $programTotalEpisodes;
            $max_season_num = $showTotalSeasons;
        }
        $part = generateXMLTV_NS($showingPart, $showingTotalParts);
        # We sometimes get data such as season 4 of 3. So fix up max season here.
        $max_season_num = $season_num if $season_num && $max_season_num && $season_num > $max_season_num;
        return ($season_num, $episode_num, $max_season_num, $max_episode_num, $season, $episode, $part, $thetvdbSeriesID, $thetvdbEpisodeID);
}

sub get_content_advisory {
    my ($programDetails, $supplementalDetails) = @_;
    # XMLTV advisories are arbitrary values.  Collect from program and supplemental
    my $advisories = {};
    if (defined($supplementalDetails->{'contentAdvisory'}))
      {
          foreach my $advisory(@{$supplementalDetails->{'contentAdvisory'}})
            {
                $advisories->{$advisory} = 1;
            }
      }
    if (defined($programDetails->{'contentAdvisory'}))
      {
          foreach my $advisory(@{$programDetails->{'contentAdvisory'}})
            {
                $advisories->{$advisory} = 1;
            }
      }
    return $advisories;
}

sub write_programme_i {
    my ($w, $r2) = @_;
    my $r = $r2->{db};
    my $sID = $r->[0];

    $w->startTag('programme', 'channel' => generateRFC2838($sID),
                 'start'   => "$r->[6] +0000",
                 'stop'    => "$r->[7] +0000");

    ++$num_prog_details_total;
    if (!is_cache_enabled()) {
        ++$num_prog_details_not_from_cache;
        write_programme_details($w, $r2);
    } else {
        my $scheduleDetails = $r2->{scheduleDetails};
        if (!$scheduleDetails && $r->[4]) {
            $scheduleDetails = $r2->{scheduleDetails} = $JSON->decode($r->[4]);
        }
        my $key = cache_generate_key_for_programme_details($r2);
        my $out = get_cache_object_for_programme_details()->
          compute($key, cache_get_expiry(), sub {
                      my $cache_prog = LightXMLWriter->new;
                      write_programme_details($cache_prog, $r2);
                      my $out = $cache_prog->to_string();
                      ++$num_prog_details_not_from_cache;
                      return $out;
                  });
        $w->raw($out) if $out;

    }
    $w->endTag('programme');
    # Programme processed.
    return 1;
}

sub write_programme {
    my ($w, $r2) = @_;

    if (!is_cache_enabled) {
        # Bypass caching logic to avoid overhead of generating keys,
        # etc.
        return write_programme_i($w, $r2);
    }

    my $key = cache_generate_key($r2);
    my $cached_value = cache_get($key);
    if ($cached_value) {
        ++$num_prog_from_cache;
        # Pop the key in to the output so we know
        # when we have retrieved from cache.
        $w->comment($key) if $debug;
        # Allow user to specify we only output programmes
        # that were not already in the cache. This allows
        # us to generate far smaller xmltv files since if
        # the programme has not changed then the PVR doesn't
        # need to re-process the same information time and
        # time again.
        state $no_print = get_option('cache-ignore-unchanged-programmes');
        if ($no_print) {
            $len_prog_not_printed += length($cached_value);
        } else {
            # We should use "raw", but we'll just print
            # directly for (a) speed and (b) to allow debug
            # checking of rest of xml writer (which is not
            # allowed with raw).
            # $w->raw($cached_value);
            print $cached_value unless $no_print;
        }
        # One more programme processed.
        return 1;
    }

    my $cache_prog = LightXMLWriter->new;
    my $ret = write_programme_i($cache_prog, $r2);
    my $out = $cache_prog->to_string();
    if ($out) {
        $w->raw($out);
        my $stop = $r2->{db}->[1]; # Scheduled start time.
        state $expiry = cache_get_expiry();
        cache_set($key, \$out, cache_get_maximum_expiry_for_programme($stop, $expiry));
    }
    return $ret;
}

sub write_programme_details {
    my ($w, $r2) = @_;
    my $r = $r2->{db};

    # These may already be decoded earlier and passed to us, in which
    # case use them, otherwise decode from DB details.
    my $programDetails = $r2->{programDetails};
    if (!$programDetails && !$r->[5]) {
        # If we were caching, we avoided fetching the large program
        # details from the DB. So we now need to fetch them here.
        my $prog_details = get_json_program_details_for_progid($r->[3]);
        $r->[5] = $prog_details;
    }

    if (!$programDetails && $r->[5]) {
        $programDetails = $r2->{programDetails} = $JSON->decode($r->[5]);
    }
    my $stationDetails = $r2->{stationDetails};
    if (!$stationDetails && $r->[8]) {
        $stationDetails = $r2->{stationDetails} = $JSON->decode($r->[8]);
    }
    my $supplementalDetails = $r2->{supplementalDetails};
    if (!$supplementalDetails && $r->[9]) {
        $supplementalDetails = $r2->{supplementalDetails} = $JSON->decode($r->[9]);
    }
    my $scheduleDetails = $r2->{scheduleDetails};
    if (!$scheduleDetails && $r->[4]) {
        $scheduleDetails = $r2->{scheduleDetails} = $JSON->decode($r->[4]);
    }

      # Note that we should legitmately parse the datetime here, but
      # the performance absolutely sucks, so we let sqlite do this
      # my $startTime = DateTime::Format::SQLite->parse_datetime($r->[1]);
      # my $endTime = $startTime->clone()->add(seconds => $r->[2]);
      my $pID = $r->[3];
      my $is_movie = substr($pID, 0, 2) eq 'MV';

    # We fetch artwork from the DB separately. We used
    # to fetch it all in one SQL, but the artwork JSON
    # is large and is unnecessary to fetch if we have
    # caching enabled and shortcut all this writing logic.
    my $artwork = get_decoded_artwork_for_progid($pID);
    my $supID = $r->[14];
    my $supArt = get_decoded_artwork_for_progid($supID);
    my $title = get_title($r2);
    $w->dataElement('title', $title) if ($title);
    my $sub_title = get_sub_title($r2);
    $w->dataElement('sub-title', $sub_title) if $sub_title;
    my $w2 = LightXMLWriter->new;
        # XMLTV roles for this program
        my $roles =
          {
            'director'                         => {},
            'actor'                            => {},
            'writer'                           => {},
            'adapter'                          => {},
            'producer'                         => {},
            'composer'                         => {},
            'editor'                           => {},
            'presenter'                        => {},
            'commentator'                      => {},
            'guest'                            => {}
          };

        # XMLTV dtd requires us to collect the various cast and
        # crew items in order to process in the dtd order.  In
        # addition, the dtd specifies that the order of the
        # roles is meaningful (first billing should come first).
        # All too often the supplemental (SHow) has more
        # detailed cast/crew data that the program (EPisode)
        # itself, and in particular, the character.

        # We use program details otherwise supplemental.
        # We don't merge the details since frequently
        # long running shows will have all regular cast
        # including people that no longer star in the show
        # in supplemental whereas program details has cast
        # for just this episode.
        if (defined($programDetails->{'cast'}))
          {
            foreach my $cast(@{$programDetails->{'cast'}})
              {
                addRole($roles, $castMap->{$cast->{'role'}}, $cast->{'name'}, $cast->{'billingOrder'}, $cast->{'characterName'});
              }
          }
        elsif (defined($supplementalDetails->{'cast'}))
          {
            foreach my $cast(@{$supplementalDetails->{'cast'}})
              {
                addRole($roles, $castMap->{$cast->{'role'}}, $cast->{'name'}, '10' . $cast->{'billingOrder'}, $cast->{'characterName'});
              }
          }
        if (defined($programDetails->{'crew'}))
          {
            foreach my $crew(@{$programDetails->{'crew'}})
              {
                addRole($roles, $crewMap->{$crew->{'role'}}, $crew->{'name'}, $crew->{'billingOrder'}, undef);
              }
          }
        elsif (defined($supplementalDetails->{'crew'}))
          {
            foreach my $crew(@{$supplementalDetails->{'crew'}})
              {
                addRole($roles, $crewMap->{$crew->{'role'}}, $crew->{'name'}, '10' . $crew->{'billingOrder'}, undef);
              }
          }
        $w2->startTag('credits');
        my @actors;
          foreach my $role('director', 'actor', 'writer', 'adapter', 'producer', 'composer', 'editor', 'presenter', 'commentator', 'guest')
            {
              foreach my $person(sort {$roles->{$role}->{$a}->{'order'} <=> $roles->{$role}->{$b}->{'order'}} (keys %{$roles->{$role}}))
                {
                  # per dtd, only actors can have roles (I respectfully disagree, as guests can have roles, but the dtd must be obeyed)
                  if ((0 == scalar(@{$roles->{$role}->{$person}->{'character'}})) || ($role ne 'actor'))
                    {
                      $w2->dataElement($role, $person);
                      push @actors, $person if $role eq 'actor' or $role eq 'presenter' or $role eq 'commentator' or $role eq 'guest';
                    }
                  else
                    {
                      foreach my $character(@{$roles->{$role}->{$person}->{'character'}})
                        {
                          $w2->dataElement($role, $person, 'role' => $character);
                          push @actors, $person;
                        }
                    }
                }
            }
        my $actors = join ', ', @actors;
        $w2->endTag('credits');
        $w2->end();

        # Only movies (likely) have a date
        # But for series we can use original air date and use entire date.
        my $year = $programDetails->{'movie'}->{'year'} //
          $supplementalDetails->{'movie'}->{'year'} //
          $programDetails->{originalAirDate} //
          $supplementalDetails->{originalAirDate};
       my $sup_year = $supplementalDetails->{'movie'}->{'year'} // $supplementalDetails->{originalAirDate};

    my ($season_num, $episode_num, $max_season_num, $max_episode_num, $season_xmltvns, $episode_xmltvns, $part_xmltvns, $thetvdbSeriesID, $thetvdbEpisodeID) = get_season_episode($pID, $programDetails, $supplementalDetails, $scheduleDetails);
        my ($imdbRating, $imdbID, $imdbParentID) = get_imdb_details($title, $sub_title, $year, $season_num, $episode_num, $pID, $sup_year);
        my $advisories = get_content_advisory($programDetails, $supplementalDetails);
        my ($artURI, $artWidth, $artHeight) = get_artwork_image($pID, $artwork, $supArt);
        # Additional artwork, normally specific to the episode. This is only
        # used if specific user options have been specified.
        my ($artURI2, $artWidth2, $artHeight2) = $SD->getEpisodeImageFromArtwork($artwork, 1) if get_option('update-description-with-artwork');

        my $mythtv_category;
        if (defined($conf->{'mythtv-categories'}->[0]) &&
            ($conf->{'mythtv-categories'}->[0] eq 'enabled'))
          {
            # For MythTV, we need to specify the first category
            # in the xmltv file as one of movie, series, sports,
            # or tvshow.  We can derive that from the entityType.
            # If the station is a radio station, we do not add
            # tvshow, but add radio (because the first category
            # is not processed in the usual way).
            my $radioStation = 0;
            if (defined($stationDetails->{'isRadioStation'}))
              {
                $radioStation = $stationDetails->{'isRadioStation'};
              }
            if (defined($programDetails->{'entityType'}))
              {
                my $entityType = $programDetails->{'entityType'};
                if ($entityType eq 'Movie')
                  {
                    $mythtv_category = 'movie';
                  }
                elsif ($entityType eq 'Sports')
                  {
                    $mythtv_category = 'sports';
                  }
                elsif ($entityType eq 'Episode')
                  {
                    $mythtv_category = 'series';
                  }
                else   # Should be Show
                  {
                    my $showType = '';
                    if (defined($programDetails->{'showType'}))
                      {
                        $showType = $programDetails->{'showType'};
                      }
                    elsif (defined($supplementalDetails->{'showType'}))
                      {
                        $showType = $supplementalDetails->{'showType'};
                      }
                    if (($showType eq 'Feature Film') ||
                        ($showType eq 'Short Film') ||
                        ($showType eq 'TV Movie'))
                      {
                        $mythtv_category = 'movie';
                      }
                    elsif (($showType eq 'Sports event') ||
                           ($showType eq 'Sports non-event'))
                      {
                        $mythtv_category = 'sports';
                      }
                    elsif (($showType eq 'Series') ||
                           ($showType eq 'Miniseries'))
                      {
                        $mythtv_category = 'series';
                      }
                    else
                      {
                        if ($radioStation)
                          {
                            $mythtv_category = 'radio';
                          }
                        else
                          {
                            $mythtv_category = 'tvshow';
                          }
                      }
                  }
              }
            else   # entityType is supposed to be manditory, but....
              {
                if ($radioStation)
                  {
                    $mythtv_category = 'radio';
                  }
                else
                  {
                    $mythtv_category = 'tvshow';
                  }
              }
          }

        # XMLTV categories are somewhat arbitrary.  We collect the
        # genres, showType, and entityType as categories.  There is
        # no order implication in the XMLTV dtd for categories,
        # but at least one well known app cares about the order,
        # so we try to be accomodating, and priorize program
        # over supplemental data.
        my $categories = {};
        my $categorynum = 0;
        if (defined($programDetails->{'genres'}))
          {
            foreach my $genre(@{$programDetails->{'genres'}})
              {
                $categories->{$genre} = $categorynum++ if (!defined($categories->{$genre}));
              }
          }
        if (defined($supplementalDetails->{'genres'}))
          {
            foreach my $genre(@{$supplementalDetails->{'genres'}})
              {
                $categories->{$genre} = $categorynum++ if (!defined($categories->{$genre}));
              }
          }
        if (defined($programDetails->{'showType'}))
          {
            $categories->{$programDetails->{'showType'}} = $categorynum++ if (!defined($categories->{$programDetails->{'showType'}}));
          }
        if (defined($supplementalDetails->{'showType'}))
          {
            $categories->{$supplementalDetails->{'showType'}} = $categorynum++ if (!defined($categories->{$supplementalDetails->{'showType'}}));
          }
        if (defined($programDetails->{'entityType'}))
          {
            $categories->{$programDetails->{'entityType'}} = $categorynum++ if (!defined($categories->{$programDetails->{'entityType'}}));
          }
        if (defined($supplementalDetails->{'entityType'}))
          {
            $categories->{$supplementalDetails->{'entityType'}} = $categorynum++ if (!defined($categories->{$supplementalDetails->{'entityType'}}));
        }

        my $ratings = get_ratings($supplementalDetails, $programDetails, $scheduleDetails);
        my $starRatings = get_star_ratings($programDetails, $supplementalDetails, $pID, $title, $sub_title, $season_num, $episode_num, $year, $imdbRating);

        # Choose the "best" (i.e. longer) description if available
        if (defined($programDetails->{'descriptions'}->{'description1000'}))
          {
            foreach my $d(@{$programDetails->{'descriptions'}->{'description1000'}})
              {
                my $lang = $d->{'descriptionLanguage'};
                my $desc = $d->{'description'};
                next if ((!defined($lang) || (!defined($desc))));
                $w->dataElement('desc', get_desc($r2, $desc, $actors, $year, $season_num, $episode_num, $max_season_num, $max_episode_num, $categories, $scheduleDetails, $advisories, $artURI, $artURI2, $programDetails, $ratings, $starRatings), 'lang' => $lang);
              }
          }
        elsif (defined($programDetails->{'descriptions'}->{'description100'}))
          {
            foreach my $d(@{$programDetails->{'descriptions'}->{'description100'}})
              {
                my $lang = $d->{'descriptionLanguage'};
                my $desc = $d->{'description'};
                next if ((!defined($lang) || (!defined($desc))));
                $w->dataElement('desc', get_desc($r2, $desc, $actors, $year, $season_num, $episode_num, $max_season_num, $max_episode_num, $categories, $scheduleDetails, $advisories, $artURI, $artURI2, $programDetails, $ratings, $starRatings), 'lang' => $lang);
              }
          }
        elsif (defined($supplementalDetails->{'descriptions'}->{'description1000'}))
          {
            foreach my $d(@{$supplementalDetails->{'descriptions'}->{'description1000'}})
              {
                my $lang = $d->{'descriptionLanguage'};
                my $desc = $d->{'description'};
                next if ((!defined($lang) || (!defined($desc))));
                $w->dataElement('desc', get_desc($r2, $desc, $actors, $year, $season_num, $episode_num, $max_season_num, $max_episode_num, $categories, $scheduleDetails, $advisories, $artURI, $artURI2, $programDetails, $ratings, $starRatings), 'lang' => $lang);
              }
          }
        elsif (defined($supplementalDetails->{'descriptions'}->{'description100'}))
          {
            foreach my $d(@{$supplementalDetails->{'descriptions'}->{'description100'}})
              {
                my $lang = $d->{'descriptionLanguage'};
                my $desc = $d->{'description'};
                next if ((!defined($lang) || (!defined($desc))));
                $w->dataElement('desc', get_desc($r2, $desc, $actors, $year, $season_num, $episode_num, $max_season_num, $max_episode_num, $categories, $scheduleDetails, $advisories, $artURI, $artURI2, $programDetails, $ratings, $starRatings), 'lang' => $lang);
              }
        }
        $w->raw($w2->to_string());
	$w->dataElement('date', $year) if $year;
        $w->dataElement('category', $mythtv_category) if $mythtv_category;
        # Adding an 'xmltv' category makes it easier to add recording rules where
        # we only want to record if we have good xmltv data, not OTA data so can
        # match against the xmltv category. We add it here (after writing the
        # description) since no point having 'xmltv' in every programme's description
        # if 'update-description-with-category' is enabled.
        $categories->{xmltv} = 1 if get_option('update-category-with-grabber');
        foreach my $category (sort keys %{$categories})
          {
            $w->dataElement('category', $category);
          }

        # MythTV does not currently have a concept of keywords,
        # so this is output is likely meaningless.  Perhaps a
        # future enhancement (a new "programkeywords" table?),
        # or keywords should be added as categories?  Some of
        # the keywords might make usable categories.  There
        # is no order implication for keywords in the XMLTV dtd.
        my $keywords = {};
        if (defined($programDetails->{'keyWords'}))
          {
            foreach my $keyCat(keys %{$programDetails->{'keyWords'}})
              {
                foreach my $kw(@{$programDetails->{'keyWords'}->{$keyCat}})
                  {
                    $keywords->{$kw} = 1
                  }
              }
          }
        if (defined($supplementalDetails->{'keyWords'}))
          {
            foreach my $keyCat(keys %{$supplementalDetails->{'keyWords'}})
              {
                foreach my $kw(@{$supplementalDetails->{'keyWords'}->{$keyCat}})
                  {
                    $keywords->{$kw} = 1
                  }
              }
          }
        # Some clients can not handle keywords so allow keywords to be used as categories instead.
        my $use_cat = $opt->{'use-category-for-keyword'} // $conf->{'use-category-for-keyword'} // 0;
        foreach my $keyword (sort keys %{$keywords})
          {
              if ($use_cat) {
                  $w->dataElement('category', $keyword);
              } else {
                  $w->dataElement('keyword', $keyword);
              }
          }

        if (defined($programDetails->{'duration'}))
          {
            $w->dataElement('length', $programDetails->{'duration'}, 'units' => 'seconds');
          }
        elsif (defined($supplementalDetails->{'duration'}))
          {
            $w->dataElement('length', $supplementalDetails->{'duration'}, 'units' => 'seconds');
          }

          if ($artURI) {
            my $url = $SD->uriResolve($artURI, '/image');
            # Append the token if available
            if ($SD && $SD->{_Token}) {
                $url .= "?token=$SD->{_Token}";
            }
            if ($artWidth && $artHeight) {
                $w->emptyTag('icon', 'src' => $url,
                             'width' => $artWidth,
                             'height' => $artHeight);
            } else {
                $w->emptyTag('icon', 'src' => $url);
            }
        }
        # Prefer episode id to series id if we have both.
        $w->dataElement('url', "https://www.imdb.com/title/$imdbID") if $imdbID;
        $w->dataElement('url', "https://www.imdb.com/title/$imdbParentID") if $imdbParentID;
        if (defined($programDetails->{'officialURL'}))
          {
            $w->dataElement('url', $programDetails->{'officialURL'});
          }
        elsif (defined($supplementalDetails->{'officialURL'}))
          {
            $w->dataElement('url', $supplementalDetails->{'officialURL'});
          }

        my $prodid = $pID;
        if (length($prodid) == 14)
          {
            $prodid = substr($prodid, 0, 10) . '.' . substr($prodid, 10, 4);
            $w->dataElement('episode-num', $prodid, 'system' => 'dd_progid' );
          }

        #if (defined($programDetails->{'resourceID'}))
        #  {
        #    $w->dataElement('episode-num', "resourceid/$programDetails->{'resourceID'}", 'system' => 'schedulesdirect.org');
        #  }
        #elsif (defined($supplementalDetails->{'resourceID'}))
        #  {
        #    $w->dataElement('episode-num', "resourceid/$supplementalDetails->{'resourceID'}", 'system' => 'schedulesdirect.org');
        #  }
        if (($season_xmltvns ne '') || ($episode_xmltvns ne '') || ($part_xmltvns ne ''))
          {
            $w->dataElement('episode-num', " $season_xmltvns . $episode_xmltvns . $part_xmltvns ", 'system' => 'xmltv_ns');
          }
        # Format is series/id or episode/id.
        # http://xmltv.cvs.sourceforge.net/viewvc/xmltv/xmltv/xmltv.dtd?r1=1.45&r2=1.46
        if ($thetvdbSeriesID) {
            $w->dataElement('episode-num', "series/$thetvdbSeriesID", system => 'thetvdb.com');
        }
        if ($thetvdbEpisodeID) {
            $w->dataElement('episode-num', "episode/$thetvdbEpisodeID", system => 'thetvdb.com');
        }
        # We base our imdb.com system on the existing themoviedb and thetvdb systems.
        $w->dataElement('episode-num', ($is_movie ? "movie" : "episode") . "/$imdbID", system => 'imdb.com') if $imdbID;
        $w->dataElement('episode-num', "series/$imdbParentID", system => 'imdb.com') if $imdbParentID;

        if (defined($scheduleDetails->{'videoProperties'}))
          {
            $w->startTag('video');
              foreach my $videoProperty(@{$scheduleDetails->{'videoProperties'}})
                {
                  $w->dataElement('quality', 'HDTV') if ($videoProperty eq 'hdtv');
                }
            $w->endTag('video');
          }

        # XMLTV only supports one audio quality report, so we try
        # to determine the best available to report.  We also need
        # to collect the closed caption information for future
        # reporting.
        my $audioHasCC = 0;    # Need to carry forward
        if (defined($scheduleDetails->{'audioProperties'}))
          {
            # Ugly because dtd only allows one type, and source data
            # may have many (in any order)
            my $audioHasDolbySurround   = 0;
            my $audioHasDolby           = 0;
            my $audioHasStereo          = 0;
            foreach my $audioProperty(@{$scheduleDetails->{'audioProperties'}})
              {
                $audioHasDolbySurround = 1 if ($audioProperty eq 'DD 5.1');
                $audioHasDolby = 1 if ($audioProperty eq 'Dolby');
                $audioHasStereo = 1 if ($audioProperty eq 'stereo');
                $audioHasCC = 1 if ($audioProperty eq 'cc');
              }
            if ($audioHasDolbySurround || $audioHasDolby || $audioHasStereo)
              {
                $w->startTag('audio');
                if ($audioHasDolbySurround)
                  {
                    $w->dataElement('stereo', 'dolby digital');
                  }
                elsif ($audioHasDolby)
                  {
                    $w->dataElement('stereo', 'dolby');
                  }
                elsif ($audioHasStereo)
                  {
                    $w->dataElement('stereo', 'stereo');
                  }
                $w->endTag('audio');
              }
          }

        # Do not add in any previously-shown indication from supplemental data for
        # originalAirDate since generic data is not relevant for this showing
        # and tends to be when series was first commissioned.
        # Date transformation occurs because XMLTV uses their standardized
        # dates, while Schedules Direct uses YYYY-MM-DD
        if (defined($programDetails->{'originalAirDate'}))
          {
            my $originalAirDate = $programDetails->{'originalAirDate'};
            my $offset = ' +0000';
            $offset = '' if (exists($GRABBER_FIXUPS->{'NO_PREVIOUSLY_SHOWN_ZONE_OFFSET'}));
            my $start = substr($originalAirDate, 0, 4) . substr($originalAirDate, 5, 2) . substr($originalAirDate, 8, 2) . $offset;
            $w->emptyTag('previously-shown', start => $start);
          }
        else
          {
            my $new = 0;
            $new = $scheduleDetails->{'new'} if (defined($scheduleDetails->{'new'}));
            # It's useful for some clients to have year copied in to previously-shown.
            if ($year && get_option('update-previously-shown-with-year')) {
                $w->emptyTag('previously-shown', start => $year);
            } else {
                $w->emptyTag('previously-shown') if (!$new);
            }
          }

        # XMLTV premiere/last-chance is sort of arbitrarily
        # defined, so we decide on our own mapping (while
        # season finale may not be a last-chance, since
        # in the US every season finale may be a series
        # finale (no renewal before its time) we just treat
        # it as the last-chance).
        if (defined($scheduleDetails->{'premiere'}))
          {
            my $premiere = $scheduleDetails->{'premiere'};
            $w->emptyTag('premiere') if ($premiere);
          }
        elsif (defined($scheduleDetails->{'isPremiereOrFinale'}))
          {
            my $premiereType = $scheduleDetails->{'isPremiereOrFinale'};
            if (($premiereType eq 'Series Premiere') || ($premiereType eq 'Season Premiere'))
              {
                $w->dataElement('premiere', $premiereType);
              }
            if (($premiereType eq 'Series Finale') || ($premiereType eq 'Season Finale'))
              {
                $w->dataElement('last-chance', $premiereType);
              }
          }
        elsif ($scheduleDetails->{'new'}) {
            $w->emptyTag('premiere');
        }
        # Carried forward from audio eval to match DTD
        $w->emptyTag('subtitles', 'type' => 'teletext') if ($audioHasCC);

        # Write out the the collected ratings
        my $cro = get_content_rating_order();
        if ($cro) {
            my @cro;
            push @cro, $_ for (split /,/, $cro);
            while (my $pref = shift @cro) {
                for my $rating(%{$ratings}) {
                    if ($rating eq $pref) {
                        $w->startTag('rating', 'system' => $rating);
                        $w->dataElement('value', $ratings->{$rating});
                        $w->endTag('rating');
                        delete $ratings->{$rating};
                        last;
                    }
                }
            }
        }
        foreach my $rating(sort keys %{$ratings})
          {
            $w->startTag('rating', 'system' => $rating);
              $w->dataElement('value', $ratings->{$rating});
            $w->endTag('rating');
          }

        foreach my $advisory(sort keys %{$advisories})
          {
            $w->startTag('rating', 'system' => 'advisory');
              $w->dataElement('value', $advisory);
            $w->endTag('rating')
          }

        foreach my $body(sort keys %{$starRatings})
          {
            $w->startTag('star-rating', 'system' => $body);
              $w->dataElement('value', $starRatings->{$body});
            $w->endTag('star-rating');
        }
    return 1;
}

#
# configureGrabber

# Perform the configure function for XMLTV
#
# NOTE: While this grabber is (technically) apiconfig
# compliant, one must run (outside of --configure)
# this script with the --manage-lineups option to
# create the local database with the username and
# password hash, and to add/delete lineups from the
# Schedules Direct account.
#
# NOTE: We do not utilze the "select-channels" functionality
# in XMLTV, because it addresses the (actual) selection
# of "stations", and not "channels".  A "station" is a
# programming entity which has a schedule of programs.
# A "channel" is a technical means of delivering a
# particular "station".  Typically, in the real world,
# many "channels" deliver the same "station".
#
#   Input:
#              stage       - the "stage" for configure
#              conf        - the (current) conf hash
#   Output:
#              result      - the xml configure string
#
sub configureGrabber
  {
    my ($stage, $conf, undef) = @_;

    my $result;

    my $writer = XMLTV::Configure::Writer->new( OUTPUT => \$result,
                                                grabber => $SCRIPT_NAME,
                                                encoding => 'iso-8859-1' );
    $writer->start ( { grabber => $SCRIPT_NAME } );

    if ($stage eq 'start')
      {
        $writer->write_string
          (
            {
              id => 'database',
              title => [ [ 'Database for Schedules Direct EPG', 'en' ] ],
              description =>
                [ [
                    "$SCRIPT_NAME uses a local database for downloaded EPG data.  Please specify the database name created via $SCRIPT_NAME --manage-lineups",
                    'en'
                ] ],
              default => File::HomeDir->my_home . "/.xmltv/SchedulesDirect.DB",
            }
          );

        $writer->end('select-lineup');
      }
    elsif ($stage eq 'select-lineup')
      {
        my $username;
        my $passwordhash;

        DB_open_global($conf->{'database'}->[0]);

        SD_login();                             # Login
        SD_downloadLineups();                   # Update our SD lineups in the DB

        my $sql = "select lineup, name, transport, location, details from lineups";
        my $sth = $DBH->prepare_cached($sql);
        if (!defined($sth))
          {
            print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
            exit(1);
          }

        $sth->execute();

        if ($sth->err())
          {
            print (STDERR "Unexpected error when executing statement ($sql): " . $sth->errstr . "\n");
            exit(1)
          }

        $sth->bind_col( 1, undef, SQL_VARCHAR );
        $sth->bind_col( 2, undef, SQL_VARCHAR );
        $sth->bind_col( 3, undef, SQL_VARCHAR );
        $sth->bind_col( 4, undef, SQL_VARCHAR );
        $sth->bind_col( 5, undef, SQL_VARCHAR );

        my $lu = $sth->fetchall_arrayref();

        $sth->finish();

        if (scalar(@{$lu}) == 0)
          {
            print (STDERR "No lineups are defined in your Schedules Direct account\n");
            print (STDERR "To manage your lineups, please re-run $SCRIPT_NAME --manage-lineups\n");
            print (STDERR "and re-run $SCRIPT_NAME --configure to complete the configuration\n");
            exit(1);
          }

        $writer->start_selectmany
          (
            {
              id => 'lineup',
              title => [ [ 'Schedules Direct Lineup', 'en' ] ],
              description =>
                [ [
                    'Select the lineup(s) associated with this configuration',
                    'en'
                ] ],
            }
          );

        for my $l (@{$lu})
          {
            my $id = $l->[0];
            my $desc = "$l->[1] $l->[2] $l->[3]";
            $writer->write_option
              (
                {
                  value => $id,
                  text => [ [ "$id - $desc", 'en' ] ]
                }
              );
          }

        $writer->end_selectmany();

        $writer->end('mythtv');
      }
    elsif ($stage eq 'mythtv')
      {
        $writer->start_selectone
          (
            {
              id => 'mythtv-categories',
              title => [ [ 'MythTV category processing', 'en' ], ],
              description =>
                [ [
                  'Specify whether the XMLTV categories should be MythTV ordered',
                  'en'
                ] ],
            }
          );
        $writer->write_option
          (
            {
              value => 'enabled',
              text => [ [ 'Yes - Enable MythTV Category order', 'en'] ]
            }
          );
        $writer->write_option
          (
            {
              value => 'disabled',
              text => [ [ 'No - Do not enable MythTV Category order', 'en'] ]
            }
          );
        $writer->end_selectone();

        $writer->end('select-channels');
      }
    else
      {
        die "Unknown stage $stage";
      }
    return $result;
  }

sub log_sd_expiry {
    my $expiry = $SD->accountExpiry;
    if (!defined($expiry))
      {
        print (STDERR "Unable to obtain the account expiration date: " . $SD->ErrorString . "\n");
        exit(1);
      }
    my $dataLastUpdated = $SD->obtainDataLastUpdated;
    if (!defined($dataLastUpdated))
      {
        print (STDERR "Unable to obtain the Schedules Direct data last updated: " . $SD->ErrorString . "\n");
        exit(1);
      }
    my $expiryDateTime = DateTime::Format::ISO8601->parse_datetime($expiry);
    my $dataLastUpdatedDateTime = DateTime::Format::ISO8601->parse_datetime($dataLastUpdated);

    print (STDERR "   Schedules Direct account expires on " . $expiryDateTime . "\n") if (!$quiet);
    print (STDERR "   Schedules Direct data last updated on " . $dataLastUpdatedDateTime . "\n") if (!$quiet);
}

sub lineupFetchAndValidate {
    my ($conf) = @_;
    my $fetchLineupRequired = 0;

    #
    # If we are downloading, allow for optimization
    #
    if ($download)
      {
          print (STDERR "Obtaining authentication token for Schedules Direct\n") if (!$quiet);
        SD_login();
        log_sd_expiry();
        $fetchLineupRequired |= SD_isLineupFetchRequired($conf->{lineup});

        if ($fetchLineupRequired)
          {
            print (STDERR "Downloading lineups from Schedules Direct\n") if (!$quiet);
            SD_downloadLineups() if ($download);
          }
        else
          {
            print (STDERR "not downloading lineups from Schedules Direct (data current)\n") if (!$quiet);
          }

        #
        # Need to validate here to not try to download maps
        # for lineups not in account (which would throw error)
        #
        for my $lineup(@{$conf->{lineup}}) {
            lineupValidate($lineup);

            if ($fetchLineupRequired)
              {
                  print (STDERR "Downloading channels stations for lineup $lineup\n") if (!$quiet);
                  SD_downloadLineupMaps($lineup) if ($download);
              }
            else
              {
                  print (STDERR "not downloading channel and station maps for lineup $lineup (data current)\n") if (!$quiet);
              }
        }
    }
    else
      {
          lineupValidate($_) for @{$conf->{lineup}};
      }
    return $fetchLineupRequired;
}

#
# listChannels
#
# Perform the list-channels function per the XMLTV standard
#
#   Input:
#              conf        - the conf hash
#              opt         - the opt hash
#   Output:
#              result      - the xml configure string
#
sub listChannels
  {
    my ($conf_xmltv, $opt_xmltv, undef) = @_;
    $conf = $conf_xmltv;
    $opt = $opt_xmltv;

    configValidate($conf, $opt);

    $debug = $opt->{'debug'};
    $quiet = $opt->{'quiet'};

    $SD->Debug(1) if ($debug);

    $download = 0 if ($opt->{'no-download'});

    print (STDERR "Opening the local database\n") if (!$quiet);
    DB_open_global($conf->{'database'}->[0]);

    if ($opt->{'force-download'})
      {
        print (STDERR "   clearing existing database to force full download\n") if (!$quiet);
        DB_clean();
      }

    check_cache_clear();
    lineupFetchAndValidate($conf);
    my $w = XML::Writer->new( 'ENCODING' => 'UTF-8',
                              'DATA_MODE' => 1,
                              'DATA_INDENT' => 1,
                              'OUTPUT' => 'self' );
    $w->xmlDecl('UTF-8');
    $w->comment($SD_COMMENT);
    $w->doctype( 'tv', undef, 'xmltv.dtd' );
    $w->startTag('tv',
                 'generator-info-name'   => $SCRIPT_NAME,
                 'generator-info-url'    => $SCRIPT_URL,
                 'source-info-name'      => $SD_DESC,
                 'source-info-url'       => $SD_SITEURL );

    my $channelsWritten = channelWriter($conf->{'lineup'}, $w, 1);

    $w->endTag('tv');
    $w->end();

    print (STDERR "$channelsWritten channels processed\n") if (!$quiet);

    return(encode('UTF-8', $w->to_string));
  }


# Generate text and bind variables suitable for lineups in the configuration file.
sub sql_generate_lineup_query {
    my ($lineupRef) = @_;
    $lineupRef = $conf->{lineup} unless $lineupRef;
    Carp::confess "We do not have any lineups" unless $lineupRef && scalar @$lineupRef;
    my @sql;
    my @bind;
    for my $lineup (@$lineupRef) {
        push @sql, '?';
        push @bind, $lineup;
    }
    # Optimize common use-case of only having one lineup.
    if (scalar @sql == 1) {
        return ("lineup = ?", @bind);
    } else {
        my $query = join ', ', @sql;
        return ("lineup in ($query)", @bind);
    }
}

#
# channelWriter
#
# Convenience routine to write the XMLTV channels.
# Output is written to the xmltv writer
#
#   Input:
#              lineup(s)   - the lineup(s) to use
#              writer      - the xmltv writer
#              do_write    - do actual write (vs. cache for summary)
#   Output:
#              written     - number of channels written
#
sub channelWriter
  {
    my ($lineups, $writer, $do_write) = @_;

    my $sql;
    my $sth;
    my $param;
    my $channelsWritten = 0;

    #
    # Collect some lineup information
    #
    my ($lineupsql, @bind) = sql_generate_lineup_query($lineups);
    # Select our lineup channels/stations
    #
    $sql = "select distinct channels.station, channels.channum, channels.details, stations.details from channels as channels left join stations as stations on stations.station = channels.station where $lineupsql and channels.selected = 1 order by 1";

    $sth = $DBH->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
        exit(1);
      }

    $sth->execute(@bind);

    if ($sth->err())
      {
        print (STDERR "Unexpected error when executing statement ($sql): " . $sth->errstr . "\n");
        exit(1)
      }

    $sth->bind_col( 1, undef, SQL_VARCHAR );
    $sth->bind_col( 2, undef, SQL_VARCHAR );
    $sth->bind_col( 3, undef, SQL_VARCHAR );
    $sth->bind_col( 4, undef, SQL_VARCHAR );

    # Process each channel in our lineup
    while (my $r = $sth->fetchrow_arrayref())
      {
        my $sID = $r->[0];
        my $channum = $r->[1];
        my $c = $JSON->decode($r->[2]);
        my $s = {};
        if (defined($r->[3]))
          {
            $s = $JSON->decode($r->[3]);
          }

        next if $channelRegex        && $s->{name} && $s->{name} !~ $channelRegex;
        next if $channelExcludeRegex && $s->{name} && $s->{name} =~ $channelExcludeRegex;

        # Cache channel names from the DB so we can print end summary.
        $channel_names{$sID} = $s->{name} // $sID;
        next unless $do_write;

        $writer->startTag('channel', 'id' => generateRFC2838($sID) ) ;

          my $name = '';
          $name = $s->{'name'} if (defined($s->{'name'}));
          my $callsign = '';
          $callsign = $s->{'callsign'} if (defined($s->{'callsign'}));
          $name = $callsign if ($name eq '');
          $name = $channum if ($name eq '');
          $callsign = $channum if ($callsign eq '');
          my $svcid = $c->{serviceID};
          # Log a comment in xmltv file so we can easily find xmltv channels that do not have a name.
          $writer->comment("Only have svcid of $svcid") if !$name && !$callsign && !$channum;
          $writer->dataElement('display-name', $name) if ($name ne '');
          # Our channels have a tendency to be called "ABC+1" but SD calls then "ABC +1"
          # (with a space). So output both variants if necessary.
          if ($name =~ / [+]1$/) {
              my $tmpdn = $name;
              $tmpdn =~ s/ [+]1$/+1/;
              $writer->dataElement('display-name', $tmpdn) if $tmpdn;
          } elsif ($name =~ /[+]1$/) {
              my $tmpdn = $name;
              $tmpdn =~ s/[+]1$/ +1/;
              $writer->dataElement('display-name', $tmpdn) if $tmpdn;
          }
          {
              # Some historic European channel names are uppercase only.
              my $tmpdn = uc $name;
              $writer->dataElement('display-name', $tmpdn) if ($tmpdn ne $name);
          }
          $writer->dataElement('display-name', $callsign) if ($callsign ne '');
          $writer->dataElement('display-name', $svcid) if $svcid;
          $writer->dataElement('display-name', $channum) if ($channum ne '');
          if (!$name && !$callsign && !$svcid && !$channum) {
            $writer->comment(Dumper $s);
            $writer->comment(Dumper $c);
          }

          # Should probably return all stationLogo's, but some applications are
          # known to take the last and not the first, so return only the first
          if ((defined($s->{'stationLogo'}->[0]->{'URL'})) &&
              (!exists($GRABBER_FIXUPS->{'NO_STATION_LOGOS'})))
            {
              if (defined($s->{'stationLogo'}->[0]->{'width'}) && defined($s->{'stationLogo'}->[0]->{'height'}))
                {
                  $writer->emptyTag('icon', 'src' => $s->{'stationLogo'}->[0]->{'URL'},
                                    'width' => $s->{'stationLogo'}->[0]->{'width'},
                                    'height' => $s->{'stationLogo'}->[0]->{'height'});
                }
              else
                {
                  $writer->emptyTag('icon', 'src' => $s->{'stationLogo'}->[0]->{'URL'});
                }
            }

        $writer->endTag('channel');

        $channelsWritten++;
      }
    return ($channelsWritten);
  }

#
# listLineups
#
# Perform the list-lineups function per XMLTV
#
#   Input:
#              opt         - the opt hash
#   Output:
#              result      - the xml configure string
#
sub listLineups
  {
    my ($opt_xmltv, undef) = @_;
    $opt = $opt_xmltv;
    $conf = LoadConfig($opt->{'config-file'});

    my $sql;
    my $sth;
    my $param;

    configValidate($conf, $opt);

    $debug = $opt->{'debug'};
    $quiet = $opt->{'quiet'};

    $SD->Debug(1) if ($debug);

    $download = 0 if ($opt->{'no-download'});

    print (STDERR "Opening the local database\n") if (!$quiet);
    DB_open_global($conf->{'database'}->[0]);

    if ($opt->{'force-download'})
      {
        print (STDERR "   clearing existing database to force full download\n") if (!$quiet);
        DB_clean();
      }

    check_cache_clear();
    print (STDERR "Obtaining authentication token for Schedules Direct\n") if ($download && !$quiet);
    SD_login() if ($download);
    log_sd_expiry();

    #
    # Optimizing lineup download is simply not worth the effort
    # due to having the check if any lineup has been modified
    # since the last time the data was downloaded.  And since
    # list-lineups is expected to be used rarely, we are going
    # to skip any attempt at optimization
    #

    print (STDERR "Downloading lineups from Schedules Direct\n") if ($download && !$quiet);
    SD_downloadLineups() if ($download);

    $sql = 'select lineup, name, transport, location, details from lineups';
    $sth = $DBH->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
        exit(1);
      }

    $sth->execute();

    if ($sth->err())
      {
        print (STDERR "Unexpected error when executing statement ($sql): " . $sth->errstr . "\n");
        exit(1)
      }

    $sth->bind_col( 1, undef, SQL_VARCHAR );
    $sth->bind_col( 2, undef, SQL_VARCHAR );
    $sth->bind_col( 3, undef, SQL_VARCHAR );
    $sth->bind_col( 4, undef, SQL_VARCHAR );
    $sth->bind_col( 5, undef, SQL_VARCHAR );

    my $lu = $sth->fetchall_arrayref();

    $sth->finish();

    my $w = XML::Writer->new( 'ENCODING' => 'UTF-8', 'DATA_MODE' => 1, 'DATA_INDENT' => 1, OUTPUT => 'self' );
    $w->xmlDecl('UTF-8');
    $w->comment('Note: list-lineups and get-lineup is still unofficial in XMLTV, and the format and content of this xml is liable to change.');
    $w->comment($SD_COMMENT);
    $w->startTag('xmltv-lineups',
                 'modified'              => strftime("%FT%T %z", localtime),
                 'generator-info-name'   => $SCRIPT_NAME,
                 'generator-info-url'    => $SCRIPT_URL,
                 'source-info-name'      => $SD_DESC,
                 'source-info-url'       => $SD_SITEURL );
      for my $l (@{$lu})
        {
          my $id = $l->[0];
          my $lineupDesc = "$l->[1] $l->[2] $l->[3]";
          $w->startTag('xmltv-lineup', 'id' => $id );
            my $type = mapTransport($l->[2]);
            $w->dataElement('type', $type);
            $w->dataElement('display-name', $lineupDesc);
          $w->endTag('xmltv-lineup');
        }

    $w->endTag('xmltv-lineups');
    $w->end();

    return(encode('UTF-8', $w->to_string));
  }

#
# getLineup
#
# Perform the get-lineup function per XMLTV
#
#   Input:
#              conf        - the conf has
#              opt         - the opt hash
#   Output:
#              result      - the xml configure string
#
sub getLineup
  {
    my ($conf_xmltv, $opt_xmltv, undef) = @_;

    $conf = $conf_xmltv;
    $opt = $opt_xmltv;

    configValidate($conf, $opt);

    $debug = $opt->{'debug'};
    $quiet = $opt->{'quiet'};

    $SD->Debug(1) if ($debug);

    $download = 0 if ($opt->{'no-download'});

    print (STDERR "Opening the local database\n") if (!$quiet);
    DB_open_global($conf->{'database'}->[0]);

    if ($opt->{'force-download'})
      {
        print (STDERR "   clearing existing database to force full download\n") if (!$quiet);
        DB_clean();
      }

    check_cache_clear();
    lineupFetchAndValidate($conf);

    my $w = XML::Writer->new( 'ENCODING' => 'UTF-8', 'DATA_MODE' => 1, 'DATA_INDENT' => 1, OUTPUT => 'self' );
    $w->xmlDecl('UTF-8');
    $w->comment('Note: list-lineups and get-lineup is still unofficial in XMLTV, and the format and content of this xml is liable to change.');
    $w->comment($SD_COMMENT);
    $w->startTag('xmltv-lineups',
                 'modified'              => strftime("%FT%T %z", localtime),
                 'generator-info-name'   => $SCRIPT_NAME,
                 'generator-info-url'    => $SCRIPT_URL,
                 'source-info-name'      => $SD_DESC,
                 'source-info-url'       => $SD_SITEURL );

    #
    # Collect our lineup(s) information.
    #

    $sql = 'select lineup, name, transport, location, details from lineups where lineup in ( ' . join(', ', ('?') x scalar(@{$conf->{'lineup'}})) . ' )';

    my $sth = $DBH->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
        exit(1);
      }

    $param = 1;
    for (my $i=0; $i < scalar(@{$conf->{'lineup'}}); $i++)
      {
        $sth->bind_param( $param, @{$conf->{'lineup'}}[$i], SQL_VARCHAR);
        $param++;
      }

    $sth->execute();

    if ($sth->err())
      {
        print (STDERR "Unexpected error when executing statement ($sql): " . $sth->errstr . "\n");
        exit(1)
      }

    $sth->bind_col( 1, undef, SQL_VARCHAR );
    $sth->bind_col( 2, undef, SQL_VARCHAR );
    $sth->bind_col( 3, undef, SQL_VARCHAR );
    $sth->bind_col( 4, undef, SQL_VARCHAR );
    $sth->bind_col( 5, undef, SQL_VARCHAR );

    my $lu = $sth->fetchall_arrayref();

    $sth->finish();


      for my $l (@{$lu})
        {
          my $id = $l->[0];
          my $lineupDesc = "$l->[1] $l->[2] $l->[3]";
          $w->startTag('xmltv-lineup', 'id' => $id );
            my $type = mapTransport($l->[2]);
            $w->dataElement('type', $type);
            $w->dataElement('display-name', $lineupDesc);

            #
            # Process each channel/station in the lineup
            #

            $sql = 'select distinct channels.station, channels.channum, channels.details, stations.details, lineups.transport from channels as channels left join stations as stations on stations.station = channels.station left join lineups as lineups on lineups.lineup = channels.lineup where channels.lineup = ? and channels.selected = 1';

            $sth = $DBH->prepare_cached($sql);
            if (!defined($sth))
              {
                print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
                exit(1);
              }

            $sth->bind_param( 1, $id, SQL_VARCHAR );

            $sth->execute();

            if ($sth->err())
              {
                print (STDERR "Unexpected error when executing statement ($sql): " . $sth->errstr . "\n");
                exit(1)
              }

            $sth->bind_col( 1, undef, SQL_VARCHAR );
            $sth->bind_col( 2, undef, SQL_VARCHAR );
            $sth->bind_col( 3, undef, SQL_VARCHAR );
            $sth->bind_col( 4, undef, SQL_VARCHAR );
            $sth->bind_col( 5, undef, SQL_VARCHAR );

            while (my $r = $sth->fetchrow_arrayref())
              {
                my $sID = $r->[0];
                my $channum = $r->[1];
                my $c = $JSON->decode($r->[2]);
                my $s = $JSON->decode($r->[3]);
                my $SDtype = $r->[4] || 'Unknown';
                my $type = mapTransport($r->[4]);

                $w->startTag('lineup-entry');

                  if (defined($channum) && ($channum ne ''))
                    {
                      $w->dataElement('preset', $channum);
                    }

                  $w->startTag('station', 'rfc2838' => generateRFC2838($sID) );

                    my $name = $s->{'name'};
                    my $shortname = $s->{'callsign'};
                    $name = $shortname if (!defined($name) || ($name eq ''));
                    $w->dataElement('name', $name) if (defined($name) && ($name ne ''));
                    $w->dataElement('short-name', $shortname) if (defined($shortname) && ($shortname ne ''));

                    # get-lineup proposal is not precise, but it appears we
                    # should only return one logo, so return only the first
                    if ((defined($s->{'stationLogo'}->[0]->{'URL'})) &&
                        (!exists($GRABBER_FIXUPS->{'NO_STATION_LOGOS'})))
                      {
                        if (defined($s->{'stationLogo'}->[0]->{'width'}) && defined($s->{'stationLogo'}->[0]->{'height'}))
                          {
                            $w->emptyTag('logo', 'url' => $s->{'stationLogo'}->[0]->{'URL'},
                                                 'height' => $s->{'stationLogo'}->[0]->{'height'},
                                                 'width' => $s->{'stationLogo'}->[0]->{'width'});
                          }
                        else
                          {
                            $w->emptyTag('logo', 'url' => $s->{'stationLogo'}->[0]->{'URL'});
                          }

                      }

                  $w->endTag('station');

                  if (($SDtype eq 'Cable') || ($SDtype eq 'Satellite') || ($SDtype eq 'IPTV'))
                    {
                      $w->startTag('stb-channel');
                      if (defined($c->{'channel'}) && looks_like_number($c->{'channel'}))
                        {
                          my $preset = $c->{'channel'};
                          $preset = 0 + $preset;
                          $w->dataElement('stb-preset', $preset);
                        }
                      $w->endTag('stb-channel');
                    }

                  if ($SDtype eq 'Antenna')
                    {
                      my $atscMajor = $c->{'atscMajor'};
                      my $atscMinor = $c->{'atscMinor'};

                      my $ATSC = (defined($atscMajor) && defined($atscMinor) &&
                                  looks_like_number($atscMajor) && looks_like_number($atscMinor));

                      if ($ATSC)
                        {
                          $atscMajor = 0 + $atscMajor;
                          $atscMinor = 0 + $atscMinor;
                          $w->startTag('atsc-channel');
                            $w->dataElement('system', 'US-ATSC');
                        }
                      else
                        {
                          $w->startTag('analog-channel');
                            $w->dataElement('system', 'NTSC-M');
                        }

                      if (defined($channum) && ($channum ne ''))
                        {
                          $w->dataElement('number', $channum);
                        }

                      my $fccChan = $c->{'uhfVhf'};
                      if (defined($fccChan))
                        {
                          $w->dataElement('frequency', mapUSATSCChannelToFrequency($fccChan));
                        }

                      if ($ATSC)
                        {
                          # This will be wrong some of the time, but until
                          # we get better data, it is what it is (and it
                          # turns out it is correct a lot of the time)
                          $w->dataElement('program', $atscMinor);
                        }

                      if (defined($s->{'callsign'}))
                        {
                          $w->dataElement('fcc-callsign', $s->{'callsign'});
                        }

                      # Needed for xsd compliance, even though it was supposed to be optional for US analog
                      $w->emptyTag('cni','tt-8-30-1' => '') if (!$ATSC);

                      if ($ATSC)
                        {
                          $w->endTag('atsc-channel');
                        }
                      else
                        {
                          $w->endTag('analog-channel');
                        }
                    }

                  if (($SDtype eq 'DVB-T') || ($SDtype eq 'DVB-S') | ($SDtype eq 'DVB-C'))
                    {
                      $w->startTag('dvb-channel');
                        my $freq = $c->{'frequencyHz'};
                        if (defined($freq) && looks_like_number($freq))
                          {
                            $freq = 0 + $freq;
                            $w->dataElement('frequency', $freq);
                          }
                        my $networkID = $c->{'networkID'};
                        if (defined($networkID) && looks_like_number($networkID))
                          {
                            $networkID = 0 + $networkID;
                            $w->dataElement('original-network-id', $networkID);
                          }
                        my $transportID = $c->{'transportID'};
                        if (defined($transportID) && looks_like_number($transportID))
                          {
                            $transportID = 0 + $transportID;
                            $w->dataElement('transport-id', $transportID);
                          }
                        my $serviceID = $c->{'serviceID'};
                        if (defined($serviceID) && looks_like_number($serviceID))
                          {
                            $serviceID = 0 + $serviceID;
                            $w->dataElement('service-id', $serviceID);
                          }
                        my $lcn = $c->{'logicalChannelNumber'};
                        if (defined($lcn) && looks_like_number($lcn))
                          {
                            $lcn = 0 + $lcn;
                            $w->dataElement('lcn', $lcn);
                          }
                        my $provider = $c->{'providerCallsign'};
                        if (defined($provider))
                          {
                            $w->dataElement('provider-name', $provider);
                          }
                      $w->endTag('dvb-channel');
                    }

                $w->endTag('lineup-entry');
              }

          $w->endTag('xmltv-lineup');
        }

    $w->endTag('xmltv-lineups');

    $w->end();

    return(encode('UTF-8', $w->to_string));
  }

#
# loadOldConfig
#
# Perform the (internal) load old config function per XMLTV
#
# Note: This sub exists only to allow the grabber to
#       manage lineups without a configuration file
#
#   Input:
#              opt         - the opt hash
#   Output:
#              result      - the xml configure string
#
sub loadOldConfig
  {
    return {};
  }

#
# SD_login
#
# Convenience function for login and checks
# for success.  All errors are fatal.
#
#   Input:
#              <none>
#   Output:
#              <none>
#
sub SD_login
  {
    my $username = DB_settingsGet($DBH, 'username');
    my $passwordhash = $passwordHash || DB_settingsGet($DBH, 'passwordhash');

    if ((!defined($username)) || (!defined($passwordhash)))
      {
        print (STDERR "Your database is not configured to access the Schedules Direct service\n");
        print (STDERR "(the username or the password hash is not available in the settings table)\n");
        print (STDERR "Please re-run $SCRIPT_NAME --manage-lineups and then $SCRIPT_NAME --configure\n");
        exit(1);
      }

    if (!defined($SD->obtainToken($username, undef, $passwordhash)))
      {
        print (STDERR "Unable to authenticate to Schedules Direct: " . $SD->ErrorString() . "\n");
        exit(1);
      }

    if (!defined($SD->obtainStatus()))
      {
        print (STDERR "Unable to obtain Schedules Direct server status: " . $SD->ErrorString() . "\n");
        exit(1);
      }

    my $online = $SD->isOnline;
    if (!defined($online))
      {
        print (STDERR "Unable to obtain Schedules Direct server online status: " . $SD->ErrorString() . "\n");
        exit(1);
      }

    if (!$online)
      {
        print (STDERR "The Schedules Direct service is not currently online,  Try again later.\n");
        exit(1);
      }

    my $expiry = $SD->accountExpiry;

    if (!defined($expiry))
      {
        print (STDERR "Unable to obtain Schedules Direct account expiration: " . $SD->ErrorString() . "\n");
        exit(1);
      }

    my $expiryDateTime = DateTime::Format::ISO8601->parse_datetime($expiry);

    if ($nowDateTime > $expiryDateTime)
      {
        print (STDERR "Schedules Direct account expired on " . $expiryDateTime . "\n");
        exit(1);
      }
    return;
  }

#
# SD_isLineupFetchRequired
#
# We can avoid downloading lineup and map information
# if we have updated our maps more recently than the
# account lineup information in the account status
# indicates (small, but occasionally useful, optimization).
#
#   Input:
#              lineup(s)   - the lineup(s) to check
#   Output:
#              result      - true (fetch required) or false
#
sub SD_isLineupFetchRequired
  {
    my ($lineups, undef) = @_;

    my $sql;
    my $sth;
    my $accountStatus;
    my $accountLineupModifiedDateTime;
    my $fetchRequired = 0;

    $accountStatus = $SD->obtainStatus;

    if (!defined($accountStatus))
      {
        print (STDERR "Unable to obtain Schedules Direct account status: " . $SD->ErrorString . "\n");
        exit(1);
      }

    $sql = 'select 1 from lineups l1 where (l1.lineup = ? and l1.modified <= ?) ' .
             'union select 1 where not exists (select 1 from lineups l2 where l2.lineup = ?)';

    $sth = $DBH->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
        exit(1);
      }

    # Since each lineup has a (potential) different modified date, we will do it the long way
    for my $lineup(@{$lineups})
      {
        undef $accountLineupModifiedDateTime;
        if (defined($accountStatus->{'lineups'}))
          {
            for my $l (@{$accountStatus->{'lineups'}})
              {
                if (defined($l->{'lineup'}) && ($l->{'lineup'} eq $lineup))
                  {
                    $accountLineupModifiedDateTime = DateTime::Format::ISO8601->parse_datetime($l->{'modified'});
                    last;
                  }
                if (defined($l->{'ID'}) && ($l->{'ID'} eq $lineup))
                  {
                    $accountLineupModifiedDateTime = DateTime::Format::ISO8601->parse_datetime($l->{'modified'});
                    last;
                  }
              }
          }

        $accountLineupModifiedDateTime = $nowDateTime->clone() if (!defined($accountLineupModifiedDateTime));

        $sth->bind_param( 1, $lineup, SQL_VARCHAR );
        $sth->bind_param( 2, DateTime::Format::SQLite->format_datetime($accountLineupModifiedDateTime), SQL_DATETIME );
        $sth->bind_param( 3, $lineup, SQL_VARCHAR );

        $sth->execute();

        if ($sth->err())
          {
            print (STDERR "Unexpected error when executing statement ($sql): " . $sth->errstr . "\n");
            exit(1)
          }

        $fetchRequired |= ($sth->fetchrow_array() || 0);

        $sth->finish();

      }

    return ($fetchRequired);
  }

#
# SD_cleanLineups
#
# Convenience routine to clean the database of
# lineups not in the account.  Errors are fatal.
#
#   Input:
#              <none>
#   Output:
#              <none>
#
sub SD_cleanLineups
  {
    my $sql;
    my $sth;
    my $param;
    my $status;
    my @accountLineups = ();

    #
    # Delete any lineups not in our account
    #
    $status = $SD->obtainStatus();

    if (!defined($status))
      {
        print (STDERR "Unable to obtain Schedules Direct account status: " . $SD->ErrorString() . "\n");
        exit(1);
      }

    if (defined($status->{'lineups'}))
      {
        foreach my $alu(@{$status->{'lineups'}})
          {
            if (defined($alu->{'lineup'}))
              {
                push(@accountLineups, $alu->{'lineup'});
              }
            elsif (defined($alu->{'ID'}))
              {
                push(@accountLineups, $alu->{'ID'});
              }
          }
      }

    $sql = 'delete from lineups where lineup not in ( ' . join(', ', ('?') x scalar(@accountLineups)) . ' )';

    $sth = $DBH->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
        exit(1);
      }

    $param = 1;
    for (my $i=0; $i < scalar(@accountLineups); $i++)
      {
        $sth->bind_param( $param, $accountLineups[$i], SQL_VARCHAR);
        $param++;
      }

    $sth->execute();

    if ($sth->err)
      {
        print (STDERR "Unexpected error when executing statement ($sql): " . $sth->errstr . "\n");
        exit(1);
      }

    $DBH->commit();

    return;
  }

#
# SD_downloadLineups
#
# Convenience routine to download lineups and
# place into our database.  Errors are fatal.
#
#   Input:
#              <none>
#   Output:
#              <none>
#
sub SD_downloadLineups
  {
    my $sql;
    my $sth;
    my $sql1;
    my $sth1;
    my $lu;
    my $lineups;

    SD_cleanLineups();

    #
    # Obtain our lineups
    #
    $lu = $SD->obtainLineups();
    if (!defined($lu))
      {
        print (STDERR "Fatal error obtaining lineups: " . $SD->ErrorString() . "\n");
        print (STDERR "Please re-run $SCRIPT_NAME --manage-lineups\n");
        print (STDERR "and/or $SCRIPT_NAME --configure\n");
        exit(1);
      }
    $lineups = $lu->{'lineups'};
    if (!defined($lineups))
      {
        print (STDERR "Fatal error obtaining lineups\n");
        print (STDERR "Please re-run $SCRIPT_NAME --manage-lineups\n");
        print (STDERR "and/or $SCRIPT_NAME --configure\n");
        exit(1);
      }

    #
    # insert or ignore, and then update in order to initialize
    # downloaded and modified as 1970-01-01 00:00:00 if new,
    # and maintain the dates if existing.
    #

    $sql = "insert or ignore into lineups (lineup, name, location, transport, details) values (?, ?, ?, ?, ?)";
    $sth = $DBH->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
        exit(1);
      }
    $sql1 = "update lineups set name = ?, location = ?, transport = ?, details = ? where lineup = ?";
    $sth1 = $DBH->prepare_cached($sql1);
    if (!defined($sth1))
      {
        print (STDERR "Unexpected error when preparing statement ($sql1): " . $DBH->errstr . "\n");
        exit(1);
      }

    for my $l (@{$lineups})
      {
        my $id = $l->{'lineup'};
        next if (!defined($id));
        my $name = $l->{'name'} || '';
        my $transport = $l->{'transport'} || '';
        my $location = $l->{'location'} || '';
        my $details = $JSON->utf8->canonical->encode($l);
        $sth->bind_param( 1, $id, SQL_VARCHAR );
        $sth->bind_param( 2, $name, SQL_VARCHAR );
        $sth->bind_param( 3, $location, SQL_VARCHAR );
        $sth->bind_param( 4, $transport, SQL_VARCHAR );
        $sth->bind_param( 5, $details, SQL_VARCHAR );
        $sth->execute();
        if ($sth->err)
          {
            print (STDERR "Unexpected error when executing statement ($sql): " . $sth->errstr . "\n");
            exit(1);
          }
        $sth1->bind_param( 1, $name, SQL_VARCHAR );
        $sth1->bind_param( 2, $location, SQL_VARCHAR );
        $sth1->bind_param( 3, $transport, SQL_VARCHAR );
        $sth1->bind_param( 4, $details, SQL_VARCHAR );
        $sth1->bind_param( 5, $id, SQL_VARCHAR );
        $sth1->execute();
        if ($sth1->err)
          {
            print (STDERR "Unexpected error when executing statement ($sql1): " . $sth1->errstr . "\n");
            exit(1);
          }
      }

    $DBH->commit();

    return;
  }

#
# SD_downloadLineupMaps
#
# Convenience routine to download maps for a lineup
# and place into our database.  Errors are fatal.
#
#   Input:
#              lineup      - Lineup to update
#   Output:
#              <none>      - database updated
#
sub SD_downloadLineupMaps
  {

    my ($lineup, undef) = @_;

    my $maps = $SD->obtainLineupMaps($lineup);

    if (!defined($maps))
      {
        print (STDERR "Unable to obtainLineupMap for lineup $lineup: " . $SD->ErrorString() . "\n");
        exit(1);
      }

    if (!defined($maps->{'map'}))
      {
        print (STDERR "Lineup map for lineup $lineup does not contain a channel entity\n");
        exit(1);
      }
    if (!defined($maps->{'stations'}))
      {
        print (STDERR "Lineup map for lineup $lineup does not contain a station entity\n");
        exit(1);
      }

    my $sql;
    my $sth;
    my $lineupChannelsSelected = 1;
    my $lineupTransport = '';

    $sql = "select new_channels_selected, transport from lineups where lineup = ?";
    $sth = $DBH->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
        exit(1);
      }
    $sth->bind_param( 1, $lineup, SQL_VARCHAR );
    $sth->execute();
    $sth->bind_col( 1, \$lineupChannelsSelected, SQL_INTEGER );
    $sth->bind_col( 2, \$lineupTransport, SQL_VARCHAR );
    $sth->fetch();
    if ($sth->err)
      {
        print (STDERR "Unexpected database error when executing statement ($sql): " . $sth->errstr . "\n");
        $DBH->rollback();
        exit(1);
      }
    $sth->finish();

    $sql = "create temp table if not exists channels_backup as select * from channels where 1<>1";
    $sth = $DBH->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
        exit(1);
      }
    $sth->execute();
    if ($sth->err)
      {
        print (STDERR "Unexpected database error when executing statement ($sql): " . $sth->errstr . "\n");
        $DBH->rollback();
        exit(1);
      }

    $sql = "delete from channels_backup";
    $sth = $DBH->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
        exit(1);
      }
    $sth->execute();
    if ($sth->err)
      {
        print (STDERR "Unexpected database error when executing statement ($sql): " . $sth->errstr . "\n");
        $DBH->rollback();
        exit(1);
      }

    $sql = "insert into channels_backup select * from channels where lineup = ?";
    $sth = $DBH->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
        exit(1);
      }
    $sth->bind_param( 1, $lineup, SQL_VARCHAR );
    $sth->execute();
    if ($sth->err)
      {
        print (STDERR "Unexpected database error when executing statement ($sql): " . $sth->errstr . "\n");
        $DBH->rollback();
        exit(1);
      }

    $sql = "delete from channels where lineup = ?";
    $sth = $DBH->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
        exit(1);
      }
    $sth->bind_param( 1, $lineup, SQL_VARCHAR );
    $sth->execute();
    if ($sth->err)
      {
        print (STDERR "Unexpected database error when executing statement ($sql): " . $sth->errstr . "\n");
        $DBH->rollback();
        exit(1);
      }

    $sql = "replace into channels (lineup, station, selected, channum, details) values (?, ?, ?, ?, ?)";
    $sth = $DBH->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
        exit(1);
      }

    foreach my $c (@{$maps->{'map'}})
      {
        my $station = $c->{'stationID'};
        $station = '' if (!defined($station));
        my $details = $JSON->utf8->canonical->encode($c);
        my $channum = '';
        if (($lineupTransport eq 'Cable') ||
            ($lineupTransport eq 'Satellite') ||
            ($lineupTransport eq 'DVB-C') ||
            ($lineupTransport eq 'DVB-T') ||
            ($lineupTransport eq 'DVB-S') ||
            ($lineupTransport eq 'IPTV'))
          {
            $channum = $c->{'channel'} if (defined($c->{'channel'}));
            $channum = 0 + $channum if (looks_like_number($channum));
          }
        elsif ($lineupTransport eq 'Antenna')
          {
            my $atscMajor = $c->{'atscMajor'};
            my $atscMinor = $c->{'atscMinor'};
            my $uhfVhf = $c->{'uhfVhf'};
            if (defined($atscMajor) && defined($atscMinor) &&
                looks_like_number($atscMajor) && looks_like_number($atscMinor))
              {
                $atscMajor = 0 + $atscMajor;
                $atscMinor = 0 + $atscMinor;
                $channum = "$atscMajor.$atscMinor";
              }
            elsif (defined($uhfVhf) && looks_like_number($uhfVhf))
              {
                $channum = 0 + $uhfVhf;
              }
          }
        $sth->bind_param( 1, $lineup, SQL_VARCHAR );
        $sth->bind_param( 2, $station, SQL_VARCHAR );
        $sth->bind_param( 3, $lineupChannelsSelected, SQL_INTEGER );
        $sth->bind_param( 4, $channum, SQL_VARCHAR );
        $sth->bind_param( 5, $details, SQL_VARCHAR );
        $sth->execute();
        if ($sth->err)
          {
            print (STDERR "Unexpected error when executing statement ($sql): " . $sth->errstr . "\n");
            exit(1);
          }
      }

    # Preserve previous selected values (if they exist) by copying them across
    # The match must be by lineup, station, and channum.  So if the station
    # changes, the selection resets (it may be a new station on that channel,
    # or it could be a change in feed (east coast to west coast), either are
    # likely for Cable/Satellite, but it is impossible to know the details,
    # so we have to consider it a new/revised channel.  Simliarly, if the
    # channum changes, we have to consider this a different channel, even
    # if the station is the same (another channel on the STB, or sometimes
    # a (new) HD version of a channel, or a repeater channel).  In other
    # words, the preservation works (reasonably well) only when the channel
    # really stays the same, but it is vulnerable to a certain class of
    # well known changes in real world lineups.
    $sql = "update channels set selected = (select selected from channels_backup where channels.lineup = channels_backup.lineup and channels.channum = channels_backup.channum and channels.station = channels_backup.station ) where lineup = ? and exists(select 1 from channels_backup where channels.lineup = channels_backup.lineup and channels.channum = channels_backup.channum and channels.station = channels_backup.station)";
    $sth = $DBH->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
        exit(1);
      }
    $sth->bind_param( 1, $lineup, SQL_VARCHAR );
    $sth->execute();
    if ($sth->err)
      {
        print (STDERR "Unexpected database error when executing statement ($sql): " . $sth->errstr . "\n");
        $DBH->rollback();
        exit(1);
      }

    $sql = "replace into stations (station, details) values (?, ?)";
    $sth = $DBH->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
        exit(1);
      }

    foreach my $s (@{$maps->{'stations'}})
      {
        # Our satellite lineup has a [] in the middle where all other
        # elements are hash refs so eval to avoid termination.
        my $station = eval { $s->{'stationID'} };
        next if (!defined($station));
        my $details = $JSON->utf8->canonical->encode($s);

        $sth->bind_param( 1, $station, SQL_VARCHAR );
        $sth->bind_param( 2, $details, SQL_VARCHAR );

        $sth->execute();

        if ($sth->err)
          {
            print (STDERR "Unexpected error when executing statement ($sql): " . $sth->errstr . "\n");
            exit(1);
          }
      }

    $sql = "update lineups set modified = ? where lineup = ?";
    $sth = $DBH->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
        exit(1);
      }
    $sth->bind_param( 1, $nowDateTimeSQLite, SQL_DATETIME );
    $sth->bind_param( 2, $lineup, SQL_VARCHAR );

    $sth->execute();
    if ($sth->err)
      {
        print (STDERR "Unexpected error when executing statement ($sql): " . $sth->errstr . "\n");
        exit(1);
      }

    $DBH->commit();

    return;
  }

#
# lineupValidate
#
# Convenience routine to validate that the specified
# lineup(s) are still in our Schedules Direct lineup
#
# If the lineup is not valid we write a message and exit
#
#   Input:
#              lineup(s)    - Lineup(s) to validate
#   Output:
#              <none>
#
sub lineupValidate
  {
    my ($lineups, undef) = @_;
    my @lineups = ref($lineups) eq 'ARRAY' ? @{$lineups} : ($lineups);

    my $fatal = 0;

    my $sql = 'select lineup, name, transport, location, details from lineups where lineup = ?';

    my $sth = $DBH->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
        exit(1);
      }

    foreach my $lineup (@lineups)
      {
        $sth->bind_param( 1, $lineup, SQL_VARCHAR );

        $sth->execute();

        if ($sth->err())
          {
            print (STDERR "Unexpected error when executing statement ($sql): " . $sth->errstr . "\n");
            exit(1)
           }

        $sth->bind_col( 1, undef, SQL_VARCHAR );
        $sth->bind_col( 2, undef, SQL_VARCHAR );
        $sth->bind_col( 3, undef, SQL_VARCHAR );
        $sth->bind_col( 4, undef, SQL_VARCHAR );
        $sth->bind_col( 5, undef, SQL_VARCHAR );

        my $llu = $sth->fetchrow_arrayref();

        $sth->finish();

        if (!defined($llu))
          {
            print (STDERR "Lineup $lineup is no longer configured in your account at Schedules Direct.\n");
            print (STDERR "Please run $SCRIPT_NAME --manage-lineups to manage your Schedules Direct lineups,\n");
            print (STDERR "and/or $SCRIPT_NAME --configure to change the configured lineups.\n");
            $fatal = 1;
          }
        else
          {
            my $lineupDeleted = $JSON->utf8->decode($llu->[4])->{'isDeleted'};

            if (defined($lineupDeleted) && $lineupDeleted)
              {
                print (STDERR "Lineup $lineup has been deleted at Schedules Direct.\n");
                print (STDERR "Please run $SCRIPT_NAME --manage-lineups to manage your Schedules Direct lineups,\n");
                print (STDERR "and/or $SCRIPT_NAME --configure to change the configured lineups.\n");
                $fatal = 1;
              }
          }
      }

    if ($fatal)
      {
        exit(1);
      }
  }

#
# configValidate
#
# Convenience routine to validate that the configuration
# file contains some basic information (database file
# and lineup).
#
# If the configuration does not contain the basic info
# we write a message and exit
#
#   Input:
#              conf        - The $conf array
#              opt         - The $opt array
#   Output:
#              <none>
#
sub configValidate
  {
    my ($conf, $opt, undef) = @_;

    if (!defined($conf->{'database'}->[0]))
      {
        print (STDERR "Database not defined in config file $opt->{'config-file'}.\n");
        print (STDERR "Please run '$SCRIPT_NAME --configure'\n");
        exit(1);
      }
    if (!defined($conf->{'lineup'}->[0]))
      {
        print (STDERR "Lineup not defined in config file $opt->{'config-file'}.\n");
        print (STDERR "Please run '$SCRIPT_NAME --configure'\n");
        exit(1);
      }
  }

#
# askChoice
#
# Convenience routine to ask for a selection and
# return the value
#
#   Input:
#              prompt      - Prompt
#              default     - (or undef which means the first)
#              options     - array of arrays (inner array is [value, text])
#   Output:
#              value       - selected value (or undef for ctrl-D)
#
sub askChoice
  {
    my ($prompt, $default, @options) = @_;

    my @optionsvalue;
    my @optionstext;

    foreach my $option ( @options )
      {
        push @optionsvalue, @{$option}[0];
        push @optionstext, @{$option}[1];
      }

    if (!defined($default))
      {
        $default = $optionstext[0];
      }

    my $selection = ask_choice($prompt, $default, @optionstext);

    return if (!defined($selection));

    for ( my $i=0; $i<scalar( @optionstext ); $i++ )
      {
        if( $optionstext[$i] eq $selection )
          {
            return $optionsvalue[$i];
          }
      }

    return;
  }

#
# DB_open_global
#
# Convenience routine to open the database
#
# If the database does not exist, a new
# database will be created with the needed
# schema
#
# If the database needs to be upgraded the
# upgrade will be performed
#
# In the database cannot be opened, a message
# is written and program exit occurs
#
#   Input:
#              database    - database name to open
#   Output:
#              <none>
#
sub DB_open_global
  {
    my ($dbname, undef) = @_;

    #
    # Quick exit if we already have the database open
    #
    return if (defined($DBH));
    return $DBH = DB_open_local(dbname => $dbname);
}

sub exit_if_db_err {
    my ($db, $rc, $reason) = @_;
    if ((!defined($rc)) || ($rc < 0)) {
        $reason = "" unless $reason;
        print (STDERR "ERROR: $reason: " . $db->errstr . "\n");
        $db->rollback();
        exit(1);
    }
}

# Open a database and return the handle.
sub DB_open_local {
    my (%opts) = @_;
    my $dbname = $opts{dbname} // $conf->{'database'}->[0];

    if (!defined($dbname))
      {
        print (STDERR "The Schedules Direct EPG database location is not specified\n");
        print (STDERR "Please re-run $SCRIPT_NAME --manage-lineups and/or $SCRIPT_NAME --configure\n");
        exit(1);
      }

    #
    # Ensure base directory exists
    #
    if (! -d dirname("$dbname"))
      {
        eval
          {
            local $SIG{'__DIE__'};  # ignore user-defined die handlers
            make_path(dirname("$dbname"));
          };
        if ($@)
          {
            print (STDERR "Unable to create parent directory for $dbname: $@");
            exit(1)
          }
      }

    my $db = DBI->connect("DBI:SQLite:dbname=$dbname", "", "",
                        { RaiseError => $opts{RaiseError}, PrintError => $opts{PrintError}, AutoCommit => $opts{AutoCommit} });

    if (!defined($db))
      {
        print (STDERR "Unable to open database file $dbname: " . $db->errstr . "\n");
        exit(1);
      }

    # Open without upgrading db.
    # Useful for second connections to avoid overhead.
    # Have to do this before pragmas otherwise we seem
    # to deadlock as it tries to change db parameters.
    if ($opts{noupgrade}) {
        return $db
    }

    #
    # SQLite specific optimizations (if it works, it works)
    #
    $db->{'AutoCommit'} = 1;
    $db->do("PRAGMA page_size=4096");
    $db->do("PRAGMA auto_vacuum=2");
    $db->do("PRAGMA journal_mode=WAL");
    $db->{'AutoCommit'} = $opts{AutoCommit};

    #
    # Create settings tables if needed
    #
    my $rc = $db->do("create table if not exists settings (" .
                        "tag varchar(256) not null primary key, " .
                        "value varchar(256))");
    if ((!defined($rc)) || ($rc < 0))
      {
        print (STDERR "Unable to create settings table in database $dbname: " . $db->errstr . "\n");
        $db->rollback();
        exit(1);
      }
    $db->commit();

    #
    # Validate DB version support
    #
    my $version = DB_settingsGet($db, 'version');
    $version = 0 if (!defined($version));
    if ($version =~ /^\d+$/)
      {
        $version = 0 + $version;
      }
    else
      {
        print (STDERR "Database version ($version) is not a valid version number\n");
        exit(1);
      }

    if (0 == $version)  ## Initial database creation
      {
        print (STDERR "Initializing database $dbname\n") if (!$quiet);
        my $rc;
        $rc = $db->do("create table lineups ( " .
                         "lineup varchar(128) not null primary key, " .
                         "name varchar(128) not null, " .
                         "location varchar(128) not null, " .
                         "transport varchar(64) not null, " .
                         "downloaded datetime not null default '1970-01-01 00:00:00', " .
                         "modified datetime not null default '1970-01-01 00:00:00', " .
                         "new_channels_selected integer not null default 1, " .
                         "details blob not null )");
        if ((!defined($rc)) || ($rc < 0))
          {
            print (STDERR "Unable to create lineups table in database $dbname: " . $db->errstr . "\n");
            $db->rollback();
            exit(1);
          }
        $rc = $db->do("create table programs ( " .
                         "program varchar(128) not null primary key, " .
                         "hash varchar(64) not null, " .
                         "details blob not null )");
        if ((!defined($rc)) || ($rc < 0))
          {
            print (STDERR "Unable to create programs table in database $dbname: " . $db->errstr . "\n");
            $db->rollback();
            exit(1);
          }
        $rc = $db->do("create table stations ( " .
                         "station varchar(128) not null primary key, " .
                         "details blob not null )");
        if ((!defined($rc)) || ($rc < 0))
          {
            print (STDERR "Unable to create stations table in database $dbname: " . $db->errstr . "\n");
            $db->rollback();
            exit(1);
          }
        $rc = $db->do("create table stations_schedules_hash ( " .
                         "station varchar(128) not null, " .
                         "day date not null, " .
                         "hash varchar(64) not null, " .
                         "details blob not null, " .
                         "primary key(station, day) )");
        if ((!defined($rc)) || ($rc < 0))
          {
            print (STDERR "Unable to create stations_schedules_hash table in database $dbname: " . $db->errstr . "\n");
            $db->rollback();
            exit(1);
          }
        $rc = $db->do("create index stations_schedules_hash_index_hash on stations_schedules_hash (hash)");
        if ((!defined($rc)) || ($rc < 0))
          {
            print (STDERR "Unable to create stations schedules hash index in database $dbname: " . $db->errstr . "\n");
            $db->rollback();
            exit(1);
          }
        $rc = $db->do("create table channels ( " .
                         "lineup varchar(128) not null, " .
                         "station varchar(128) not null, " .
                         "channum varchar(128) not null default '', " .
                         "selected integer not null default 1, " .
                         "details blob not null )");
        if ((!defined($rc)) || ($rc < 0))
          {
            print (STDERR "Unable to create channels table in database $dbname: " . $db->errstr . "\n");
            $db->rollback();
            exit(1);
          }
        $rc = $db->do("create index channels_index_lineup_station on channels (lineup, station)");
        if ((!defined($rc)) || ($rc < 0))
          {
            print (STDERR "Unable to create channel index in database $dbname: " . $db->errstr . "\n");
            $db->rollback();
            exit(1);
          }
        $rc = $db->do("create table schedules_hash ( " .
                         "station varchar(128) not null, " .
                         "day date not null, " .
                         "hash varchar(64) not null, " .
                         "primary key (station, day) )");
        if ((!defined($rc)) || ($rc < 0))
          {
            print (STDERR "Unable to create schedules_hash table in database $dbname: " . $db->errstr . "\n");
            $db->rollback();
            exit(1);
          }
        $rc = $db->do("create index schedules_hash_index_hash on schedules_hash (hash)");
        if ((!defined($rc)) || ($rc < 0))
          {
            print (STDERR "Unable to create schedules hash index in database $dbname: " . $db->errstr . "\n");
            $db->rollback();
            exit(1);
          }
        $rc = $db->do("create table schedules ( " .
                         "station varchar(128) not null, " .
                         "day date not null, " .
                         "starttime datetime not null, " .
                         "duration integer not null, " .
                         "program varchar(128) not null, " .
                         "program_hash varchar(64) not null, " .
                         "details blob not null, " .
                         "primary key (station, day, starttime, duration) )");
        if ((!defined($rc)) || ($rc < 0))
          {
            print (STDERR "Unable to create schedules table in database $dbname: " . $db->errstr . "\n");
            $db->rollback();
            exit(1);
          }
        $rc = $db->do("create index schedules_index_station_starttime on schedules (station, starttime)");
        if ((!defined($rc)) || ($rc < 0))
          {
            print (STDERR "Unable to create schedules index in database $dbname: " . $db->errstr . "\n");
            $db->rollback();
            exit(1);
          }
        $rc = $db->do("create index schedules_index_program on schedules (program)");
        if ((!defined($rc)) || ($rc < 0))
          {
            print (STDERR "Unable to create schedules program index in database $dbname: " . $db->errstr . "\n");
            $db->rollback();
            exit(1);
          }

        $version = 1;
        DB_settingsSet($db, 'version', 1);
        $db->commit();
      }

    if ($version > $SCRIPT_DB_VERSION)
      {
        print (STDERR "Database version $version is not supported (newer than grabber version $SCRIPT_DB_VERSION)\n");
        exit(1);
      }
    elsif ($version < $SCRIPT_DB_VERSION)
      {
        if (1 == $version)
          {
            $version = 2;
            print (STDERR "Upgrading database to version $version\n") if (!$quiet);
            $rc = $db->do("alter table programs add column program_supplemental varchar(128)");
            if ((!defined($rc)) || ($rc < 0))
              {
                print (STDERR "Unable to add column program_supplemental to programs table in database $dbname: " . $db->errstr . "\n");
                $db->rollback();
                exit(1);
              }
            $rc = $db->do("alter table programs add column downloaded datetime not null default '1970-01-01 00:00:00'");
            if ((!defined($rc)) || ($rc < 0))
              {
                print (STDERR "Unable to add column downloaded to programs table in database $dbname: " . $db->errstr . "\n");
                $db->rollback();
                exit(1);
              }
            $rc = $db->do("create index programs_index_program_supplemental on programs(program_supplemental)");
            if ((!defined($rc)) || ($rc < 0))
              {
                print (STDERR "Unable to create programs_index_program_supplemental in database $dbname: " . $db->errstr . "\n");
                $db->rollback();
                exit(1);
              }
            $rc = $db->do("create index programs_index_downloaded on programs(downloaded)");
            if ((!defined($rc)) || ($rc < 0))
              {
                print (STDERR "Unable to create programs_index_downloaded in database $dbname: " . $db->errstr . "\n");
                $db->rollback();
                exit(1);
              }
            # Update existing programs
            $sql = "update programs set downloaded = ?";
            $sth = $db->prepare_cached($sql);
            if (!defined($sth))
              {
                print (STDERR "Unexpected error when preparing statement ($sql): " . $db->errstr . "\n");
                $db->rollback();
                exit(1);
              }
            $sth->bind_param( 1, $nowDateTimeSQLite, SQL_DATETIME );
            $sth->execute();
            if ($sth->err)
              {
                print (STDERR "Unexpected error when executing statement ($sql): " . $sth->errstr . "\n");
                $db->rollback();
                exit(1);
              }
            $sql = "update programs set program_supplemental = 'SH' || substr(program,3,8) || '0000' where program like 'EP%'";
            $sth = $db->prepare_cached($sql);
            if (!defined($sth))
              {
                print (STDERR "Unexpected error when preparing statement ($sql): " . $db->errstr . "\n");
                $db->rollback();
                exit(1);
              }
            $sth->execute();
            if ($sth->err)
              {
                print (STDERR "Unexpected error when executing statement ($sql): " . $sth->errstr . "\n");
                $db->rollback();
                exit(1);
              }
            DB_settingsSet($db, 'version', $version);
            $db->commit();
        }

        if (2 == $version)
          {
              $version = 3;
              print (STDERR "Updating database to version $version\n") if (!$quiet);
                      $rc = $db->do("create table if not exists artwork ( " .
                         "program varchar(128) not null primary key, " .
                         "hash varchar(64) not null, " .
                         "details blob not null) ");
              if ((!defined($rc)) || ($rc < 0))
                {
                    print (STDERR "Unable to create artwork table in database $dbname: " . $db->errstr . "\n");
                    $db->rollback();
                    exit(1);
                }

              DB_settingsSet($db, 'version', $version);
              $db->commit();
          }

        if (3 == $version)
          {
              $version = 4;
              print (STDERR "Updating database to version $version\n") if (!$quiet);
              $rc = $db->do("alter table artwork add downloaded datetime");
              exit_if_db_err($db, $rc, "Alter table artwork");
              $rc = $db->do("update artwork set downloaded = datetime('now') where downloaded is null");
              exit_if_db_err($db, $rc, "Update download time");
              $rc = $db->do("create index artwork_index_downloaded on artwork(downloaded)");
              exit_if_db_err($db, $rc, "Add index to artwork");
              # Add a couple of indexes that are useful for pruning.
              $rc = $db->do("create index ssh_index_day on stations_schedules_hash(day)");
              exit_if_db_err($db, $rc, "Create index on stations_schedules_hash");
              DB_settingsSet($db, 'version', $version);
              $db->commit();
          }

        ##
        ##  if (2 == $version   ## Example upgrade (version 2 to 3)
        ##    {
        ##      $version = 3;
        ##      print (STDERR "Updating database to version $version\n") if (!$quiet);
        ##      ## Alter table, create index, ?
        ##      DB_settingsSet($db, 'version', $version);
        ##      $db->commit();
        ##    }
      }
    return $db;
  }

#
# DB_settingsGet
#
# Convenience routine to get a setting from the database
#
#   Input:
#              db          - database to use
#              tag         - the tag
#   Output:
#              value       - of the tag (or undef)
#
sub DB_settingsGet
  {
    my ($db, $tag, undef) = @_;

    my $value;

    my $sql = "select value from settings where tag = ?";

    my $sth = $db->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $db->errstr . "\n");
        exit(1);
      }

    $sth->bind_param( 1, $tag, SQL_VARCHAR );

    $sth->execute();
    if ($sth->err)
      {
        print (STDERR "Unexpected error when executing statement ($sql): " . $sth->errstr . "\n");
        exit(1);
      }

    $sth->bind_col( 1, \$value);

    $sth->fetch();

    if ($sth->err)
      {
        print (STDERR "Unexpected error when fetching row ($sql): " . $sth->errstr . "\n");
        exit(1)
      }

    $sth->finish();

    return ($value);
  }

#
# DB_settingsSet
#
# Convenience routine to set a setting in the database
#
#   Input:
#              tag         - the tag
#              value       - the value to set
#   Output:
#              <none>
#
sub DB_settingsSet
  {
    my ($db, $tag, $value, undef) = @_;

    my $sql = "replace into settings (tag, value) values (?, ?)";

    my $sth = $db->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $db->errstr . "\n");
        exit(1);
      }

    $sth->bind_param( 1, $tag, SQL_VARCHAR );
    $sth->bind_param( 2, $value, SQL_VARCHAR );

    $sth->execute();

    if ($sth->err)
      {
        print (STDERR "Unexpected error when executing statement ($sql): " . $sth->errstr . "\n");
        $db->rollback();
        exit(1);
      }

    $sth->finish();

    return;
  }

#
# DB_prune
#
# Convenience routine to prune the database of old
# or obsolete content.
#
#   Input:
#              <none>
#   Output:
#              <none>
#
sub DB_prune
  {
    return if (!defined($DBH));

    my $sql;
    my $sth;
    my $rc;

    my $expireBeforeDateTime = DateTime->now(time_zone => 'UTC')->subtract(days => 1);
    my $expireAfterDateTime = DateTime->now(time_zone => 'UTC')->add(days => 30);
    # Ignore records downloaded after this when doing lazy pruning.
    my $lazyPruneDownloadDate = DateTime->now(time_zone => 'UTC')->subtract(days => 14);

    # Update any lineups where the downloaded datetime is in the future (bad rtc?)
    $sql = "update lineups set downloaded = '1970-01-01 00:00:00' where downloaded > ?";
    $sth = $DBH->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
        exit(1);
      }
    $sth->bind_param( 1, $nowDateTimeSQLite, SQL_DATETIME );
    $sth->execute();
    if ($sth->err)
      {
        print (STDERR "Unable to update lineups with downloaded dates in the future in database: " . $sth->errstr . "\n");
      }

    # Update any lineups where the modified datetime is in the future (bad rtc?)
    $sql = "update lineups set modified = '1970-01-01 00:00:00' where modified > ?";
    $sth = $DBH->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
        exit(1);
      }
    $sth->bind_param( 1, $nowDateTimeSQLite, SQL_DATETIME );
    $sth->execute();
    if ($sth->err)
      {
        print (STDERR "Unable to update linesups with modified dates in the future in database: " . $sth->errstr . "\n");
      }

    # Delete channels no longer in any of our lineups
    $sql = "delete from channels where lineup not in (select distinct lineups.lineup from lineups as lineups)";
    $sth = $DBH->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
        exit(1);
      }
    $sth->execute();
    if ($sth->err)
      {
        print (STDERR "Unable to prune channels no longer in our lineups in database: " . $sth->errstr . "\n");
      }

    # Delete stations no longer in any of our channels
    $sql = "delete from stations where station not in (select distinct channels.station from channels as channels)";
    $sth = $DBH->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
        exit(1);
      }
    $sth->execute();
    if ($sth->err)
      {
        print (STDERR "Unable to prune stations no longer in our channels in database: " . $sth->errstr . "\n");
      }

    # Delete schedules no longer referenced by our stations
    # We now lazily only delete them once their day elapses to avoid runtime.
    $sql = "delete from schedules where day < ? or day > ?"; # or station not in (select distinct stations.station from stations as stations)";
    $sth = $DBH->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
        exit(1);
      }
    $sth->bind_param( 1, DateTime::Format::SQLite->format_date($expireBeforeDateTime), SQL_DATE );
    $sth->bind_param( 2, DateTime::Format::SQLite->format_date($expireAfterDateTime), SQL_DATE );
    $sth->execute();
    if ($sth->err)
      {
        print (STDERR "Unable to prune schedules for past and far future dates in database: " . $sth->errstr . "\n");
      }

    # Delete schedules_hash no longer referenced by our stations
    # We now lazily only delete them once their day elapses to avoid runtime.
    $sql = "delete from schedules_hash where day < ? or day > ?"; #  or station not in (select stations.station from stations as stations)";
    $sth = $DBH->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
        exit(1);
      }
    $sth->bind_param( 1, DateTime::Format::SQLite->format_date($expireBeforeDateTime), SQL_DATE );
    $sth->bind_param( 2, DateTime::Format::SQLite->format_date($expireAfterDateTime), SQL_DATE );
    $sth->execute();
    if ($sth->err)
      {
        print (STDERR "Unable to prune schedules_hash for past and far future dates in database: " . $sth->errstr . "\n");
    }

    # We now leave these in the schedules_hash and just let them expire once the day passes.
    # This is to avoid runtime every day processing them.

    # # Delete schedules_hash which have no matching schedules
    # $sql = "delete from schedules_hash where not exists (select * from schedules as schedules where schedules.station = schedules_hash.station and schedules.day = schedules_hash.day)";
    # $sth = $DBH->prepare_cached($sql);
    # if (!defined($sth))
    #   {
    #     print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
    #     exit(1);
    #   }
    # $sth->execute();
    # if ($sth->err)
    #   {
    #     print (STDERR "Unable to prune schedules_hash which have no matching schedule in database: " . $sth->errstr . "\n");
    #   }

    # # Delete schedules for which there is no schedules_hash
    # $sql = "delete from schedules where not exists (select * from schedules_hash as schedules_hash where schedules.station = schedules_hash.station and schedules.day = schedules_hash.day)";
    # $sth = $DBH->prepare_cached($sql);
    # if (!defined($sth))
    #   {
    #     print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
    #     exit(1);
    #   }
    # $sth->execute();
    # if ($sth->err)
    #   {
    #     print (STDERR "Unable to prune schedules for unmatched schedule hashes in database: " . $sth->errstr . "\n");
    #   }

    # # Delete stations_schedules_hash no longer referenced by our stations
    # $sql = "delete from stations_schedules_hash where station not in (select distinct channels.station from channels as channels)";
    # $sth = $DBH->prepare_cached($sql);
    # if (!defined($sth))
    #   {
    #     print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
    #     exit(1);
    #   }
    # $sth->execute();
    # if ($sth->err)
    #   {
    #     print (STDERR "Unable to prune stations_schedules_hash in database: " . $sth->errstr . "\n");
    #   }

    # Delete stations_schedules_hash which have "expired"
    $sql = "delete from stations_schedules_hash where day < ? OR day > ?";
    $sth = $DBH->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
        exit(1);
      }
    $sth->bind_param( 1, DateTime::Format::SQLite->format_date($expireBeforeDateTime), SQL_DATE );
    $sth->bind_param( 2, DateTime::Format::SQLite->format_date($expireAfterDateTime), SQL_DATE );
    $sth->execute();
    if ($sth->err)
      {
        print (STDERR "Unable to prune stations_schedules_hash for past and far future dates in database: " . $sth->errstr . "\n");
      }

    # Delete programs no longer referenced by a schedule and are not supplemental
    # We now do a "lazy delete" and only expire programmes earlier than a timestamp.
    # This is to reduce runtime since pruning programs takes a very long time.
    # So we assume if it recently downloaded then we can leave it (the SQL
    # for generating tv schedules won't use programmes not in schedules anyway).
    $sql = "delete from programs where downloaded < ? and program not in (select distinct schedules.program from schedules as schedules) and program not in (select distinct p2.program_supplemental from programs as p2 where p2.program_supplemental is not null)";
    $sth = $DBH->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
        exit(1);
      }
    $sth->execute($lazyPruneDownloadDate);
    if ($sth->err)
      {
        print (STDERR "Unable to prune programs no longer referenced in database: " . $sth->errstr . "\n");
      }

    # Delete artwork no longer referenced
    $sql = "delete from artwork where downloaded < ? and program not in (select distinct schedules.program from schedules as schedules) and program not in (select distinct p2.program_supplemental from programs as p2 where p2.program_supplemental is not null)";
    $sth = $DBH->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
        exit(1);
      }
    $sth->execute($lazyPruneDownloadDate);
    if ($sth->err)
      {
        print (STDERR "Unable to prune artwork no longer referenced in database: " . $sth->errstr . "\n");
      }
    elsif ($sth->rows)
      {
          print (STDERR "Number of artwork pruned: " . $sth->rows . "\n");
      }
    # Update programs which have a downloaded data in the future (bad rtc?)
    # (this should force a refresh of any supplemental programs downloaded with bad dates)
    $sql = "update programs set downloaded = '1970-01-01 00:00:00' where downloaded > ?";
    $sth = $DBH->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
        exit(1);
      }
    $sth->bind_param( 1, $nowDateTimeSQLite, SQL_DATETIME );
    $sth->execute();
    if ($sth->err)
      {
        print (STDERR "Unable to update programs with downloaded dates in the future in database: " . $sth->errstr . "\n");
      }

    $DBH->commit();

    $sql = "update artwork set downloaded = ? where downloaded > ?";
    $sth = $DBH->prepare_cached($sql);
    if (!defined($sth))
      {
        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
        exit(1);
      }
    $sth->bind_param( 1, $nowDateTimeSQLite, SQL_DATETIME );
    $sth->bind_param( 2, $nowDateTimeSQLite, SQL_DATETIME );
    $sth->execute();
    if ($sth->err)
      {
        print (STDERR "Unable to update artwork with downloaded dates in the future in database: " . $sth->errstr . "\n");
      }

    $DBH->commit();

    #
    # Because the database may not have the needed configuration
    # for incremental vacuum, we issue the command, but do not
    # check the results of the execution (it works, or not)
    #
    $DBH->{'AutoCommit'} = 1;
    $sql = "PRAGMA incremental_vacuum";
    $DBH->do($sql);
    $DBH->{'AutoCommit'} = 0;

    #
    # vacuum can be a resource intensive activity, so we do
    # not perform it by default.  Incremental vacuum will
    # handle the low hanging fruit, and users can choose
    # to perform a full vacuum as desired
    #
    # Once a month we vacuum the database since over time it can get
    # really slow. The "auto vacuum" only shuffles pages and can make
    # fragmentation worse, so we need a proper vacuum.

    my $need_vacuum = get_option('force-vacuum');
    my $vac_setting = 'vacuum-stamp';
    if (!$need_vacuum) {
        # Vacuum not forced, so check timestamp of last vacuum.
        my $now = DateTime->now->epoch;
        my $vac_date = DB_settingsGet($DBH, $vac_setting);
        # DB date does not exist (first run?) or DB date in the
        # future, so is wrong (bad RTC)
        if (!$vac_date || $vac_date > $now) {
            # Don't vacuum on first run.
            DB_settingsSet($DBH, $vac_setting, $now);
        } else {
            # How frequently (in seconds) to vacuum? Once every few months seems
            # fine.
            my $vac_frequency = get_option('vacuum-frequency') // 60 * 60 * 24 * 90;
            if ($now - $vac_date > $vac_frequency) {
                $need_vacuum = 1;
            }
        }
    }

    if ($need_vacuum) {
        print (STDERR "Vacuuming the database\n") unless $quiet;
        $DBH->{'AutoCommit'} = 1;
        $sql = "vacuum";
        $rc = $DBH->do($sql);
        if ((!defined($rc)) || ($rc < 0))
          {
              print (STDERR "Unable to vacuum database: " . $DBH->errstr . "\n");
          }
        $DBH->{'AutoCommit'} = 0;
        DB_settingsSet($DBH, $vac_setting, DateTime->now->epoch);
    }

    #
    # In many (real world) runs, substantive data has been
    # added/deleted/updated, so update any statistics for
    # future optimizer choices
    #
    $sql = "analyze";
    $rc = $DBH->do($sql);
    if ((!defined($rc)) || ($rc < 0))
      {
        print (STDERR "Unable to analyze data in database: " . $DBH->errstr . "\n");
      }

    $DBH->commit();

    return;
  }

#
# DB_clean
#
# Convenience routine to clean the database of all data
# (commonly used to force a complete download)
#
#   Input:
#              <none>
#   Output:
#              <none>
#
sub DB_clean
  {
    return if (!defined($DBH));

    my $sql;
    my $rc;

#   We do not delete the lineups, channels, or stations in order to try to
#   preserve any channel (de)selection that may have occurred.  By setting
#   the downloaded and modified dates to long ago, we will refresh those.
#
#   $sql = "delete from lineups";
#   $rc = $DBH->do($sql);
#   if ((!defined($rc)) || ($rc < 0))
#     {
#       print (STDERR "Unable to delete lineups in database: " . $DBH->errstr . "\n");
#       exit(1);
#     }
#   $sql = "delete from channels";
#   $rc = $DBH->do($sql);
#   if ((!defined($rc)) || ($rc < 0))
#     {
#       print (STDERR "Unable to delete channels in database: " . $DBH->errstr . "\n");
#       exit(1);
#     }
#   $sql = "delete from stations";
#   $rc = $DBH->do($sql);
#   if ((!defined($rc)) || ($rc < 0))
#     {
#       print (STDERR "Unable to delete stations in database: " . $DBH->errstr . "\n");
#       exit(1);
#     }
    $sql = "update lineups set downloaded = '1970-01-01 00:00:00', modified = '1970-01-01 00:00:00'";
    $rc = $DBH->do($sql);
    if ((!defined($rc)) || ($rc < 0))
      {
        print (STDERR "Unable to update lineups in database: " . $DBH->errstr . "\n");
        exit(1);
      }
    $sql = "delete from stations_schedules_hash";
    $rc = $DBH->do($sql);
    if ((!defined($rc)) || ($rc < 0))
      {
        print (STDERR "Unable to delete stations_schedules_hash in database: " . $DBH->errstr . "\n");
        exit(1);
      }
    $sql = "delete from schedules_hash";
    $rc = $DBH->do($sql);
    if ((!defined($rc)) || ($rc < 0))
      {
        print (STDERR "Unable to delete schedules_hash in database: " . $DBH->errstr . "\n");
        exit(1);
      }
    $sql = "delete from schedules";
    $rc = $DBH->do($sql);
    if ((!defined($rc)) || ($rc < 0))
      {
        print (STDERR "Unable to delete schedules in database: " . $DBH->errstr . "\n");
        exit(1);
      }
    $sql = "delete from programs";
    $rc = $DBH->do($sql);
    if ((!defined($rc)) || ($rc < 0))
      {
        print (STDERR "Unable to delete programs in database: " . $DBH->errstr . "\n");
        exit(1);
    }
    $sql = "delete from artwork";
    $rc = $DBH->do($sql);
    if ((!defined($rc)) || ($rc < 0))
      {
        print (STDERR "Unable to delete artwork in database: " . $DBH->errstr . "\n");
        exit(1);
      }
    $DBH->commit();

    return;
  }

#
# manageLineups
#
# NOTE: This should not be in this grabber, but there
# is no obvious alternative place to provide it....
#
# The username/passwordhash is obtained from the
# database if it exists (and can be opened) but
# the lineup can be managed without a database
#
#   Input:
#              <none>
#   Output:
#              <none>
#
sub manageLineups
  {
    my $username;
    my $passwordhash;

    if ((defined($conf->{'database'}->[0])) && (-f $conf->{'database'}->[0]))
      {
        DB_open_global($conf->{'database'}->[0]);
        $username = DB_settingsGet($DBH, 'username');
        $passwordhash = $passwordHash || DB_settingsGet($DBH, 'passwordhash');
      }

    # Try obtained username/password, but allow re-entry
    my $auth_prompted = 0;
    while(1)
      {
        if (!defined($username))
          {
            $username = ask("Enter your username at Schedules Direct:");
            $passwordhash = undef;
            $auth_prompted = 1;
          }

        if (!defined($passwordhash))
          {
            my $password = ask_password("Enter your password for $username at Schedules Direct:");
            $passwordhash = sha1_hex($password);
            $auth_prompted = 1;
          }

        last if (defined($SD->obtainToken($username, undef, $passwordhash)));

        print (STDERR "Unable to authenticate to Schedules Direct: " . $SD->ErrorString() . "\n");
        $username = undef;
        $passwordhash = undef;
        $auth_prompted = 1;
      }

    if (!defined($SD->obtainStatus()))
      {
        print (STDERR "Unable to obtain the service status at Schedules Direct: " . $SD->ErrorString() . "\n");
        exit(1);
      }

    if (!$SD->isOnline)
      {
        print (STDERR "The Schedules Direct service is not currently online,  Try again later.\n");
        exit(1);
      }

    my $prompt = '';
    my $choice = '';
    my @choices = ();

    while ($choice ne 'Exit')
      {
        my $lu = $SD->obtainLineups();
        if (!defined($lu))
          {
            print (STDERR "Fatal error obtaining lineups: " . $SD->ErrorString() . "\n");
            print (STDERR "Please re-run $SCRIPT_NAME --manage-lineups and/or $SCRIPT_NAME --configure\n");
            exit(1);
          }
        my $lineups = $lu->{'lineups'};
        if (!defined($lineups))
          {
            print (STDERR "Fatal error obtaining lineups\n");
            print (STDERR "Please re-run $SCRIPT_NAME --manage-lineups and/or $SCRIPT_NAME --configure\n");
            exit(1);
          }

        $prompt .= "\n";
        $prompt .= "Your Schedules Direct account has the following lineups configured:\n";
        $prompt .= "Lineup ID            Description\n";
        $prompt .= "======================================================================\n";
        for my $l (@{$lineups})
          {
            my $desc = '';
            if (defined($l->{'isDeleted'}) && $l->{'isDeleted'})
              {
                $desc = "DELETED LINEUP";
              }
            else
              {
                my $name = $l->{'name'} || 'None';
                my $transport = $l->{'transport'} || 'None';
                my $location = $l->{'location'} || 'None';
                $desc = "$name ($transport $location)";
              }
            $prompt .= sprintf("%-20s %s\n", $l->{'lineup'}, $desc);
          }

        $prompt .= "Specify a Schedules Direct account lineup management action";

        @choices = ( [ 'Exit',                  'Exit lineup management'] ,
                     [ 'Add',                   'Add an additional lineup to your account' ],
                     [ 'Delete',                'Delete an existing lineup from your account' ],
                     [ 'Display Password Hash', 'Display your password hash'],
                     [ 'Initialize Database'  , 'Initialize/update the local database'],
                     [ 'Channel Selection',     'Manage database lineup channel selection'],
                   );

        $choice = askChoice($prompt, undef, @choices);
        $choice = 'Exit' if (!defined($choice));

        $prompt = "\n";

        if ($choice eq 'Add')
          {

            my $guided = ask_boolean("\nDo you want to use guided lineup addition?",1);
            next if (!defined($guided));

            if (!$guided)
              {
                my $lineup_to_add = ask("\nEnter the Schedules Direct lineup to add: ");
                next if (!defined($lineup_to_add));

                $lineup_to_add =~ s/^\s+|\s+$//g;
                if ($lineup_to_add eq '')
                  {
                    $prompt .= "No lineup entered to add\n";
                    next;
                  }

                if ($SD->addLineup($lineup_to_add))
                  {
                    $prompt .= "Lineup $lineup_to_add added\n";
                  }
                else
                  {
                    $prompt .= "Lineup addition of $lineup_to_add failed: " . $SD->ErrorString() . "\n";
                  }
                next;
              }

            # Obtain the list of countries (by region)
            my $available = $SD->obtainAvailable('COUNTRIES');

            @choices = ();
            foreach my $reg (sort(keys(%{$available})))
              {
                push (@choices, ["$reg", "$reg"]);
              }

            my $region = askChoice("\nSelect the region for the new lineup (ctrl-D to skip)", undef, @choices);
            next if (!defined($region));

            my @choices = ();
            my $clist = $available->{$region};
            if (!defined($clist))
              {
                $prompt .= "Region $region is ill-formed\n";
                next;
              }
            if (scalar(@{$clist}) == 0)
              {
                $prompt .= "Region $region has no countries defined\n";
                next;
              }
            for (my $i = 0; $i < scalar(@{$clist}); $i++)
              {
                next if ((!defined(@{$clist}[$i]->{'shortName'})) || (!defined(@{$clist}[$i]->{'fullName'})));
                push (@choices, [$i, "@{$clist}[$i]->{'shortName'} - @{$clist}[$i]->{'fullName'}"]);
              }
            if (scalar(@choices) == 0)
              {
                $prompt .= "Region $region countries are improperly defined, no valid entries exist\n";
                next;
              }

            my $cindex = askChoice("\nSelect the country code for the new lineup (ctrl-D to skip)", undef, @choices);
            next if (!defined($cindex));

            # check if we can offer transmitter selection
            my $transmitters = $SD->obtainAvailable('DVB-T', '/' . @{$clist}[$cindex]->{'shortName'});
            if (defined($transmitters) && (ref($transmitters) eq 'HASH') && (scalar($transmitters) != 0))
              {
                my $selectXMTR = ask_boolean("\nDo you want to select by transmitter?",0);
                next if (!defined($selectXMTR));
                if ($selectXMTR)
                  {
                    my @choices = ();
                    my $aprompt = '';

                    foreach my $location(sort(keys(%{$transmitters})))
                      {
                        my $lineup = $transmitters->{$location};

                        if (scalar(@choices) < 10)
                          {
                            push (@choices, [ "$lineup", sprintf (" %-20s %s", $lineup, "$location") ]);
                          }
                        else
                          {
                            push (@choices, [ "$lineup", sprintf ("%-20s %s", $lineup, "$location") ]);
                          }
                      }

                    $aprompt  = "\n";
                    $aprompt .= "Select one of the following lineups to add to your Schedules Direct account (ctrl-D to skip)\n";
                    $aprompt .= "    Lineup ID            Description\n";
                    $aprompt .= "    ======================================================================\n";

                    my $lineup_to_add = askChoice($aprompt, undef, @choices);
                    next if (!defined($lineup_to_add));

                    if ($SD->addLineup($lineup_to_add))
                      {
                        $prompt .= "Lineup $lineup_to_add added\n";
                      }
                    else
                      {
                        $prompt .= "Lineup addition of $lineup_to_add failed: " . $SD->ErrorString() . "\n";
                      }

                    next;
                  }
              }

            my $country_code = @{$clist}[$cindex]->{'shortName'};
            my $postal_code_regex = @{$clist}[$cindex]->{'postalCode'};
            $postal_code_regex =~ s/^\/(.*)\/[a-z]*$/\^$1\$/;    # Adjust for perl
            my $postal_code_example = @{$clist}[$cindex]->{'postalCodeExample'};
            my $postal_code_required = 1;
            $postal_code_required = !(@{$clist}[$cindex]->{'onePostalCode'}) if (defined(@{$clist}[$cindex]->{'onePostalCode'}));

            my $postal_code = '';

            if ($postal_code_required)
              {
                my $pprompt = '';
                while ((defined($postal_code) && ($postal_code eq '')))
                  {
                    $pprompt .= "\nSpecify the postal code for the new lineup (ex: $postal_code_example) (ctrl-D to skip)";
                    $postal_code = ask($pprompt);
                    $pprompt = '';
                    if (defined($postal_code))
                      {
                        $postal_code =~ s/^\s+|\s+$//g;
                        # Check regex
                        if ("$postal_code" !~ m/$postal_code_regex/)
                          {
                            $pprompt .= "The specified postal code is not valid\n";
                            $postal_code = '';
                          }
                      }
                  }
                next if (!defined($postal_code));
              }
            else
              {
                $postal_code = $postal_code_example;
              }

            my $headends = $SD->obtainHeadends($country_code, $postal_code);
            if (!defined($headends))
              {
                print (STDERR "Fatal error obtaining headends: " . $SD->ErrorString() . "\n");
                print (STDERR "Please re-run $SCRIPT_NAME --manage-lineups and/or $SCRIPT_NAME --configure\n");
                exit(1);
              }

            if ((ref($headends) ne 'ARRAY') || (scalar(@{$headends})) == 0)
              {
                $prompt .= "Unable to add lineup, Schedules Direct has no lineups in $country_code/$postal_code\n";
              }
            else
              {
                my $location;
                my $transport;
                my @choices = ();
                my $aprompt = '';
                for (my $i = 0; $i < scalar(@{$headends}); $i++)
                  {
                    $transport = @{$headends}[$i]->{'transport'} || 'None';
                    $location = @{$headends}[$i]->{'location'} || 'None';
                    foreach my $lu (@{$headends}[$i]->{'lineups'})
                      {
                        for my $l (@{$lu})
                          {
                            my $lineup = $l->{'lineup'};
                            if (scalar(@choices) < 10)
                              {
                                push (@choices, [ "$lineup", sprintf (" %-20s %s", $lineup, "$l->{'name'} ($transport $location)") ]);
                              }
                            else
                              {
                                push (@choices, [ "$lineup", sprintf ("%-20s %s", $lineup, "$l->{'name'} ($transport $location)") ]);
                              }
                          }
                      }
                  }

                $aprompt  = "\n";
                $aprompt .= "Select one of the following lineups to add to your Schedules Direct account (ctrl-D to skip)\n";
                $aprompt .= "    Lineup ID            Description\n";
                $aprompt .= "    ======================================================================\n";

                my $lineup_to_add = askChoice($aprompt, undef, @choices);
                next if (!defined($lineup_to_add));

                if ($SD->addLineup($lineup_to_add))
                  {
                    $prompt .= "Lineup $lineup_to_add added\n";
                  }
                else
                  {
                    $prompt .= "Lineup addition of $lineup_to_add failed: " . $SD->ErrorString() . "\n";
                  }
              }
          }
        elsif ($choice eq 'Delete')
          {
            if (scalar(@{$lineups}) == 0)
              {
                $prompt .= "No lineups available to delete\n";
                next;
              }
            my @choices = ();
            for my $l (@{$lineups})
              {
                my $desc = '';
                if (defined($l->{'isDeleted'}) && $l->{'isDeleted'})
                  {
                    $desc = "DELETED LINEUP";
                  }
                else
                  {
                    my $name = $l->{'name'} || 'None';
                    my $transport = $l->{'transport'} || 'None';
                    my $location = $l->{'location'} || 'None';
                    $desc = "$name ($transport $location)";
                  }
                push (@choices, [ $l->{'lineup'}, sprintf("%-20s %s", $l->{'lineup'}, $desc) ]);;
              }

            my $lineup_to_delete = askChoice("\nLineup to delete (ctrl-D to skip)", undef, @choices);
            next if (!defined($lineup_to_delete));

            if ($SD->deleteLineup($lineup_to_delete))
              {
                $prompt .= "Lineup $lineup_to_delete deleted\n";
              }
            else
              {
                $prompt .= "Lineup deletion of $lineup_to_delete failed: " . $SD->ErrorString() . "\n";
              }
          }
        elsif ($choice eq 'Display Password Hash')
          {
            $prompt .= "Your password hash is: $passwordhash\n";
          }
        elsif ($choice eq 'Initialize Database')
          {
            if (!defined($DBH))
              {
                my $db = $conf->{'database'}->[0] || File::HomeDir->my_home . "/.xmltv/SchedulesDirect.DB";
                my $newdb = ask("\nEnter your database[$db]:");
                $db = $newdb if ($newdb ne '');
                DB_open_global($db);
                $prompt .= "Database initialized.\n";
              }

            DB_settingsSet($DBH, 'username', $username);

            my $storehash = ask_boolean(
                              "\n" .
                              "*WARNING* While your password is stored as a sha1 hash,\n" .
                              "(i.e. the actual password is not stored in the database)\n" .
                              "the sha1 hash can be used to update your schedules direct\n" .
                              "lineup information, and since the sha1 hash is unsalted,\n" .
                              "a poor password can easily be brute forced (or more likely\n" .
                              "found in an existing online rainbow table).  Ensure that\n" .
                              "your database is appropriately protected.  Note that it is\n" .
                              "STRONGLY recommended that your Schedules Direct password\n" .
                              "be a long random sequence of characters that is not shared\n" .
                              "with any other service.  If you choose not to store the\n" .
                              "passwordhash in the database, you will need to specify it\n" .
                              "at every invokation of the grabber.\n\n" .
                              "Confirm that you want to store the passwordhash in the database",
                              1);

            $storehash = 0 if (!defined($storehash));

            if ($storehash)
              {
                DB_settingsSet($DBH, 'passwordhash', $passwordhash);
                $prompt .= "Schedules Direct username/passwordhash stored in database";
              }
            else
              {
                DB_settingsSet($DBH, 'passwordhash', undef);
                $prompt .= "Schedules Direct Username stored in database";
              }
            $DBH->commit();
          }
        elsif ($choice eq 'Channel Selection')
          {
            if (!defined($DBH))
              {
                $prompt .= "Database has not been initialized (or cannot be opened)\n";
                next;
              }
            if (scalar(@{$lineups}) == 0)
              {
                $prompt .= "No lineups available to manage channels\n";
                next;
              }
            my $choice = '';
            my @choices = ();
            my $sql;
            my $sth;
            my $lineup;
            my $prompt = '';
            @choices = ();
            for my $l (@{$lineups})
              {
                my $name = $l->{'name'} || 'None';
                my $transport = $l->{'transport'} || 'None';
                my $location = $l->{'location'} || 'None';
                my $desc = "$name ($transport $location)";
                push (@choices, [ $l->{'lineup'}, sprintf("%-20s %s", $l->{'lineup'}, $desc) ]);;
              }

            $lineup = askChoice("\nLineup to manage channels (ctrl-D to skip)", undef, @choices);
            next if (!defined($lineup));

            SD_downloadLineupMaps($lineup);

            while ($choice ne 'Exit')
              {

                $prompt .= "\nSelect lineup channel action for lineup $lineup:";

                @choices = ( [ 'Exit',                  'Exit lineup channel management'] ,
                             [ 'MarkFuture',            'Set future new or updated lineup channels as selected' ],
                             [ 'ClearFuture',           'Set future new or updated lineup channels as unselected'],
                             [ 'MarkExisting',          'Set all existing lineup channels as selected'],
                             [ 'ClearExisting',         'Set all existing lineup channels as unselected'],
                             [ 'Select',                'Choose which channels are selected'],
                           );

                $choice = askChoice($prompt, undef, @choices);
                $choice = 'Exit' if (!defined($choice));

                $prompt = "\n";

                # Changing selected values needs to force downloads
                # (it may not always be necessary, but it is the
                # only way to make sure)
                $sql = "update lineups set downloaded = '1970-01-01 00:00:00', modified = '1970-01-01' where lineup = ?";
                $sth = $DBH->prepare_cached($sql);
                if (!defined($sth))
                  {
                    print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
                    exit(1);
                  }
                $sth->bind_param( 1, $lineup, SQL_VARCHAR );
                $sth->execute();
                if ($sth->err)
                  {
                    print (STDERR "Unexpected database error when executing statement ($sql): " . $sth->errstr . "\n");
                    $DBH->rollback();
                    exit(1);
                  }
                $DBH->commit();

                if ($choice eq 'MarkFuture')
                  {
                    $sql = "update lineups set new_channels_selected = 1 where lineup = ?";
                    $sth = $DBH->prepare_cached($sql);
                    if (!defined($sth))
                      {
                        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
                        exit(1);
                      }
                    $sth->bind_param( 1, $lineup, SQL_VARCHAR );
                    $sth->execute();
                    if ($sth->err)
                      {
                        print (STDERR "Unexpected database error when executing statement ($sql): " . $sth->errstr . "\n");
                        $DBH->rollback();
                        exit(1);
                      }
                    $DBH->commit();
                    $prompt .= "Future channels set as selected\n";
                  }
                elsif ($choice eq 'ClearFuture')
                  {
                    $sql = "update lineups set new_channels_selected = 0 where lineup = ?";
                    $sth = $DBH->prepare_cached($sql);
                    if (!defined($sth))
                      {
                        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
                        exit(1);
                      }
                    $sth->bind_param( 1, $lineup, SQL_VARCHAR );
                    $sth->execute();
                    if ($sth->err)
                      {
                        print (STDERR "Unexpected database error when executing statement ($sql): " . $sth->errstr . "\n");
                        $DBH->rollback();
                        exit(1);
                      }
                    $DBH->commit();
                    $prompt .= "Future channels set as not selected\n";
                  }
                elsif ($choice eq 'MarkExisting')
                  {
                    $sql = "update channels set selected = 1 where lineup = ?";
                    $sth = $DBH->prepare_cached($sql);
                    if (!defined($sth))
                      {
                        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
                        exit(1);
                      }
                    $sth->bind_param( 1, $lineup, SQL_VARCHAR );
                    $sth->execute();
                    if ($sth->err)
                      {
                        print (STDERR "Unexpected database error when executing statement ($sql): " . $sth->errstr . "\n");
                        $DBH->rollback();
                        exit(1);
                      }
                    $DBH->commit();
                    $prompt .= "Existing channels set as selected\n";
                  }
                elsif ($choice eq 'ClearExisting')
                  {
                    $sql = "update channels set selected = 0 where lineup = ?";
                    $sth = $DBH->prepare_cached($sql);
                    if (!defined($sth))
                      {
                        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
                        exit(1);
                      }
                    $sth->bind_param( 1, $lineup, SQL_VARCHAR );
                    $sth->execute();
                    if ($sth->err)
                      {
                        print (STDERR "Unexpected database error when executing statement ($sql): " . $sth->errstr . "\n");
                        $DBH->rollback();
                        exit(1);
                      }
                    $DBH->commit();
                    $prompt .= "Existing channels set as not selected\n";
                  }
                elsif ($choice eq 'Select')
                  {
                    #
                    # two by two, hands of blue
                    #
                    my $rowid = 0;
                    my $selected = 1;
                    my $station = '';
                    my $channum = '';
                    my $cdetails = '';
                    my $sdetails = '';
                    my $sql = "select channels.rowid, channels.station, channels.channum, channels.selected, channels.details, stations.details from channels as channels left join stations as stations on stations.station = channels.station where channels.lineup = ?";
                    my $sth = $DBH->prepare_cached($sql);
                    if (!defined($sth))
                      {
                        print (STDERR "Unexpected error when preparing statement ($sql): " . $DBH->errstr . "\n");
                        exit(1);
                      }
                    my $sqlupd = "update channels set selected = ? where rowid = ?";
                    my $sthupd = $DBH->prepare_cached($sqlupd);
                    if (!defined($sthupd))
                      {
                        print (STDERR "Unexpected error when preparing statement ($sqlupd): " . $DBH->errstr . "\n");
                        exit(1);
                      }

                    $sth->bind_param( 1, $lineup, SQL_VARCHAR );
                    $sth->execute();
                    if ($sth->err)
                      {
                        print (STDERR "Unexpected database error when executing statement ($sql): " . $sth->errstr . "\n");
                        $DBH->rollback();
                        exit(1);
                      }
                    $sth->bind_col( 1, \$rowid, SQL_INTEGER );
                    $sth->bind_col( 2, \$station, SQL_VARCHAR );
                    $sth->bind_col( 3, \$channum, SQL_VARCHAR );
                    $sth->bind_col( 4, \$selected, SQL_INTEGER );
                    $sth->bind_col( 5, \$cdetails, SQL_VARCHAR );
                    $sth->bind_col( 6, \$sdetails, SQL_VARCHAR );
                    while($sth->fetch())
                      {
                        my $c = $JSON->decode($cdetails);
                        my $s = {};
                        $s = $JSON->decode($sdetails) if (defined($sdetails));
                        my $name;
                        $name = $s->{'name'} if (defined($s->{'name'}));
                        my $callsign;
                        $callsign = $s->{'callsign'} if (defined($s->{'callsign'}));
                        my $i = '';
                        $i .= "$channum " if ($channum ne '');
                        $i .= "$name " if (defined($name));
                        $i .= "$callsign " if (defined($callsign));
                        if ($i eq '')
                          {
                            $i = 'Unknown';
                          }
                        my $ans = ask_boolean($i, $selected);
                        $ans = $selected if (!defined($ans));
                        $sthupd->bind_param( 1, $ans, SQL_INTEGER );
                        $sthupd->bind_param( 2, $rowid, SQL_VARCHAR );
                        $sthupd->execute();
                        if ($sthupd->err)
                          {
                            print (STDERR "Unexpected database error when executing statement ($sqlupd): " . $sth->errstr . "\n");
                            $DBH->rollback();
                            exit(1);
                          }
                        $DBH->commit();
                      }
                  }
              }
          }
      }
    return;
  }

#
# generateRFC2838
#
# Per the XMLTV definition, the station must be
# in RFC2838 format, even though there are no
# (realistic) tables that provide any consistent
# or reliable mappings (for at least NA stations).
# So, we meet the definition by making up a
# compliant name.
#
#   Input:
#              name        - the station name
#   Output:
#              RFC2838     - rfc2838 station name
#
sub generateRFC2838
  {
    my ($station, undef) = @_;
    if ($RFC2838_COMPLIANT)
      {
        return (sprintf("I%s.json.schedulesdirect.org", $station));
      }
    else
      {
        return ($station);
      }
  }

#
# generateXMLTV_NS
#
# Per the XMLTV definition, the xmltv_ns string has
# two parts, the number (zero origin) and the total
# separated by a '/' if the total exists. This routine
# provides the formatting conversion.
#
#   Input:
#              number      - the base number
#              total       - the total
#   Output:
#              xmltv_ns    - the string representing the number/total
#
sub generateXMLTV_NS
  {
    my ($number, $total, undef) = @_;
    return '' if (!defined($number));
    if ($number =~ /^\d+$/)
      {
        $number = $number - 1;
        if ($number >= 0)
          {
            return "$number" if (!defined($total));
            if ($total =~ /^\d+$/)
              {
                $total = $total + 0;
                if ($total > 0)
                  {
                    return "$number / $total";
                  }
              }
            return "$number";
          }
      }
    return '';
  }

#
# addRole
#
# Add a role to the roles hash, eliminating duplicates
# and treating an empty character as incomplete if
# other (better?) character entries are provided later.
# Note that (unfortunately), we have no way of knowing
# which "character" is better if we get more than one
# (and the same actor could be playing multiple roles),
# so we just return them all.
#
#   Input:
#              roles       - existing $roles array
#              role        - role to add
#              person      - person to add to role
#              order       - billing order
#              character   - character being played
#   Output:
#              none        - $roles array updated
#
sub addRole
  {
    my ($roles, $role, $person, $order, $character, undef) = @_;
    return if (!defined($role));
    return if (!defined($person));
    return if (!defined($order));
    return if ($order !~ /^\d+$/);
    my $ra = $roles->{$role};
    return if (!defined($ra));
    $character = '' if (!defined($character));
    if ($character eq '')
      {
        if (!defined($ra->{$person}))          # Only add person if we do not have them
          {
            $ra->{$person}->{'order'} = 0 + $order;
            $ra->{$person}->{'character'} = [];
          }
      }
    else
      {
        if (!defined($ra->{$person}))          # Only add person order if we do not have them
          {
            $ra->{$person}->{'order'} = 0 + $order;
          }
        foreach my $c(@{$ra->{$person}->{'character'}})    # Do not duplicate characters
          {
            return if ($c eq $character);
          }
        push(@{$ra->{$person}->{'character'}}, $character);
      }
    return;
  }

#
# mapTransport
#
# The XMLTV definition specifies the allowed transport
# types.  Schedules Direct has slightly different
# transport types.  Map the Schedules Direct type to
# an XMLTV type.
#
#   Input:
#              SDtype      - Schedules Direct transport type
#   Ouput:
#              XMLTVtype   - XMLTV transport type
#
sub mapTransport
  {
    my ($transport, undef) = @_;

    return 'Unknown' if (!defined($transport));

    state $transportTypeMap =              # Map for Schedules Direct transport to XMLTV type
      {
        'DVB-C'          => 'DTV',         # DVB-C
        'DVB-T'          => 'DTV',         # DVB-T
        'DVB-S'          => 'DTV',         # DVB-S (should be STB?)
        'Cable'          => 'STB',         # Cable (most use a STB?)
        'Antenna'        => 'DTV',         # Antenna (US ATSC and/or analog)
        'Satellite'      => 'STB',         # Satellite (most use a STB?)
        'IPTV'           => 'STB'          # Schedules Direct IPTV is STB-like
      };

    if (defined($transportTypeMap->{$transport}))
      {
        return($transportTypeMap->{$transport});
      }

    return 'Unknown';
  }

#
# mapRatingAgency
#
# Map the Schedules Direct rating agency to the expected
# (short) name for MythTV.
#
#   Input:
#              body        - rating Body
#              rating      - rating
#   Output:
#              body        - rating Body (abbrev)
#              rating      - rating (adjusted for VCHIP)

sub mapRatingAgency
  {
    my ($body, $rating, undef) = @_;

    my $mappedBody = $body;
    my $mappedRating = $rating;

    # Maps partially derived from wikipedia and the wiki page located at
    # http://www.filmo.gs/wiki/Identifying-Film-Classification-Symbols,
    # based on the Schedules Direct rating agency names from sample data.
    # There are likely many missing country agencies.  Updates welcome.

    state $bodyMap =
      {
        'Australian Classification Board'                                                  => 'CB',
        'British Board of Film Classification'                                             => 'BBFC',
        'USA Parental Rating'                                                              => 'VCHIP',
        'Motion Picture Association of America'                                            => 'MPAA',
        'Freiwillige Selbstkontrolle der Filmwirtschaft'                                   => 'FSK',
        'Film & Publication Board'                                                         => 'FPB',
        'Manitoba Film Classification Board'                                               => 'MFCB',
        'B.C. Film Classification Office'                                                  => 'BCFCO',
        'Saskatchewan Film and Video Classification Board'                                 => 'SFVCB',
        'Medietilsynet'                                                                    => 'NMA',
        'Departamento de Justiça, Classificação, Títulos e Qualificação'                   => 'ClassInd',
        'Alberta\'s Film Classification Board'                                             => 'AFR',
        'The Régie du cinéma'                                                              => 'RCQ',
        'Ontario Film Review Board'                                                        => 'OFRB',
        'Maritime Film Classification Board'                                               => 'MFC',
        'Canadian Parental Rating'                                                         => 'CHVRS',
        'Conseil Supérieur de l\'Audiovisuel'                                              => 'CSA',
        'Dirección General de Radio, Televisión y Cinematografía'                          => 'RTC',
        'Instituto de Cinematografía y de las Artes Visuales'                              => 'ICAA',
        'Mediakasvatus- ja kuvaohjelmayksikkö'                                             => 'MEKU',
        'UK Content Provider'                                                              => 'UK',
        'Centre national du cinéma et de l\'image animée'                                  => 'CNC',
        'Irish Film Classification Office'                                                 => 'IFCO',    # Guess
        'Statens filmgranskningsbyrå'                                                      => 'VET',     # Guess
        'Nemzeti Média- és Hirközlési Hatóság'                                             => 'NMHH',    # Guess
        'Nederlands Instituut voor de Classificatie van Audiovisuele Media'                => 'NICAM',   # Guess
        'Office of Film and Literature Classification'                                     => 'OFLC',    # Guess
        'Board of Film Censors'                                                            => 'BFC',     # Guess
        'Korea Media Rating Board'                                                         => 'KMRB'     # Guess
      };

    if (defined($bodyMap->{$body}))
      {
        $mappedBody = $bodyMap->{$body};
      }

    #
    # Special hack for the VCHIP rating, as currently the
    # Schedules Direct rating does not include the '-'
    #
    if ($mappedBody eq 'VCHIP')
      {
        # Currently, the USA Parental Rating does not include the '-'?
        if (substr($mappedRating,2,1) ne '-')
          {
            $mappedRating = (substr($mappedRating,0,2) . '-' . substr($mappedRating, 2));
          }
      }

    return ($mappedBody, $mappedRating);
  }

#
# mapUSATSCChannelToFrequency
#
# Map the US FCC channel number to a transmission
# frequency
#
#   Input:
#              channel     - the FCC channel
#   Output:
#              frequency   - frequency in HZ
#
sub mapUSATSCChannelToFrequency
  {
    my ($channel, undef) = @_;

    $channel =~ s/^\s+|\s+$//g;                # Remove any leading/trailing spaces

    if ($channel =~ m/^\d+$/)
      {
        $channel = 0 + $channel;
      }

    my $frequency;

    state $USATSCFrequenciesMap =              # US ATSC frequencies
      {
         2 =>   57000000,
         3 =>   63000000,
         4 =>   69000000,
         5 =>   79000000,
         6 =>   85000000,
         7 =>  177000000,
         8 =>  183000000,
         9 =>  189000000,
        10 =>  195000000,
        11 =>  201000000,
        12 =>  207000000,
        13 =>  213000000,
        14 =>  473000000,
        15 =>  479000000,
        16 =>  485000000,
        17 =>  491000000,
        18 =>  497000000,
        19 =>  503000000,
        20 =>  509000000,
        21 =>  515000000,
        22 =>  521000000,
        23 =>  527000000,
        24 =>  533000000,
        25 =>  539000000,
        26 =>  545000000,
        27 =>  551000000,
        28 =>  557000000,
        29 =>  563000000,
        30 =>  569000000,
        31 =>  575000000,
        32 =>  581000000,
        33 =>  587000000,
        34 =>  593000000,
        35 =>  599000000,
        36 =>  605000000,
        37 =>  611000000,
        38 =>  617000000,
        39 =>  623000000,
        40 =>  629000000,
        41 =>  635000000,
        42 =>  641000000,
        43 =>  647000000,
        44 =>  653000000,
        45 =>  659000000,
        46 =>  665000000,
        47 =>  671000000,
        48 =>  677000000,
        49 =>  683000000,
        50 =>  689000000,
        51 =>  695000000
      };

    $frequency = $USATSCFrequenciesMap->{$channel} || '0';

    return $frequency;
  }

#
# A little info
#
=pod

=head1 NAME

tv_grab_az_sdjson_sqlite - Grab TV and radio program listings from Schedules Direct (subscription required).

=head1 SYNOPSIS

tv_grab_az_sdjson_sqlite --help

tv_grab_az_sdjson_sqlite --info

tv_grab_az_sdjson_sqlite --version

tv_grab_az_sdjson_sqlite --capabilities

tv_grab_az_sdjson_sqlite --description

tv_grab_az_sdjson_sqlite --manage-lineups [--config-file FILE]
              [--quiet] [--debug] [--passwordhash HASH]

tv_grab_az_sdjson_sqlite [--days N] [--offset N] [--config-file FILE]
              [--output FILE] [--quiet] [--debug]
              [--passwordhash HASH]

tv_grab_az_sdjson_sqlite --configure [--config-file FILE]
              [--quiet] [--debug]
              [--passwordhash HASH]

tv_grab_az_sdjson_sqlite --list-channels [--config-file FILE]
              [--output FILE] [--quiet] [--debug]
              [--passwordhash HASH]

tv_grab_az_sdjson_sqlite --list-lineups  [--config-file FILE]
              [--output FILE] [--quiet] [--debug]
              [--passwordhash HASH]

tv_grab_az_sdjson_sqlite --get-lineup [--config-file FILE]
              [--output FILE] [--quiet] [--debug]
              [--passwordhash HASH]

=head1 DESCRIPTION

Output TV listings in XMLTV format for many locations available in
North America (US/CA) and other selected countries internationally.
The data comes from L<http://www.schedulesdirect.org> and an account
must be created on the Schedules Direct site in order to grab data.
Refer to the Schedules Direct site for signup requirements and
supported locations.

This grabber uses a shared local database which allows for
downloading only new/changed/updated information, and in
the case of mixed OTA, Cable, and/or Satellite providers can
substantially reduce the download times (as some data such
as schedules and program details are commonly shared between
sources in the same location).

First, you must run B<tv_grab_az_sdjson_sqlite --manage-lineups>
to manage the lineups available to your grabber configuration
at the Schedules Direct service.

Second, you must run B<tv_grab_az_sdjson_sqlite --configure> to
choose which lineup this configuration will grab (this grabber
will share the downloaded information for multiple lineups,
and can substantially reduce the royal overheads in those
cases).

=head1 OPTIONS

B<--manage-lineups> Perform Schedules Direct lineup management
functions (adding/deleting lineups from your account, and
creating the local EPG database).  Managing lineups can be
performed without a configuration file (it will prompt for
the needed information) but if it exists, it will be used
to obtain initial credentials.  If you change your password
at Schedules Direct, you will need to update the database
(or display the new password hash) using --manage-lineups.

B<--configure> Prompt for which lineup to download and write the
configuration file.  Note that one must run --manage-lineups
first to create and initialize the database and configure lineups.

B<--config-file FILE> Set the name of the configuration file, the
default is B<~/.xmltv/tv_grab_az_sdjson_sqlite.conf>.  This is
the file written by B<--configure> and read when grabbing.

B<--output FILE> When grabbing, write output to FILE rather than
standard output.

B<--download-only> Perform a download of the data only (no output).

B<--no-download> Do not download data, but use the existing contents
of the local database.  Since the code optimizes the data downloaded,
this is nominally useful only in offline situations.

B<--force-download> Deletes most existing local database data and
forces a download of the data.  If there is a suspicion that the
data is currupt (and not being automatically corrected), forcing
a new download might be necessary.

B<--days N> When grabbing, grab N days rather than all available days.

B<--offset N> Start grabbing at today/now + N days.

B<--quiet> Suppress various informational messages shown on standard error.

B<--debug> Provide more information on progress to stderr to help in
debugging.  This can get very verbose, but too much data is better
that not enough if errors need to be squashed.  Note that the
debug data may contain information you might prefer to be confidential
such as your password hash, so treat the output appropriately.

B<--passwordhash HASH> Provide the password hash on the command line.
This is necessary if the hash is not stored in the database.

B<--list-channels> Write output giving <channel> elements for every
channel available in the current configuration.

B<--list-lineups> Write output giving list of available viewing regions.
Note that list-lineups is not fully standardized, so the output is
subject to change.

B<--get-lineup> Write output giving <channel> elements for every
channel available in the current lineup.  Note that get-lineup is
not fully standardized, so the output is subject to change.

B<--capabilities> Show which capabilities the grabber supports. For more
information, see L<http://wiki.xmltv.org/index.php/XmltvCapabilities>

B<--version> Show the version of the grabber.

B<--help> Print a help message and exit.

B<--info> Print a help page and exit.

=head1 INSTALLATION

1.
First you must signup for an account at Schedules Direct.
This is a paid service providing EPG data for North America
and other selected countries.  See L<http://www.schedulesdirect.org>
for signup requirements, and the countries served.

2.
Second you need to configure the lineups that you will have
access to using your account with this grabber.  Run
B<tv_grab_az_sdjson_sqlite --manage-lineups> to add your lineups and
to initialize the database.

3.
Third, you will need to configure this specific instance of
the grabber to select the lineup to use.  Run
B<tv_grab_az_sdjson_sqlite --configure>.

4.
(Optionally) run B<tv_grab_az_sdjson_sqlite --download-only> to download
and "fill" the local database copies of your data.  In future
runs, only updated information will be downloaded, and the
local database will be pruned to delete old/obsolete information.

=head1 USAGE

All the normal XMLTV capabilities are included.

Note that Schedules Direct only has data for a maximum of about 21 days,
(although may be less for some channels) but the accuracy of the data
at the end of the period tends to be poor.

=head1 ERROR HANDLING

If the grabber encounters a fatal error, it will write a message to
STDERR and exit(1).  Some errors are retriable, and the code performs
retries.

=head1 ENVIRONMENT VARIABLES

The environment variable HOME can be set to change where configuration
files are stored. All configuration is stored in $HOME/.xmltv/. On Windows,
it might be necessary to set HOME to a path without spaces in it.

The environment variable TV_GRAB_TARGET_APPLICATION_FIXUPS can be
set to indicate that the grabber should apply fixups for applications
that are not fully XMLTV compliant, or that are currently missing some
specific functionality.  The fixups can be combined by separating
them with colons.  Available fixups are NO_XMLTV_NS_TOTAL_SEASONS
(do not include the total seasons in the generated xmltv_ns episode
numbering), NO_PREVIOUSLY_SHOWN_ZONE_OFFSET (do not include the
zone offset in previously-shown), and NO_STATION_LOGOS (do not include
station logos in the output).  The fixups are intended to be temporary
until the application(s) can be updated.

=head1 SUPPORTED CHANNELS

Schedules Direct lineups should support all the channels from
your provider or OTA antenna.  If there are missing channels,
or incorrect guide data, you should contact Schedules Direct
to request updates.

=head1 XMLTV VALIDATION

B<tv_validate_grabber> may report an error similar to:

      "Line 123 Duplicate channel-tag for 'I12345.json.schedulesdirect.org'"

This is a because at least some providers (typically Cable/Satellite,
but sometimes OTA repeaters that you may have in your lineup) actually
have the exact same station available on multiple channels.  XMLTV
does not like seeing the same station reported twice, even though the
full display-name info does show that the channel number is different.

This error can (should/must?) be ignored.

=head1 XMLTV STATIONS vs CHANNELS

XMLTV (despite a couple of proposals to update the specifications)
has a legacy confusion regarding the differences between a "station",
which is a supplier of content (programs) and schedules, and a
"channel" which is method of delivery/transport.  XMLTV uses the
term <channel> where they likely should be using the term <station>,
because they deal with programming, not transport.  Regardless,
such a transition would be understandably be a challenge, and
the lineup proposals to extend the capability to provide a
mechanism to support "channels" has not progressed in years.

This also results in a failing of the configuration capability
which treats the selecting of content as being station based,
which is not always the same thing as a <channel> (for example,
for Cable providers, a "station" may be transmitted on many
"channels" (perhaps in different resolutions), but an individual
may only be authorized to receive some of the "channels").  One
may want the "station" schedules and programs, but not to see
the "channel" returned because they cannot tune it.

=head1 CHANNEL SELECTION

Due to the XMLTV interpretations of <channel>, this grabber
implements its own "channel" (transport) selection mechanism
(which parallels that on the Schedules Direct site).  It
is implemented within the --manage-lineups capability.  The
grabber defaults will result in all channels and stations
associated with the lineup being written.  In some cases
it may be desired by some to limit the channels to a small
subset of all available channels (the most common being a
Cable or Satellite service which has billions and billions
of channels, but you are subscribed to a significantly
reduced programming tier, and your application does not
have the ability to restrict the display/access to that
large number of channels).  There is just enough flexibility
to allow one to confuse oneself some of the time.  Note that
while an effort is made to maintain the existing selection
value when the lineup mapping (channels and stations) are
updated, new or changed station assignments per channel will
result in the lineup defaults being assigned to the new or
updated channel.  The lineup channel selection default can
also be set for an existing lineup.  Due to the potential
of future surprises or confusion, if one can avoid using
the channel selection capability one is likely better off.

=head1 FAQs

No FAQs yet....

=head1 DISCLAIMER

The Schedules Direct service requires a subscription, and only allows
for usage for personal use with approved open source projects.  Refer
to the Schedules Direct site for their requirements and how to sign
up.

=head1 AUTHOR

Gary Buhrmaster.  As with most tv_grabbers, documentation,
ideas, and parts of the code may have been leveraged from
other existing grabbers from the XMLTV-project.  We stand
on the shoulders of those that came before us.

=head1 COPYRIGHT

Copyright (c) 2016, 2017 Gary Buhrmaster <gary.buhrmaster@gmail.com>

This code is distributed under the GNU General Public License v2 (GPLv2)

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
version 2 as published by the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

=head1 SEE ALSO

L<xmltv(5)>.


=cut


########################################################################

# The XML::Writer is very heavy-weight and slow.
# So we implement a very lightweight version that only
# writes to internal string and contains a subset of
# functions.
package LightXMLWriter;

sub new {
    my ($class, %args) = @_;
    my $self = {};
    $self->{str} = '';
    return bless $self, $class
}

sub to_string {
    my ($self) = @_;
    return $self->{str};
}

sub raw {
    my ($self, $str) = @_;
    $self->{str} .= $str;
    return $self;
}

sub _escape_string {
    my ($str) = @_;
    if ($str =~ /[&<>"]/) {
        $str =~ s/&/\&amp;/g;
        $str =~ s/</\&lt;/g;
        $str =~ s/>/\&gt;/g;
        $str =~ s/"/\&quot;/g;
    }
    return $str;
}

sub comment {
    my ($self, $str) = @_;
    $self->{str} .= "<comment>" . _escape_string($str) . "</comment>";
    return $self;
}

sub startTag {
    my ($self, $tag, %tags) = @_;
    $self->{str} .= "<$tag";
    $self->_add_attribs(%tags);
    $self->{str} .= '>';
    return $self;
}

sub endTag {
    my ($self, $tag) = @_;
    $self->{str} .= "</$tag>\n";
    return $self;
}

sub _add_attribs {
    my ($self, %tags) = @_;
    for my $attr (sort keys %tags) {
        my $value = _escape_string($tags{$attr});
        $self->{str} .= qq/ $attr = "$value"/;
    }
    return $self;
}


sub emptyTag {
    my ($self, $tag, %tags) = @_;
    $self->{str} .= "<$tag";
    $self->_add_attribs(%tags);
    $self->{str} .= " />\n";
    return $self;
}

sub characters {
    my ($self, $data) = @_;
    $self->{str} .= _escape_string($data);
    return $self;
}

sub dataElement {
    my ($self, $tag, $data, %tags) =@_;
    $self->startTag($tag, %tags)->characters($data)->endTag($tag);
    return $self;
}

sub end {}

package TVHIMDB;
use File::Spec::Functions qw(catdir);

sub new {
    my ($class, %args) = @_;
    my $self = {};
    my $dbi = $args{dbi};
    my $user = $args{user};
    my $pass = $args{pass};
    # Connect or print error and die.
    $self->{db} = DBI->connect($dbi, $user, $pass,
                               {
                                AutoCommit => 0, RaiseError => 1, PrintError => 1}
                              );

    my @table = (
             {
              table => "imdb_title",
              file => "title.basics",
              columns => "tconst,titleType,primaryTitle,originalTitle,isAdult,startYear,endYear,runtimeMinutes,genres",
              calc_pt_crc => 1,
             },
             {
              table => "imdb_episode",
              file => "title.episode",
              columns => "tconst,parentTconst,seasonNumber,episodeNumber",
             },
             {
              table => "imdb_ratings",
              file => "title.ratings",
              columns => "tconst,averageRating,numVotes",
              mode => "replace",
             }
                );
    $self->{entry} = \@table;
    bless $self, $class;
    $self->_update_schema();
    return $self;
}

sub _update_schema {
    my ($self) = @_;
    my $db = $self->{db};

    my $charset = "CHARACTER SET latin1 COLLATE latin1_bin";
    $db->do("create table if not exists imdb_settings (tag varchar(100) $charset primary key not null, value text $charset)");
    my $version = $db->selectrow_array("select value from imdb_settings where tag='version'");
    if (!$version) {
        my @sql = (
                   # Need runtimeMinutes as an int since one show says it is 125156 minutes long.
                   "create table if not exists imdb_title(tconst varchar(12) $charset primary key not null, titleType text, primaryTitle text NOT NULL, originalTitle text, isAdult boolean, startYear smallint unsigned, endYear smallint unsigned, runtimeMinutes mediumint unsigned, genres text, pt_crc int unsigned, downloaded datetime default CURRENT_TIMESTAMP COLLATE utf8_general_ci)",
                   "create index idx_i_c_y on imdb_title(pt_crc, startYear)", # Average length of title is 19; max 408, so pt_crc should be faster match
                   "create table if not exists imdb_episode(tconst varchar(12) $charset not null, parentTconst varchar(12) $charset not null, seasonNumber tinyint unsigned, episodeNumber mediumint unsigned, downloaded datetime default CURRENT_TIMESTAMP, CONSTRAINT pk_i_e PRIMARY KEY (tconst, parentTconst), FOREIGN KEY(tconst) REFERENCES imdb_title(tconst) ON DELETE CASCADE, FOREIGN KEY(parentTconst) REFERENCES imdb_title(tconst) ON DELETE CASCADE)",
                   "create unique index idx_i_e on imdb_episode(episodeNumber,seasonNumber,tconst)",

                   "create table if not exists imdb_ratings (tconst varchar(12) $charset primary key not null, averageRating numeric, numVotes integer,  parentTconst varchar(12) $charset, downloaded datetime default CURRENT_TIMESTAMP, FOREIGN KEY(tconst) REFERENCES imdb_title(tconst) ON DELETE CASCADE)",

                  );
        for (@sql) {
            my $rc = $db->do($_);
        }

        $db->do("replace into imdb_settings(tag,value) values('version', 1)");
        $db->commit();
    }
    $db->commit();
}

sub _find_id {
    my ($self, $stmt, @args) = @_;
    $stmt->execute(@args);
    my @ret = $stmt->fetchrow_array;
    $stmt->finish;
    return wantarray? @ret : $ret[0];
}

sub _find_rating_by_tconst {
    my ($self, $tconst, $parentTconst) = @_;
    my $rating;
    if ($tconst) {
        state $stmt = $self->{db}->prepare_cached("select averageRating from imdb_ratings where tconst=?");
        $stmt->execute($tconst);
        $rating = $stmt->fetchrow_array;
        $stmt->finish;
    }
    # Some episode (such as future episodes) have no rating, so search for the rating on the series.
    if (!$rating && $parentTconst) {
        state $stmt = $self->{db}->prepare_cached("select averageRating from imdb_ratings where tconst=?");
        $stmt->execute($parentTconst);
        $rating = $stmt->fetchrow_array;
        $stmt->finish;
    }
    return wantarray ? ($rating, $tconst, $parentTconst) : $rating;
}

sub find_details_for_episode {
    my ($self, $title, $subtitle, $year, $season, $episode, $sup_year) = @_;

    if (!$subtitle && !$season && !$episode && $year) {
        return $self->find_details_for_show($title, $year);
    }

    my ($tconst, $parentTconst);
    if ($title && $subtitle) {
        # We don't check season/episode since exact match of title/subtitle is usually good enough.
        # and E.seasonNumber=? and E.episodeNumber=?
        state $stmt = $self->{db}->prepare_cached("select TE.tconst,TE.parentTconst from imdb_title S, imdb_title E, imdb_episode TE where S.primaryTitle=? and E.primaryTitle=? and TE.parentTconst = S.tconst and TE.tconst = E.tconst and E.startYear=? and S.pt_crc=crc32(?) and E.pt_crc=crc32(?)");
        ($tconst, $parentTconst) = $self->_find_id($stmt, $title, $subtitle, $year, $title, $subtitle);
        # Could not find id for episode based on subtitle.

        if (!$tconst && $season && $episode) {
            # It's unusual for IMDB to not have details of a series. So we assume sub-title is incorrect.
            # E.g., S11E13 of CSI has "Mrs" on SD and "Mrs." on IMDB. So search by season/episode.
            # The only reason we don't always search by season/episode first is that sometimes
            # different sources have different orderings for season/episode, but episode names
            # tend to be consistent nowadays; however if above matches fail then it seems
            # sensible to do a fallback. We use soundex to ensure that the subtitles
            # "sound" similar, which means in the above example they would have the
            # same value.
            #
            # We currently don't do soundex on series name since modern series are standardized,
            # but old series such as "Quincy" can be "Quincy, M.E." (SD) vs "Quincy M.E." (imdb)
            # and this isn't fixed in the "akas" table.
            #
            # Try by season/episode and approx match of subtitle.
            state $stmt = $self->{db}->prepare_cached("select TE.tconst,TE.parentTconst from imdb_title S, imdb_title E, imdb_episode TE  where S.primaryTitle=? and TE.seasonNumber=? and TE.episodeNumber=? and TE.parentTconst = S.tconst and TE.tconst=E.tconst and soundex(E.primaryTitle) = soundex(?) and E.startYear=? and S.pt_crc=crc32(?)");
            ($tconst, $parentTconst) = $self->_find_id($stmt, $title, $subtitle, $season, $episode, $year, $title);
        }
    }

    if ($tconst) {
        return $self->_find_rating_by_tconst($tconst, $parentTconst);
    } else {
        return;
    }
}

sub find_details_for_show {
    my ($self, $title, $year) = @_;
    return unless $title && $year;
    # Currently ignore "originalTitle=$title"

    state $stmt = $self->{db}->prepare_cached("select tconst from imdb_title where pt_crc=crc32(?) and primaryTitle=? and startYear=? and titleType like 'tv%'");
    my $tconst = $self->_find_id($stmt, $title, $title, $year);
    my $rating = $self->_find_rating_by_tconst($tconst);
    # undef for imdbid since we are a generic show (series).
    return ($rating, undef, $tconst);
}

sub find_details_for_movie {
    my ($self, $title, $year) = @_;
    return unless $title && $year;

    my $stmt = $self->{db}->prepare_cached("select tconst from imdb_title where pt_crc=crc32(?) and primaryTitle=? and startYear=? and titleType in('movie', 'tvmovie', 'tvShort')");
    my $tconst = $self->_find_id($stmt, $title, $title, $year);

    return $self->_find_rating_by_tconst($tconst);
}

sub _import_file {
    my ($self, $entry, $path) = @_;
    my @s = stat $path or return;
    my $mtime = $s[9];
    my $table = $entry->{table};
    my $tag = "import_$table";
    my $db = $self->{db};
    my $last_import = $db->selectrow_array("select value from imdb_settings where tag='$tag'");
    # Previously imported?
    return if $last_import && $last_import == $mtime;
    print STDERR "Import $path in to table $table\n" unless $quiet;
    my $ignore = $entry->{mode} // 'ignore';
    my $columns = $entry->{columns};
    # crc32 is good enough since it is much faster to calculate than
    # md5/sha1 and we always need to string compare against
    # primaryTitle anyway.
    my $extra = ($entry->{calc_pt_crc}) ? ",pt_crc=crc32(primaryTitle)" : "";
    $db->do("load data infile ? $ignore into table $table ignore 1 lines ($columns) set downloaded = current_timestamp$extra", {}, $path);
    $db->do("replace into imdb_settings(tag, value) values(?,?)", {}, $tag, $mtime);
    $db->commit();
    print STDERR "Finished import $path in to table $table\n" unless $quiet;
}
sub import {
    my ($self, $dir) = @_;
    return unless $dir;
    my $entries = $self->{entry};
    for my $entry (@$entries) {
        my $file = $entry->{file};
        my $path = catdir($dir, "$file.tsv");
        $self->_import_file($entry, $path);
    }
}

sub _download_file_needed {
    my ($self, $path, $dl) = @_;

    if (my @s = stat $path) {
        # Output file already exists. Check timestamp against user's
        # download criteria.
        my $mtime = $s[9];
        my $now = time();
        my $tdiff = $now - $mtime;
        return if ($dl =~ /^day|^daily/  && $tdiff < 60 * 60 * 24);
        return if ($dl =~ /^week/        && $tdiff < 60 * 60 * 24 * 7);
        return if ($dl =~ /^month/       && $tdiff < 60 * 60 * 24 * 7 * 30);
        return if ($dl =~ /^quarter/     && $tdiff < 60 * 60 * 24 * 7 * 30 * 3);
        return if ($dl =~ /^half/        && $tdiff < 60 * 60 * 24 * 7 * 30 * 6);
        return if ($dl =~ /^year/        && $tdiff < 60 * 60 * 24 * 7 * 365);
    }
    return 1;
}

sub _download_file {
    use autodie;
    my ($self, $entry, $dir, $dl) = @_;
    my $file = $entry->{file};
    my $path = catdir($dir, "$file.tsv");
    if (!$self->_download_file_needed($path, $dl)) {
        print STDERR "not downloading imdb file $file (data current)\n" unless $quiet;
        return;
    }

    my $base_url = "https://datasets.imdbws.com/";
    my $url = "$base_url$file.tsv.gz";
    my $dl_file = "$path.gz";
    my $output_tmp_file = "$path.tmp";

    use IPC::Run3;
    # We use wget instead of internal LWP purely because the files are
    # huge and it is useful to have progress information that wget
    # outputs.
    #
    # We deliberately fetch in to the same secure directory (not TMPDIR)
    # since modern distributions make TMPDIR small.
    #
    # We also manually retry since we sometimes get "unable to resolve
    # host address" errors, and the "--tries" option on wget doesn't
    # retry for these.
    my $tries = 0;
    while (++$tries) {
        print STDERR "Downloading imdb file for $file from $url in to $output_tmp_file\n" unless $quiet;
        my @wget = ("wget", "--output-document", "$output_tmp_file", $url);
        run3 \@wget, \undef;
        if ($? || !-s $output_tmp_file) {
            print STDERR" Failed to download from $url in to $output_tmp_file, exit status $?\n";
            unlink $output_tmp_file if -e $output_tmp_file;
            return if $tries > 3;
            print STDERR "Will retry download after a short pause..." unless $quiet;
            sleep 1;
        } else {
            last;
        }
    }

    # Now the file is fully downloaded, we rename it to the .gz file.
    rename $output_tmp_file, $dl_file;
    # Now we need to decompress the file.
    # Need --force to overwrite existing file.
    my @gunzip = ("gunzip", "--force", $dl_file);
    run3 \@gunzip, \undef;
    if ($?) {
        print STDERR "Failed to gunzip $dl_file: $? $!\n";
    } else {
        print STDERR "Downloaded and uncompressed file $path\n" unless $quiet;
    }
    # Ensure file is readable by all (since files in the secure area
    # need to be readable by mysql).
    chmod 0644, $path;
    # And touch the timestamp. This is because gunzip restores the
    # original timestamp. But timezone differences means we can keep
    # downloading the same file if we are downloading daily.
    my $now = time;
    utime $now, $now, $path;
}

sub download {
    my ($self, $dir, $dl) = @_;
    return unless $dir;
    # Output directory does not exist? Then return
    # since mysql installs would have the directory
    # already created.
    if (!-e $dir) {
        print STDERR "mysql secure directory does not exist: $dir\n";
        return;
    }
    my $entries = $self->{entry};
    for my $entry (@$entries) {
        $self->_download_file($entry, $dir, $dl);
    }
}

package SchedulesDirect v20141201.0.0;

#
# Public methods
#
# Debug                        - set/return debug value
# RaiseError                   - set/return croak value
# PrintError                   - set/return carp value
# Error                        - return error value
# ErrorString                  - return error string value
# Username                     - set/return username to use
# Password                     - set/return passwordhash to use
# PasswordHash                 - set/return passwordhash to use
# obtainToken                  - obtain and return SD token
# obtainStatus                 - obtain and return SD status
# isOnline                     - return true if SD systems online
# accountExpiry                - return account expiration datetime
# obtainDataLastUpdated        - return data last updated datetime
# addLineup                    - add lineup to account
# deleteLineup                 - delete lineup from account
# getEpisodeImageFromArtwork   - return URI for episode from artwork
# obtainLineups                - return lineups in account
# obtainLineupMaps             - return maps for lineup
# obtainHeadends               - return headends in country/postal
# obtainStationsSchedules      - return stations schedules
# obtainStationsSchedulesHash  - return stations schedules hash
# obtainPrograms               - return program data for programs
# obtainProgramsArtwork        - return artwork data for programs
# obtainAvailable              - return available counties/satellites
# deleteMessage                - delete message
# uriResolve                   - convert uri to absolute
#

require 5.016;
use feature ':5.16';

use strict;
use warnings FATAL => 'all';
use warnings NONFATAL => qw(exec recursion internal malloc newline deprecated portable);
no warnings 'once';

use Carp;
use Digest::SHA qw(sha1 sha1_hex sha1_base64);
use URI;
use URI::Escape;
use Compress::Zlib;
use HTTP::Request;
use HTTP::Message;
use JSON;
use LWP::UserAgent::Determined;
use LWP::Simple;
use LWP::Protocol::https;
use LWP::ConnCache;
use Time::Duration::Parse;
use Time::HiRes qw( time );
use Data::Dumper;

sub new
  {
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = {@_};
    $self->{'Username'} = undef unless $self->{'Username'};
    $self->{'PasswordHash'} = undef unless $self->{'PasswordHash'};
    $self->{'PasswordHash'} = sha1_hex($self->{'Password'}) if defined($self->{'Password'});
    delete $self->{'Password'};
    $self->{'UserAgent'} = 'tv_grab_az_sdjson_sqlite' unless $self->{'UserAgent'};
    $self->{'Debug'} = 0 unless $self->{'Debug'};
    $self->{'RESTUrl'} = 'https://json.schedulesdirect.org/20141201' unless $self->{'RESTUrl'};
    $self->{'RaiseError'} = 0 unless $self->{'RaiseError'};    # Not (yet) implemented
    $self->{'PrintError'} = 0 unless $self->{'PrintError'};    # Not (yet) implemented
    $self->{'_Token'} = undef;
    $self->{'_TokenAcquired'} = 0;     # Refresh token every 12 hours
    $self->{'_Error'} = 0;
    $self->{'_ErrorString'} = '';
    $self->{'_Status'} = undef;
    $self->{'_StatusAcquired'} = 0;    # Refresh status every 15 minutes?
    $self->{'_JSON'} = JSON->new()->shrink(1)->utf8(1);
    $self->{'ConnCache'} = 10 unless $self->{'ConnCache'};
    $self->{'_LWP'} = LWP::UserAgent::Determined->new(agent => $self->{'UserAgent'},
                        conn_cache => LWP::ConnCache->new(total_capacity => $self->{'ConnCache'}));
    $self->{'_LWP'}->timing('1,2,5,10,20,20,20,20,20,20');
    $self->{'_LWP'}->default_header('Accept-Encoding' => scalar HTTP::Message::decodable(),
                                    'Accept' => 'application/json',
                                    'Content_Type' => 'application/json',
                                    'Pragma' => 'no-cache',
                                    'Cache-Control' => 'no-cache');

    bless($self, $class);
    return $self;
  }

END
  {
  }

sub DESTROY
  {
    my $self = shift;
    return;
  }

#
# Convenience method since many times you only
# need to know if Schedules Direct is 'online'.
#
sub isOnline
  {
    my $self = shift;

    print (STDERR "DEBUG: Entering " . (caller(0))[3] . "\n") if ($self->{'Debug'});

    my $return;

    $self->_resetError;
    $self->obtainStatus;
    if ($self->{'_Error'})
      {
        $return = undef;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }
    if (defined($self->{'_Status'}->{'systemStatus'}->[0]->{'status'}))
      {
        my $status = $self->{'_Status'}->{'systemStatus'}->[0]->{'status'};
        if ($status eq 'Online')
          {
            $return = 1;
          }
        else
          {
            $return = 0;
          }
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }
    $return = undef;
    $self->_setErrorString("Unable to obtain the Schedules Direct system status");
    $self->_CroakOrCarp;
    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
    return $return;
  }

#
# Convenience method for when the account expires
#
sub accountExpiry
  {
    my $self = shift;

    print (STDERR "DEBUG: Entering " . (caller(0))[3] . "\n") if ($self->{'Debug'});

    my $return;

    $self->_resetError;
    $self->obtainStatus;
    if ($self->{'_Error'})
      {
        $return = undef;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }
    if (defined($self->{'_Status'}->{'account'}->{'expires'}))
      {
        $return = $self->{'_Status'}->{'account'}->{'expires'};
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }
    $return = undef;
    $self->_setErrorString("Unable to obtain the Schedules Direct account expiration date");
    $self->_CroakOrCarp;
    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
    return $return;
  }

#
# Convenience method to obtain when the data was last updated
#
sub obtainDataLastUpdated
  {
    my $self = shift;

    print (STDERR "DEBUG: Entering " . (caller(0))[3] . "\n") if ($self->{'Debug'});

    my $return;

    $self->_resetError;
    $self->obtainStatus;
    if ($self->{'_Error'})
      {
        $return = undef;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }
    if (defined($self->{'_Status'}->{'lastDataUpdate'}))
      {
        $return = $self->{'_Status'}->{'lastDataUpdate'};
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }
    $self->_setErrorString("Unable to obtain the Schedules Direct data last updated");
    $return = undef;
    $self->_CroakOrCarp;
    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
    return $return;
  }

#
# Return error
#
sub Error
  {
    my $self = shift;

    print (STDERR "DEBUG: Entering " . (caller(0))[3] . "\n") if ($self->{'Debug'});

    my $return;

    $return = $self->{'_Error'};

    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    return $return;
  }

#
# Return error string
#
sub ErrorString
  {
    my $self = shift;

    print (STDERR "DEBUG: Entering " . (caller(0))[3] . "\n") if ($self->{'Debug'});

    my $return;

    $return = $self->{'_ErrorString'};

    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    return $return;
  }

#
# set/return debug status
#
sub Debug
  {
    my $self = shift;

    print (STDERR "DEBUG: Entering " . (caller(0))[3] . " with args: \n" . Data::Dumper->new(\@_)->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    if (@_) { $self->{'Debug'} = shift }

    my $return = $self->{'Debug'};

    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    return $return;
  }

#
# set/return RaiseError (croak) status
#
sub RaiseError
  {
    my $self = shift;

    print (STDERR "DEBUG: Entering " . (caller(0))[3] . " with args: \n" . Data::Dumper->new(\@_)->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $return;

    if (@_) { $self->{'RaiseError'} = shift }

    $return = $self->{'RaiseError'};

    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    return $return;
  }

#
# set/return PrintError (carp) status
#
sub PrintError
  {
    my $self = shift;

    print (STDERR "DEBUG: Entering " . (caller(0))[3] . " with args: \n" . Data::Dumper->new(\@_)->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $return;

    if (@_) { $self->{'PrintError'} = shift }

    $return = $self->{'PrintError'};

    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    return $return;
  }

#
# set/return username
#
sub Username
  {
    my $self = shift;

    print (STDERR "DEBUG: Entering " . (caller(0))[3] . " with args: \n" . Data::Dumper->new(\@_)->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $return;

    if (@_)
      {
        $self->{'Username'} = shift;
        $self->_resetSession;
      }

    $return = $self->{'Username'};

    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    return $return;
  }

#
# set/return password (return hash)
#
sub Password
  {
    my $self = shift;

    print (STDERR "DEBUG: Entering " . (caller(0))[3] . " with args: \n" . Data::Dumper->new(\@_)->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $return;

    if (@_)
      {
        my $p = shift;
        $self->{'PasswordHash'} = sha1_hex($p);
        $self->_resetSession;
      }

    $return = $self->{'PasswordHash'};

    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    return $return;
  }

#
# set/return password hash
#
sub PasswordHash
  {
    my $self = shift;

    print (STDERR "DEBUG: Entering " . (caller(0))[3] . " with args: \n" . Data::Dumper->new(\@_)->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $return;

    if (@_)
      {
        $self->{'PasswordHash'} = shift;
        $self->_resetSession;
      }

    $return = $self->{'PasswordHash'};

    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    return $return;
  }

#
# Resolve a possible relative uri to absolute URL
#
sub uriResolve
  {
    my $self = shift;

    print (STDERR "DEBUG: Entering " . (caller(0))[3] . " with args: \n" . Data::Dumper->new(\@_)->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $uri = shift;

    my $path = shift || '';

    my $return;

    # strip off leading /
    # add trailing / if needed
    #$rel = '/' . $rel . '/' if (defined($rel) && ($rel ne ''));

    $return = URI->new_abs( $uri, "$self->{'RESTUrl'}" . $path . "/" )->as_string();

    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    return $return;
  }

#
# Delete a message
#
sub deleteMessage
  {
    my $self = shift;

    print (STDERR "DEBUG: Entering " . (caller(0))[3] . " with args: \n" . Data::Dumper->new(\@_)->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $return;

    my $messageID = shift;

    $self->_resetError;

    if (!defined($messageID))
      {
        $return = 0;
        $self->_setErrorString("messageID is not specified to delete");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if (!$self->isOnline)
      {
        if ($self->{'_Error'})
          {
            $return = 0;
            print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
           return $return;

          }
        $return = 0;
        $self->_setErrorString("Schedules Direct web services is not online");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    my $request = HTTP::Request->new(DELETE => "$self->{'RESTUrl'}/messages/$messageID");

    $request->header(Token => "$self->{'_Token'}");

    print (STDERR "DEBUG:   HTTP request:\n" . Data::Dumper->new([$request])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $response = $self->{'_LWP'}->request($request);

    print (STDERR "DEBUG:   HTTP response:\n" . Data::Dumper->new([$response])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $responseCode = $response->code();
    my $responseContent = $response->decoded_content();

    print (STDERR "DEBUG:   HTTP decoded response content:\n" . Data::Dumper->new([$responseContent])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    if ($responseCode != 200)
      {
        $return = 0;
        $self->_setErrorString("HTTP response code was not successful ($responseCode)");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if (!defined($responseContent))
      {
        $return = 0;
        $self->_setErrorString("HTTP response content could not be decoded");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if ($responseContent eq '')
      {
        $return = 0;
        $self->_setErrorString("HTTP response content was empty");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    my $r = eval { $self->{'_JSON'}->decode($responseContent) };

    if (!defined($r))
      {
        $return = 0;
        $self->_setErrorString("HTTP response content was not parseable ($responseContent)");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    my $code = $r->{'code'};
    my $msg = $r->{'message'} || '';
    if (!defined($code))
      {
        $return = 0;
        $self->_setErrorString("Delete response was not valid");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }
    if ($code != 0)
      {
        $return = 0;
        $self->_setError($code);
        $self->_setErrorString("Delete request failed, code: $code, message: $msg");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    $return = 1;
    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
    return $return;
  }

#
# Add a lineup to the account
#
sub addLineup
  {

    my $self = shift;

    print (STDERR "DEBUG: Entering " . (caller(0))[3] . " with args: \n" . Data::Dumper->new(\@_)->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $return;

    my $lineup = shift;

    $self->_resetError;

    if (!defined($lineup))
      {
        $return = 0;
        $self->_setErrorString("Lineup is not specified to add");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if (!$self->isOnline)
      {
        if ($self->{'_Error'})
          {
            $return = 0;
            print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
            return $return;
          }
        $return = 0;
        $self->_setErrorString("Schedules Direct web services is not online");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    my $request = HTTP::Request->new(PUT => "$self->{'RESTUrl'}/lineups/$lineup");

    $request->header(Token => "$self->{'_Token'}");

    print (STDERR "DEBUG:   HTTP request:\n" . Data::Dumper->new([$request])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $response = $self->{'_LWP'}->request($request);

    print (STDERR "DEBUG:   HTTP response:\n" . Data::Dumper->new([$response])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $responseCode = $response->code();
    my $responseContent = $response->decoded_content();

    print (STDERR "DEBUG:   HTTP decoded response content:\n" . Data::Dumper->new([$responseContent])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    if (($responseCode == 403) || ($responseCode == 400))
      {
        if (defined($responseContent))
          {
            my $r = eval { $self->{'_JSON'}->decode($responseContent) };
            if (defined($r))
              {
                $self->_setError($r->{'code'}) if (defined($r->{'code'}));
                my $msg = $r->{'message'} || "(no message text returned for code)";
                $self->_setErrorString("$msg");
                $return = 0;
                $self->_CroakOrCarp;
                print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
                return $return;

              }
            $return = 0;
            $self->_setErrorString("HTTP response content was not parseable: $responseContent");
            $self->_CroakOrCarp;
            print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
            return $return;
          }
        $return = 0;
        $self->_setErrorString("HTTP response content could not be decoded for response code $responseCode");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if ($responseCode != 200)
      {
        $return = 0;
        $self->_setErrorString("HTTP response code was not successful ($responseCode)");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if (!defined($responseContent))
      {
        $return = 9;
        $self->_setErrorString("HTTP response content could not be decoded");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if ($responseContent eq '')
      {
        $return = 0;
        $self->_setErrorString("HTTP response content was empty");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    my $r = eval { $self->{'_JSON'}->decode($responseContent) };

    if (!defined($r))
      {
        $return = 0;
        $self->_setErrorString("HTTP response content was not parseable ($responseContent)");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    my $code = $r->{'code'};
    my $msg = $r->{'message'} || '';
    if (!defined($code))
      {
        $return = 0;
        $self->_setErrorString("Add lineup response was not valid (code not returned)");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }
    if ($code != 0)
      {
        $return = 0;
        $self->_setError($code);
        $self->_setErrorString("Add lineup request failed with code: $code, message: $msg");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    $return = 1;
    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
    return $return;
  }

#
# Delete a lineup from the account
#
sub deleteLineup
  {
    my $self = shift;

    print (STDERR "DEBUG: Entering " . (caller(0))[3] . " with args: \n" . Data::Dumper->new(\@_)->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $return;

    my $lineup = shift;

    $self->_resetError;

    if (!defined($lineup))
      {
        $return = 0;
        $self->_setErrorString("Lineup is not specified to delete");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if (!$self->isOnline)
      {
        if ($self->{'_Error'})
          {
            $return = 0;
            print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
           return $return;

          }
        $return = 0;
        $self->_setErrorString("Schedules Direct web services is not online");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    my $request = HTTP::Request->new(DELETE => "$self->{'RESTUrl'}/lineups/$lineup");

    $request->header(Token => "$self->{'_Token'}");

    print (STDERR "DEBUG:   HTTP request:\n" . Data::Dumper->new([$request])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $response = $self->{'_LWP'}->request($request);

    print (STDERR "DEBUG:   HTTP response:\n" . Data::Dumper->new([$response])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $responseCode = $response->code();
    my $responseContent = $response->decoded_content();

    print (STDERR "DEBUG:   HTTP decoded response content:\n" . Data::Dumper->new([$responseContent])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    if ($responseCode != 200)
      {
        $return = 0;
        $self->_setErrorString("HTTP response code was not successful ($responseCode)");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if (!defined($responseContent))
      {
        $return = 0;
        $self->_setErrorString("HTTP response content could not be decoded");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if ($responseContent eq '')
      {
        $return = 0;
        $self->_setErrorString("HTTP response content was empty");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    my $r = eval { $self->{'_JSON'}->decode($responseContent) };

    if (!defined($r))
      {
        $return = 0;
        $self->_setErrorString("HTTP response content was not parseable ($responseContent)");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    my $code = $r->{'code'};
    my $msg = $r->{'message'} || '';
    if (!defined($code))
      {
        $return = 0;
        $self->_setErrorString("Delete response was not valid");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }
    if ($code != 0)
      {
        $return = 0;
        $self->_setError($code);
        $self->_setErrorString("Delete request failed, code: $code, message: $msg");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    $return = 1;
    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
    return $return;
  }

#
# Obtain the lineups in the account
#
sub obtainLineups
  {
    my $self = shift;

    print (STDERR "DEBUG: Entering " . (caller(0))[3] . "\n") if ($self->{'Debug'});

    my $return;

    $self->_resetError;

    if (!$self->isOnline)
      {
        if ($self->{'_Error'})
          {
            $return = undef;
            print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
            return $return;
          }
        $return = undef;
        $self->_setErrorString("Schedules Direct web services is not online");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    my $request = HTTP::Request->new(GET => "$self->{'RESTUrl'}/lineups");

    $request->header('Token' => "$self->{'_Token'}");

    print (STDERR "DEBUG:   HTTP request:\n" . Data::Dumper->new([$request])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $response = $self->{'_LWP'}->request($request);

    print (STDERR "DEBUG:   HTTP response:\n" . Data::Dumper->new([$response])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $responseCode = $response->code();
    my $responseContent = $response->decoded_content();

    print (STDERR "DEBUG:   HTTP decoded response content:\n" . Data::Dumper->new([$responseContent])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    if ($responseCode == 400)
      {
        # (bug?) Rather than returning an empty array, SD returns 400 error
        # We will convert this to an empty array (no lineups)
        if (defined($responseContent))
          {
            my $r = eval { $self->{'_JSON'}->decode($responseContent) };
            if (defined($r) && defined($r->{'code'}) && ($r->{'code'} == 4102))
              {
                $return = {};
                $return->{'datetime'} = $r->{'datetime'} || '1970-01-01T00:00:00Z';
                $return->{'serverID'} = $r->{'serverID'} || 'internal';
                $return->{'response'} = $r->{'response'} || 'NO_LINEUPS';
                $return->{'message'} = $r->{'message'} || 'No lineups have been added to this account';
                $return->{'code'} = 4102;
                $return->{'lineups'} = [];
                print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
                return $return;
              }
            $return = undef;
            $self->_setErrorString("HTTP response content was not parseable: $responseContent");
            $self->_CroakOrCarp;
            print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
            return $return;
          }
        $return = undef;
        $self->_setErrorString("HTTP response content could not be decoded");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if ($responseCode != 200)
      {
        $return = undef;
        $self->_setErrorString("HTTP response code was not successful: $responseCode");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if (!defined($responseContent))
      {
        $return = undef;
        $self->_setErrorString("HTTP response content could not be decoded");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if ($responseContent eq '')
      {
        $return = undef;
        $self->_setErrorString("HTTP response content was empty");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    my $r = eval { $self->{'_JSON'}->decode($responseContent) };

    if (!defined($r))
      {
        $return = undef;
        $self->_setErrorString("HTTP response content was not parseable: $responseContent");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    $return = $r;

    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
    return $return;
  }

#
# ObtainLineupMaps
#
sub obtainLineupMaps
  {
    my $self = shift;

    print (STDERR "DEBUG: Entering " . (caller(0))[3] . " with args: \n" . Data::Dumper->new(\@_)->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $return;

    my $lineup = shift;

    $self->_resetError;

    if (!defined($lineup))
      {
        $return = undef;
        $self->_setErrorString("Schedules Direct lineup not specified");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if (!$self->isOnline)
      {
        if ($self->{'_Error'})
          {
            $return = undef;
            print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
            return $return;
          }
        $return = undef;
        $self->_setErrorString("Schedules Direct web services is not online");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    my $request = HTTP::Request->new(GET => "$self->{'RESTUrl'}/lineups/$lineup");

    $request->header('Token' => "$self->{'_Token'}",
                     'verboseMap' => 'true');

    print (STDERR "DEBUG:   HTTP request:\n" . Data::Dumper->new([$request])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $response = $self->{'_LWP'}->request($request);

    print (STDERR "DEBUG:   HTTP response:\n" . Data::Dumper->new([$response])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $responseCode = $response->code();
    my $responseContent = $response->decoded_content();

    print (STDERR "DEBUG:   HTTP decoded response content:\n" . Data::Dumper->new([$responseContent])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    if ($responseCode != 200)
      {
        $return = undef;
        $self->_setErrorString("HTTP response code was not successful ($responseCode)");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if (!defined($responseContent))
      {
        $return = undef;
        $self->_setErrorString("HTTP response content could not be decoded");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if ($responseContent eq '')
      {
        $return = undef;
        $self->_setErrorString("HTTP response content was empty");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    my $r = eval { $self->{'_JSON'}->decode($responseContent) };

    if (!defined($r))
      {
        $return = undef;
        $self->_setErrorString("HTTP response content was not parseable ($responseContent)");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    $return = $r;

    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
    return $return;
  }

#
# Return list of headends in country/postal code
#
sub obtainHeadends
  {
    my $self = shift;

    print (STDERR "DEBUG: Entering " . (caller(0))[3] . " with args: \n" . Data::Dumper->new(\@_)->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $return;

    my ($country, $postalcode, undef) = @_;

    $self->_resetError;

    if (!defined($country))
      {
        $return = undef;
        $self->_setErrorString("Country code not provided for headend list");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }
    if (!defined($postalcode))
      {
        $return = undef;
        $self->_setErrorString("Postal code code not provided for headend list");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if (!$self->isOnline)
      {
        if ($self->{'_Error'})
          {
            $return = undef;
            print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
            return $return;
          }
        $return = undef;
        $self->_setErrorString("Schedules Direct web services is not online");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    $country = uri_escape($country);
    $postalcode = uri_escape($postalcode);

    my $request = HTTP::Request->new(GET => "$self->{'RESTUrl'}/headends?country=$country\&postalcode=$postalcode");

    $request->header(Token => "$self->{'_Token'}");

    print (STDERR "DEBUG:   HTTP request:\n" . Data::Dumper->new([$request])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $response = $self->{'_LWP'}->request($request);

    print (STDERR "DEBUG:   HTTP response:\n" . Data::Dumper->new([$response])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $responseCode = $response->code();
    my $responseContent = $response->decoded_content();

    print (STDERR "DEBUG:   HTTP decoded response content:\n" . Data::Dumper->new([$responseContent])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    if ($responseCode == 400)
      {
        # (bug?) Rather than returning an empty array, SD returns error
        # we will convert this to an empty array
        my $r = eval { $self->{'_JSON'}->decode($responseContent) };
        if (defined($r))
          {
            my $code = $r->{'code'};
            my $msg = $r->{'message'} || '';
            if (defined($code))
              {
                $self->_setError($code);
                if ($code == 2102)
                  {
                    $return = [];
                    $self->_setErrorString("No headends in specified country/postalcode");
                    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
                    return $return;
                  }
                $return = undef;
                $self->_setErrorString("Error obtaining headends ($code): $msg");
                $self->_CroakOrCarp;
                print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
                return $return;
              }
          }
        $return = undef;
        $self->_setErrorString("HTTP response code was not successful ($responseCode)");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if ($responseCode != 200)
      {
        $return = undef;
        $self->_setErrorString("HTTP response code was not successful ($responseCode)");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if (!defined($responseContent))
      {
        $return = undef;
        $self->_setErrorString("HTTP response content could not be decoded");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if ($responseContent eq '')
      {
        $return = undef;
        $self->_setErrorString("HTTP response content was empty");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    my $r = eval { $self->{'_JSON'}->decode($responseContent) };

    if (!defined($r))
      {
        $return = undef;
        $self->_setErrorString("HTTP response content was not parseable ($responseContent)");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    $return = $r;

    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
    return $return;
  }

#
# _obtainProgramsCommon
#
sub _obtainProgramsCommon
  {
    my $self = shift;
    my $url = shift;
    print (STDERR "DEBUG: Entering " . (caller(0))[3] . " with url: $url and args: \n" . Data::Dumper->new(\@_)->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $return;

    my (@programs) = @_;

    $self->_resetError;

    if (!$self->isOnline)
      {
        if ($self->{'_Error'})
          {
            $return = undef;
            print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
            return $return;
          }
        $return = undef;
        $self->_setErrorString("Schedules Direct web services is not online");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if (scalar(@programs) == 0)
      {
        $return = [];
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    my $request = HTTP::Request->new(POST => "$self->{'RESTUrl'}/$url");

    $request->header('Token' => "$self->{'_Token'}");

    $request->content($self->{'_JSON'}->encode(\@programs));

    print (STDERR "DEBUG:   HTTP request:\n" . Data::Dumper->new([$request])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $response = $self->{'_LWP'}->request($request);

    print (STDERR "DEBUG:   HTTP response:\n" . Data::Dumper->new([$response])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $responseCode = $response->code();
    my $responseContent = $response->decoded_content();

    print (STDERR "DEBUG:   HTTP decoded response content:\n" . Data::Dumper->new([$responseContent])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    if ($responseCode != 200)
      {
        $return = undef;
        $self->_setErrorString("HTTP response code was not successful ($responseCode)");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if (!defined($responseContent))
      {
        $return = undef;
        $self->_setErrorString("HTTP response content could not be decoded");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if ($responseContent eq '')
      {
        $return = undef;
        $self->_setErrorString("HTTP response content was empty");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    my $r = eval { $self->{'_JSON'}->convert_blessed->decode($responseContent) };

    if (!defined($r))
      {
        $return = undef;
        $self->_setErrorString("HTTP response content was not parseable: $responseContent");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    $return = $r;

    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
    return $return;
  }


#
# obtainPrograms
#
sub obtainPrograms
  {
    my $self = shift;

    print (STDERR "DEBUG: Entering " . (caller(0))[3] . " with args: \n" . Data::Dumper->new(\@_)->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
    return $self->_obtainProgramsCommon("programs", @_);
  }

#
# obtainProgramsArtwork
#
sub obtainProgramsArtwork
  {
    my $self = shift;

    print (STDERR "DEBUG: Entering " . (caller(0))[3] . " with args: \n" . Data::Dumper->new(\@_)->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
    return $self->_obtainProgramsCommon("metadata/programs", @_);
  }

#
# obtainStationsSchedules
#
sub obtainStationsSchedules
  {
    my $self = shift;

    print (STDERR "DEBUG: Entering " . (caller(0))[3] . " with args: \n" . Data::Dumper->new(\@_)->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $return;

    my (@schedulesRequest) = @_;

    $self->_resetError;

    if (!$self->isOnline)
      {
        if ($self->{'_Error'})
          {
            $return = undef;
            print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
            return $return;

          }
        $return = undef;
        $self->_setErrorString("Schedules Direct web services is not online");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if (scalar(@schedulesRequest) == 0)
      {
        $return = [];
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    my $request = HTTP::Request->new(POST => "$self->{'RESTUrl'}/schedules");

    $request->content($self->{'_JSON'}->encode(\@schedulesRequest));

    $request->header('Token' => "$self->{'_Token'}");

    print (STDERR "DEBUG:   HTTP request:\n" . Data::Dumper->new([$request])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $response = $self->{'_LWP'}->request($request);

    print (STDERR "DEBUG:   HTTP response:\n" . Data::Dumper->new([$response])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $responseCode = $response->code();
    my $responseContent = $response->decoded_content();

    print (STDERR "DEBUG:   HTTP decoded response content:\n" . Data::Dumper->new([$responseContent])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    if ($responseCode != 200)
      {
        $return = undef;
        $self->_setErrorString("HTTP response code was not successful ($responseCode)");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if (!defined($responseContent))
      {
        $return = undef;
        $self->_setErrorString("HTTP response content could not be decoded");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if ($responseContent eq '')
      {
        $return = undef;
        $self->_setErrorString("HTTP response content was empty");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    my $r = eval { $self->{'_JSON'}->convert_blessed->decode($responseContent) };

    if (!defined($r))
      {
        $return = undef;
        $self->_setErrorString("HTTP response content was not parseable: $responseContent");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    $return = $r;

    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
    return $return;
  }

#
# obtainStationsSchedulesHash
#
sub obtainStationsSchedulesHash
  {
    my $self = shift;

    print (STDERR "DEBUG: Entering " . (caller(0))[3] . " with args: \n" . Data::Dumper->new(\@_)->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $return;

    my (@stationsRequest) = @_;

    $self->_resetError;

    if (!$self->isOnline)
      {
        if ($self->{'_Error'})
          {
            $return = undef;
            print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
            return $return;
          }
        $return = undef;
        $self->_setErrorString("Schedules Direct web services is not online");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    my $request = HTTP::Request->new(POST => "$self->{'RESTUrl'}/schedules/md5");

    $request->content($self->{'_JSON'}->encode(\@stationsRequest));

    $request->header('Token' => "$self->{'_Token'}");

    print (STDERR "DEBUG:   HTTP request:\n" . Data::Dumper->new([$request])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $response = $self->{'_LWP'}->request($request);

    print (STDERR "DEBUG:   HTTP response:\n" . Data::Dumper->new([$response])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $responseCode = $response->code();
    my $responseContent = $response->decoded_content();

    print (STDERR "DEBUG:   HTTP decoded response content:\n" . Data::Dumper->new([$responseContent])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    if ($responseCode != 200)
      {
        $return = undef;
        $self->_setErrorString("HTTP response code was not successful ($responseCode)");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if (!defined($responseContent))
      {
        $return = undef;
        $self->_setErrorString("HTTP response content could not be decoded");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if ($responseContent eq '')
      {
        $return = undef;
        $self->_setErrorString("HTTP response content was empty");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    my $r = eval { $self->{'_JSON'}->convert_blessed->decode($responseContent) };

    if (!defined($r))
      {
        $return = undef;
        $self->_setErrorString("HTTP response content was not parseable: $responseContent");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    $return = $r;

    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
    return $return;
  }

#
# obtainAvailable
#
sub obtainAvailable
  {
    my $self = shift;

    print (STDERR "DEBUG: Entering " . (caller(0))[3] . " with args: \n" . Data::Dumper->new(\@_)->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $return;

    my $type = shift;

    my $path = shift;

    $type = '' if (!defined($type));

    $path = '' if (!defined($path));

    $self->_resetError;

    if (!$self->isOnline)
      {
        if ($self->{'_Error'})
          {
            $return = undef;
            print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
            return $return;

          }
        $return = undef;
        $self->_setErrorString("Schedules Direct web services is not online");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if (($path ne '') && ($type eq ''))
      {
        $return = undef;
        $self->_setErrorString("obtainAvailable request is not valid (type=$type, path=$path)");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    my $request = HTTP::Request->new(GET => "$self->{'RESTUrl'}/available");

    $request->header('Token' => "$self->{'_Token'}");

    print (STDERR "DEBUG:   HTTP request:\n" . Data::Dumper->new([$request])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $response = $self->{'_LWP'}->request($request);

    print (STDERR "DEBUG:   HTTP response:\n" . Data::Dumper->new([$response])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $responseCode = $response->code();
    my $responseContent = $response->decoded_content();

    print (STDERR "DEBUG:   HTTP decoded response content:\n" . Data::Dumper->new([$responseContent])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    if ($responseCode != 200)
      {
        $return = undef;
        $self->_setErrorString("HTTP response code was not successful ($responseCode)");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if (!defined($responseContent))
      {
        $return = undef;
        $self->_setErrorString("HTTP response content could not be decoded");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if ($responseContent eq '')
      {
        $return = undef;
        $self->_setErrorString("HTTP response content was empty");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    my $r = eval { $self->{'_JSON'}->convert_blessed->decode($responseContent) };

    if (!defined($r))
      {
        $return = undef;
        $self->_setErrorString("HTTP response content was not parseable: $responseContent");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if ($type eq '')
      {
        $return = $r;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if (ref($r) ne 'ARRAY')
      {
        $return = undef;
        $self->_setErrorString("HTTP response content was malformed (not an array)");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    foreach my $e(@{$r})
      {
        if (ref($e) ne 'HASH')
          {
            $return = undef;
            $self->_setErrorString("HTTP response content was malformed (not an array of hashes)");
            $self->_CroakOrCarp;
            print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
            return $return;
          }
        if (defined($e->{'type'}) && ($e->{'type'} eq "$type"))
          {
            if (defined($e->{'uri'}))
              {
                my $uri = $e->{'uri'};

                $uri =~ s/\/\{.*?\}$//;        # Bad adjustment?

                $request = HTTP::Request->new(GET => $self->uriResolve($uri) . "$path");

                $request->header('Token' => "$self->{'_Token'}");

                print (STDERR "DEBUG:   HTTP request:\n" . Data::Dumper->new([$request])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

                $response = $self->{'_LWP'}->request($request);

                print (STDERR "DEBUG:   HTTP response:\n" . Data::Dumper->new([$response])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

                $responseCode = $response->code();
                $responseContent = $response->decoded_content();

                print (STDERR "DEBUG:   HTTP decoded response content:\n" . Data::Dumper->new([$responseContent])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

                if ($responseCode != 200)
                  {
                    $return = undef;
                    $self->_setErrorString("HTTP response code was not successful ($responseCode)");
                    $self->_CroakOrCarp;
                    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
                    return $return;
                  }

                if (!defined($responseContent))
                  {
                    $return = undef;
                    $self->_setErrorString("HTTP response content could not be decoded");
                    $self->_CroakOrCarp;
                    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
                    return $return;
                  }

                if ($responseContent eq '')
                  {
                    $return = undef;
                    $self->_setErrorString("HTTP response content was empty");
                    $self->_CroakOrCarp;
                    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
                    return $return;
                  }

                $r = eval { $self->{'_JSON'}->convert_blessed->decode($responseContent) };

                if (!defined($r))
                  {
                    $return = undef;
                    $self->_setErrorString("HTTP response content was not parseable: $responseContent");
                    $self->_CroakOrCarp;
                    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
                    return $return;
                  }

                $return = $r;
                print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
                return $return;
              }
            else
              {
                $return = undef;
                $self->_setErrorString("HTTP response content was malformed (uri not specified in available response)");
                $self->_CroakOrCarp;
                print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
                return $return;
              }
          }
      }

    $return = undef;
    $self->_setErrorString("HTTP response did not match type=$type");
    $self->_CroakOrCarp;
    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
    return $return;
  }

#
# obtainStatus
#
sub obtainStatus
  {
    my $self = shift;

    print (STDERR "DEBUG: Entering " . (caller(0))[3] . "\n") if ($self->{'Debug'});

    my $return;

    $self->_resetError;

    $self->obtainToken;

    if ($self->{'_Error'})
      {
        $return = undef;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    my $now = time();

    #Reuse existing status if in current session and last status update < 15 min ago
    if (defined($self->{'_Status'}) && ($self->{'_StatusAcquired'} > ($now - 900)))
      {
        print (STDERR "DEBUG:   (re)using current status\n") if ($self->{'Debug'});
        $return = $self->{'_Status'};
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    my $request = HTTP::Request->new(GET => "$self->{'RESTUrl'}/status");

    $request->header('Token' => "$self->{'_Token'}");

    print (STDERR "DEBUG:   HTTP request:\n" . Data::Dumper->new([$request])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $response = $self->{'_LWP'}->request($request);

    print (STDERR "DEBUG:   HTTP response:\n" . Data::Dumper->new([$response])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $responseCode = $response->code();
    my $responseContent = $response->decoded_content();

    print (STDERR "DEBUG:   HTTP decoded response content:\n" . Data::Dumper->new([$responseContent])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    if ($responseCode != 200)
      {
        $self->_setErrorString("HTTP response code was not successful ($responseCode)");
        $self->_CroakOrCarp;
        $return = undef;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if (!defined($responseContent))
      {
        $self->_setErrorString("HTTP response content could not be decoded");
        $self->_CroakOrCarp;
        $return = undef;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if ($responseContent eq '')
      {
        $self->_setErrorString("HTTP response content was empty");
        $self->_CroakOrCarp;
        $return = undef;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    my $r = eval { $self->{'_JSON'}->decode($responseContent) };

    if (!defined($r))
      {
        $self->_setErrorString("HTTP response content was not parseable: $responseContent");
        $self->_CroakOrCarp;
        $return = undef;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    my $code = $r->{'code'};
    my $message = $r->{'message'} || '' ;

    if (!defined($code) || !defined($message))
      {
        $self->_setErrorString("Schedules Direct status request response was not valid: $responseContent");
        $self->_CroakOrCarp;
        $return = undef;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if (($code != 0))
      {
        $self->_setError($code);
        $self->_setErrorString("Schedules Direct status request response message: $message ($code)");
        $self->_CroakOrCarp;
        $return = undef;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    $self->{'_Status'} = $r;

    $self->{'_StatusAcquired'} = $now;

    $return = $r;

    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    return $return;
  }

#
# obtainToken
#
sub obtainToken
  {
    my $self = shift;

    print (STDERR "DEBUG: Entering " . (caller(0))[3] . " with args: \n" . Data::Dumper->new(\@_)->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $return;

    my ($username, $password, $passwordHash, undef) = @_;

    $self->_resetError;

    my $now = time();

    $self->Username($username) if defined($username);
    $self->Password($password) if defined($password);
    $self->PasswordHash($passwordHash) if defined($passwordHash);

    if (!defined($self->{'Username'}))
      {
        $return = undef;
        $self->_setErrorString("Username not provided for obtaining Schedules Direct token");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }
    if (!defined($self->{'PasswordHash'}))
      {
        $return = undef;
        $self->_setErrorString("Password not provided for obtaining Schedules Direct token");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    # Reuse existing token if in current session and last token update < 12 hours ago
    if (defined($self->{'_Token'}) && ($self->{'_TokenAcquired'} > ($now - 43200)))
      {
        print (STDERR "DEBUG:   (re)using current token\n") if ($self->{'Debug'});
        $return = $self->{'_Token'};
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    $self->_resetSession;

    my $request = HTTP::Request->new(POST => "$self->{'RESTUrl'}/token");

    my %json_data = ("username" => $self->{'Username'}, "password" => $self->{'PasswordHash'});

    $request->content($self->{'_JSON'}->encode(\%json_data));

    print (STDERR "DEBUG:   HTTP request:\n" . Data::Dumper->new([$request])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $response = $self->{'_LWP'}->request($request);

    print (STDERR "DEBUG:   HTTP response:\n" . Data::Dumper->new([$response])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $responseCode = $response->code();
    my $responseContent = $response->decoded_content();

    print (STDERR "DEBUG:   HTTP decoded response content:\n" . Data::Dumper->new([$responseContent])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    if ($responseCode == 400)
      {
        if (!defined($responseContent))
          {
            $return = undef;
            $self->_setErrorString("HTTP response content could not be decoded for response code 400");
            $self->_CroakOrCarp;
            print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
            return $return;
          }

        if ($responseContent eq '')
          {
            $return = undef;
            $self->_setErrorString("HTTP response content was empty for response code 400.");
            $self->_CroakOrCarp;
            print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
            return $return;
          }

        my $r = eval { $self->{'_JSON'}->decode($responseContent) };

        if (!defined($r))
          {
            $return = undef;
            $self->_setErrorString("HTTP response content was not valid JSON for response code 400: $responseContent)");
            $self->_CroakOrCarp;
            print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
            return $return;
          }

        my $code = $r->{'code'};
        my $message = $r->{'message'};

        if (!defined($code) || !defined($message))
          {
            $return = undef;
            $self->_setErrorString("Schedules Direct authorization token response was not valid 400: $responseContent");
            $self->_CroakOrCarp;
            print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
            return $return;
          }

        if (($code != 0) || ("$message" ne "OK"))
          {
            $return = undef;
            $self->_setErrorString("Schedules Direct authorization token request code: $code, message: $message");
            $self->_CroakOrCarp;
            print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
            return $return;
          }

        $return = undef;
        $self->_setErrorString("HTTP response code and content inconsistent for code 400: $responseContent");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if ($responseCode != 200)
      {
        $return = undef;
        $self->_setErrorString("HTTP response code was $responseCode");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if (!defined($responseContent))
      {
        $return = undef;
        $self->_setErrorString("HTTP response content could not be decoded");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if ($responseContent eq '')
      {
        $return = undef;
        $self->_setErrorString("HTTP response content was empty");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    my $r = eval { $self->{'_JSON'}->decode($responseContent) };

    if (!defined($r))
      {
        $return = undef;
        $self->_setErrorString("HTTP response content was not parseable: $responseContent");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    my $code = $r->{'code'};
    my $message = $r->{'message'};
    my $token = $r->{'token'};

    if (!defined($code) || !defined($message))
      {
        $return = undef;
        $self->_setErrorString("Schedules Direct authorization token response was not valid: $responseContent");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if (($code != 0) || ("$message" ne "OK"))
      {
        $return = undef;
        $self->_setError($code);
        $self->_setErrorString("Schedules Direct authorization token response code: $code, message: $message");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    if (!defined($token))
      {
        $return = undef;
        $self->_setErrorString("Schedules Direct authorization token was not returned: $responseContent");
        $self->_CroakOrCarp;
        print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});
        return $return;
      }

    $self->{'_Token'} = $token;
    $self->{'_TokenAcquired'} = $now;

    $return = $self->{'_Token'};

    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    return $return;
  }

sub _resetError
  {
    my $self = shift;

    print (STDERR "DEBUG: Entering " . (caller(0))[3] . "\n") if ($self->{'Debug'});

    $self->{'_Error'} = 0;
    $self->{'_ErrorString'} = '';

    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . "\n") if ($self->{'Debug'});

    return;
  }

sub _setError
  {
    my $self = shift;

    print (STDERR "DEBUG: Entering " . (caller(0))[3] . " with args: \n" . Data::Dumper->new(\@_)->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $return;

    if (@_) { $self->{'_Error'} = shift || (-1) }

    $return = $self->{'_Error'};

    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    return $return;
  }

sub _setErrorString
  {
    my $self = shift;

    print (STDERR "DEBUG: Entering " . (caller(0))[3] . " with args: \n" . Data::Dumper->new(\@_)->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    my $return;

    $self->{'_Error'} = (-1) if (!defined($self->{'_Error'}) || $self->{'_Error'} == 0);
    if (@_) { $self->{'_ErrorString'} = shift || '' }

    $return = $self->{'_ErrorString'};

    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . " with: \n" . Data::Dumper->new([$return])->Pad('DEBUG:   ')->Useqq(1)->Dump) if ($self->{'Debug'});

    return $return;
  }

sub _resetSession
  {
    my $self = shift;

    print (STDERR "DEBUG: Entering " . (caller(0))[3] . "\n") if ($self->{'Debug'});

    $self->{'_Token'} = undef;
    $self->{'_Status'} = undef;
    $self->_resetError();

    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . "\n") if ($self->{'Debug'});

    return;
  }

sub _CroakOrCarp
  {
    my $self = shift;

    print (STDERR "DEBUG: Entering " . (caller(0))[3] . "\n") if ($self->{'Debug'});

    if ($self->{'_Error'})
      {
        if ($self->{'RaiseError'})
          {
            Carp::croak($self->{'_ErrorString'});
          }
        if ($self->{'PrintError'})
          {
            Carp::carp($self->{'_ErrorString'});
          }
      }

    print (STDERR "DEBUG: Returning from " . (caller(0))[3] . "\n") if ($self->{'Debug'});

    return;
  }

# Try to get a decent image to use for the artwork.
sub getEpisodeImageFromArtwork
  {
      my $self = shift;
      print (STDERR "DEBUG: Entering " . (caller(0))[3] . "\n") if ($self->{'Debug'});
      my ($art, $allowAnyArt) = @_;
      return unless $art;
      return unless $art->{data};
      return unless ref($art->{data}) eq 'ARRAY';
      # Allow user to configure maximum size we prefer our artwork.
      # If we find no decent artwork then we may use larger.
      state $maxWidth = $opt->{'artwork-max-width'} // $conf->{'artwork-max-width'} // 1080;
      # Prefer "poster" shape elements to wide art since that seems to
      # be what clients prefer to show.
      my %required_aspect;
      @required_aspect{qw/3x2 2x3 3x4/} = ();
      # For the moment simply return the first match we find that
      # exceeds the given width and is of an appropriate category
      # since any art is better than no art. If $allowAnyArt then
      # we allow any category of image.
      my @fallback_tuple;
      for my $minWidth (900, 400, 200, 0) {
          next if $minWidth > $maxWidth && !$allowAnyArt;
          # Testing suggests that SD appends images to its artwork as new
          # series become available, so prefer the later artwork by
          # reversing the array.
          for my $d (reverse(@{$art->{data}})) {
              next unless $d;
              my $uri = $d->{uri};
              next unless $uri;
              # Episodes/shows can have tiers. 'Season' can have
              # season number in text on it, but metadata doesn't tell
              # us _what_ season, so that means you see S9 text even
              # if you are on season S13. So we prefer Series which
              # is generic enough to apply to any episode.
              my $tier = $d->{tier};
              next if $tier && !$allowAnyArt && $tier ne 'Series';

              my $imgWidth = $d->{width};
              #my $aspect = $d->{aspect} // "N/A";
              #my $category = $d->{category};
              # say STDERR "$minWidth $allowAnyArt $imgWidth $aspect $category $uri";

              # If we're size 0 it means we couldn't find a decent
              # image so use any other images we can find such as
              # cast images or Iconic images. Seems to happen on
              # some daytime shows. We allow this as an option
              # since on EP we don't want generic art but to use
              # SH art instead; but for MV we are better using
              # any art.
              my $canUseImage = $minWidth == 0 && $allowAnyArt;
              # Otherwise we're looking for a good high quality image.
              if (!$canUseImage) {
                  # https://github.com/SchedulesDirect/JSON-Service/wiki/API-20141201#field-meanings
                  $canUseImage = $imgWidth > $minWidth && $imgWidth < $maxWidth;
                  if ($canUseImage) {
                      my $category = $d->{category};
                      $canUseImage = $category &&
                        ($category eq 'Poster Art' ||
                         $category eq 'Box Art' ||
                         $category eq 'VOD Art' ||
                         $category eq 'Staple' ||
                         $category =~ 'Banner-L' ||
                         $category eq 'Logo');
                  }
              }
              if ($canUseImage) {
                  my $aspect = $d->{aspect} // "N/A";
                  if (exists $required_aspect{$aspect}) {
                      # Correct aspect ratio, so use it.
                      return ($uri, $imgWidth, $d->{height});
                  } else {
                      @fallback_tuple = ($uri, $imgWidth, $d->{height}) unless scalar @fallback_tuple;
                  }
              }
          }
      }
      if (scalar @fallback_tuple) {
          return @fallback_tuple;
      }
      return;
  }
1;
